{"version":3,"sources":["fable.min.js","node_modules/browser-pack/_prelude.js","node_modules/async.eachlimit/index.js","node_modules/async.iterator/index.js","node_modules/async.util.eachoflimit/index.js","node_modules/async.util.ensureasync/index.js","node_modules/async.util.isarray/index.js","node_modules/async.util.isarraylike/index.js","node_modules/async.util.keyiterator/index.js","node_modules/async.util.keys/index.js","node_modules/async.util.noop/index.js","node_modules/async.util.once/index.js","node_modules/async.util.onlyonce/index.js","node_modules/async.util.restparam/index.js","node_modules/async.util.setimmediate/index.js","node_modules/async.util.withoutindex/index.js","node_modules/async.waterfall/index.js","node_modules/base64-js/index.js","node_modules/big.js/big.js","node_modules/buffer/index.js","node_modules/builtin-status-codes/browser.js","node_modules/cachetrax/source/CacheTrax.js","node_modules/cachetrax/source/LinkedList-Node.js","node_modules/cachetrax/source/LinkedList.js","node_modules/call-bind-apply-helpers/actualApply.js","node_modules/call-bind-apply-helpers/functionApply.js","node_modules/call-bind-apply-helpers/functionCall.js","node_modules/call-bind-apply-helpers/index.js","node_modules/call-bind-apply-helpers/reflectApply.js","node_modules/call-bound/index.js","node_modules/cookie/dist/index.js","node_modules/dayjs/dayjs.min.js","node_modules/dayjs/plugin/advancedFormat.js","node_modules/dayjs/plugin/isoWeek.js","node_modules/dayjs/plugin/relativeTime.js","node_modules/dayjs/plugin/timezone.js","node_modules/dayjs/plugin/utc.js","node_modules/dayjs/plugin/weekOfYear.js","node_modules/dayjs/plugin/weekday.js","node_modules/dunder-proto/get.js","node_modules/es-define-property/index.js","node_modules/es-errors/eval.js","node_modules/es-errors/index.js","node_modules/es-errors/range.js","node_modules/es-errors/ref.js","node_modules/es-errors/syntax.js","node_modules/es-errors/type.js","node_modules/es-errors/uri.js","node_modules/es-object-atoms/index.js","node_modules/events/events.js","node_modules/fable-log/package.json","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log-Logger-SimpleFlatFile.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-serviceproviderbase/package.json","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","node_modules/fable-settings/package.json","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/package.json","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/get-intrinsic/index.js","node_modules/get-proto/Object.getPrototypeOf.js","node_modules/get-proto/Reflect.getPrototypeOf.js","node_modules/get-proto/index.js","node_modules/gopd/gOPD.js","node_modules/gopd/index.js","node_modules/has-symbols/index.js","node_modules/has-symbols/shams.js","node_modules/hasown/index.js","node_modules/https-browserify/index.js","node_modules/ieee754/index.js","node_modules/inherits/inherits_browser.js","node_modules/manyfest/source/Manyfest-CleanWrapCharacters.js","node_modules/manyfest/source/Manyfest-HashTranslation.js","node_modules/manyfest/source/Manyfest-LogToConsole.js","node_modules/manyfest/source/Manyfest-ObjectAddress-CheckAddressExists.js","node_modules/manyfest/source/Manyfest-ObjectAddress-DeleteValue.js","node_modules/manyfest/source/Manyfest-ObjectAddress-GetValue.js","node_modules/manyfest/source/Manyfest-ObjectAddress-Parser.js","node_modules/manyfest/source/Manyfest-ObjectAddress-SetValue.js","node_modules/manyfest/source/Manyfest-ObjectAddressGeneration.js","node_modules/manyfest/source/Manyfest-ParseConditionals.js","node_modules/manyfest/source/Manyfest-SchemaManipulation.js","node_modules/manyfest/source/Manyfest.js","node_modules/math-intrinsics/abs.js","node_modules/math-intrinsics/floor.js","node_modules/math-intrinsics/isNaN.js","node_modules/math-intrinsics/max.js","node_modules/math-intrinsics/min.js","node_modules/math-intrinsics/pow.js","node_modules/math-intrinsics/round.js","node_modules/math-intrinsics/sign.js","node_modules/object-inspect/index.js","node_modules/once/once.js","node_modules/path-browserify/index.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/qs/lib/formats.js","node_modules/qs/lib/index.js","node_modules/qs/lib/parse.js","node_modules/qs/lib/stringify.js","node_modules/qs/lib/utils.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/safe-buffer/index.js","node_modules/side-channel-list/index.js","node_modules/side-channel-map/index.js","node_modules/side-channel-weakmap/index.js","node_modules/side-channel/index.js","node_modules/simple-concat/index.js","node_modules/simple-get/index.js","node_modules/stream-http/index.js","node_modules/stream-http/lib/capability.js","node_modules/stream-http/lib/request.js","node_modules/stream-http/lib/response.js","node_modules/stream-http/node_modules/readable-stream/errors-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_transform.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/from-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/state.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/stream-http/node_modules/readable-stream/readable-browser.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/timers-browserify/main.js","node_modules/url/url.js","node_modules/util-deprecate/browser.js","node_modules/wrappy/wrappy.js","node_modules/xtend/immutable.js","package.json","source/Fable.js","source/services/Fable-Service-Anticipate.js","source/services/Fable-Service-CSVParser.js","source/services/Fable-Service-DataFormat.js","source/services/Fable-Service-DataGeneration-DefaultValues.json","source/services/Fable-Service-DataGeneration.js","source/services/Fable-Service-DateManipulation.js","source/services/Fable-Service-EnvironmentData.js","source/services/Fable-Service-ExpressionParser.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Base.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer-DirectiveMutation.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json","source/services/Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js","source/services/Fable-Service-FilePersistence.js","source/services/Fable-Service-Logic.js","source/services/Fable-Service-Math.js","source/services/Fable-Service-MetaTemplate.js","source/services/Fable-Service-MetaTemplate/MetaTemplate-StringParser.js","source/services/Fable-Service-MetaTemplate/MetaTemplate-WordTree.js","source/services/Fable-Service-Operation-DefaultSettings.js","source/services/Fable-Service-Operation.js","source/services/Fable-Service-ProgressTime.js","source/services/Fable-Service-ProgressTracker/ProgressTracker.js","source/services/Fable-Service-ProgressTrackerSet.js","source/services/Fable-Service-RestClient.js","source/services/Fable-Service-Template.js","source/services/Fable-Service-Utility.js","source/services/Fable-SetConcatArray.js"],"names":["_defineProperty2","e","r","t","_toPropertyKey2","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive2","Symbol","toPrimitive","call","TypeError","String","Number","f","exports","module","define","amd","window","global","self","this","Fable","n","o","c","require","u","a","Error","code","p","length","eachOfLimit","withoutIndex","arr","limit","iterator","cb","tasks","makeCallback","index","fn","apply","arguments","next","once","noop","onlyOnce","keyIterator","obj","nextKey","done","running","errored","replenish","key","err","setImmediate","restParam","args","callback","pop","push","innerArgs","sync","Array","isArray","prototype","toString","_keys","isArrayLike","coll","len","keys","k","hasOwnProperty","func","startIndex","Math","max","rest","_setImmediate","fallback","setTimeout","timers","ensureAsync","wrapIterator","concat","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","Arr","_byteLength","curByte","revLookup","charCodeAt","fromByteArray","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","Uint8Array","indexOf","tripletToBase64","num","start","end","output","GLOBAL","Big","MAX_DP","MAX_POWER","NAME","INVALID","INVALID_DP","INVALID_RM","DIV_BY_ZERO","P","UNDEFINED","NUMERIC","round","x","sd","rm","more","xc","constructor","RM","unshift","stringify","doExponential","isNonzero","s","charAt","slice","abs","cmp","y","isneg","yc","j","l","div","b","dp","DP","bl","bt","ri","bz","ai","al","rl","q","qc","qi","shift","eq","gt","gte","lt","lte","minus","sub","xlty","plus","xe","ye","reverse","mod","ygtx","times","neg","add","pow","one","prec","sqrt","half","toExponential","mul","toFixed","toJSON","NE","PE","toNumber","strict","toPrecision","valueOf","_Big_","nl","test","replace","search","substring","parse","roundDown","roundHalfUp","roundHalfEven","roundUp","dup","Buffer","base64","ieee754","SlowBuffer","alloc","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","__proto__","arg","encodingOrOffset","allocUnsafe","from","string","encoding","isEncoding","actual","write","fromString","ArrayBuffer","isView","fromArrayLike","isInstance","buffer","array","byteOffset","undefined","fromArrayBuffer","isBuffer","checked","copy","numberIsNaN","type","data","fromObject","assertSize","size","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","hexWrite","offset","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","foo","typedArraySupport","console","error","get","species","poolSize","fill","allocUnsafeSlow","_isBuffer","compare","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUIntLE","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","INVALID_BASE64_RE","Infinity","leadSurrogate","split","base64clean","src","dst","name","libFableServiceProviderBase","libLinkedList","pFable","pManifest","pServiceHash","super","serviceType","_HashMap","_RecordMap","_List","maxLength","maxAge","RecordMap","put","pData","pHash","Datum","tmpNode","Hash","Metadata","Created","Date","touch","remove","expire","pruneBasedOnExpiration","fComplete","pRemovedRecords","tmpRemovedRecords","tmpNow","tmpKeys","pruneBasedOnLength","pruneCustom","fPruneFunction","prune","fExpirationPruneComplete","getNode","LeftNode","RightNode","__ISNODE","libLinkedListNode","totalNodes","head","tail","initializeNode","pDatum","tmpHash","append","prepend","pNode","each","fAction","fIterator","pError","seek","pNodeIndex","bind","$apply","$call","$reflectApply","Function","$TypeError","$actualApply","Reflect","GetIntrinsic","callBindBasic","$indexOf","allowMissing","intrinsic","parseCookie","stringifyCookie","cookie","options","enc","encode","encodeURIComponent","cookieStrings","cookieNameRegExp","cookieValueRegExp","stringifySetCookie","serialize","parseSetCookie","dec","decode","endIdx","endIndex","eqIdx","eqIndex","setCookie","valueSlice","attr","httpOnly","secure","partitioned","domain","path","maxAgeRegExp","date","expires","priority","sameSite","domainValueRegExp","pathValueRegExp","__toString","NullObject","C","create","_name","_val","_opts","isInteger","toUTCString","decodeURIComponent","h","d","$","M","weekdays","months","ordinal","v","z","utcOffset","floor","year","month","clone","ceil","w","D","ms","Q","g","S","_","O","locale","$L","utc","$u","$x","$offset","$d","NaN","match","UTC","init","$y","getFullYear","$M","getMonth","$D","getDate","$W","getDay","$H","getHours","$m","getMinutes","$s","getSeconds","$ms","getMilliseconds","$utils","isValid","isSame","startOf","endOf","isAfter","isBefore","$g","unix","getTime","toDate","$locale","weekStart","$set","daysInMonth","subtract","format","invalidDate","meridiem","monthsShort","weekdaysMin","weekdaysShort","getTimezoneOffset","diff","toISOString","forEach","extend","$i","isDayjs","en","Ls","globalThis","dayjs","weekYear","isoWeekYear","week","isoWeek","offsetName","dayjs_plugin_advancedFormat","isoWeekday","day","dayjs_plugin_isoWeek","future","past","mm","hh","dd","MM","yy","fromToBase","relativeTime","thresholds","rounding","to","toNow","fromNow","dayjs_plugin_relativeTime","hour","minute","second","timeZoneName","Intl","DateTimeFormat","hour12","timeZone","formatToParts","tz","$timezone","guess","find","resolvedOptions","setDefault","dayjs_plugin_timezone","local","getUTCFullYear","getUTCMonth","getUTCDate","getUTCDay","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","$localOffset","isUTC","dayjs_plugin_utc","yearStart","weeks","dayjs_plugin_weekOfYear","weekday","dayjs_plugin_weekday","hasProtoAccessor","callBind","gOPD","desc","$Object","$getPrototypeOf","getPrototypeOf","gopd","$defineProperty","EvalError","ReferenceError","SyntaxError","URIError","ReflectOwnKeys","R","ReflectApply","receiver","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","emitter","Promise","resolve","reject","errorListener","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","events","existing","warning","newListener","emit","warned","count","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","unwrapListeners","arrayClone","listenerCount","addEventListener","wrapListener","removeEventListener","setMaxListeners","getMaxListeners","doError","er","message","context","listeners","addListener","prependListener","prependOnceListener","position","originalListener","spliceOne","off","removeAllListeners","rawListeners","eventNames","version","description","main","scripts","coverage","tests","mocha","extension","package","reporter","slow","timeout","ui","browser","repository","url","keywords","author","license","bugs","homepage","devDependencies","quackage","dependencies","CoreServiceProviderBase","pLogStreamSettings","pLogStreamHash","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","pCharacter","tmpRandomData","random","initialize","trace","pLogText","pLogObject","debug","info","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","default","loggertype","streamtype","level","libBaseLogger","pFableLog","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","tmpLogLine","log","JSON","libConsoleLog","libFS","libPath","logFileRawPath","logFilePath","normalize","logFileStreamOptions","fileStreamOptions","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","closeWriter","fCloseComplete","tmpCloseComplete","completeBufferFlushToLogFile","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","fs","libPackage","pSettings","_Package","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","uuid","addLogger","pLogger","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","assign","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","LogProviderBase","LogProviderConsole","LogProviderFlatfile","build","types","check","fable","typescript","FableServiceProviderBase","pOptions","UUID","services","servicesMap","isFable","connectFable","_PackageFableServiceProvider","getUUID","tmpErrorMessage","Logging","precedent","ProductVersion","ConfigFile","process","libPrecedent","pDependencies","templateProcessor","addPattern","pTemplateValue","tmpTemplateValue","tmpSeparatorIndex","tmpDefaultValue","tmpEnvironmentVariableName","env","parseSetting","pString","parseString","_process","libFableSettingsTemplateProcessor","FableSettings","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","base","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","_deepMergeObjects","toObject","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","new","getRandomValues","crypto","msCrypto","generateWhatWGBytes","tmpBuffer","generateRandomBytes","tmpValue","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","bytesToUUID","pBuffer","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","toStr","concatty","bound","arrLike","slicy","boundLength","boundArgs","joiner","joiny","result","Empty","implementation","$Error","$EvalError","$RangeError","$ReferenceError","$SyntaxError","$URIError","sign","$Function","getEvalledConstructor","expressionSyntax","$gOPD","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","hasSymbols","getProto","$ObjectGPO","$ReflectGPO","needsEval","TypedArray","INTRINSICS","AggregateError","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","decodeURI","encodeURI","eval","Float16Array","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","Map","parseFloat","Proxy","RegExp","Set","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","WeakRef","WeakSet","errorProto","doEval","gen","LEGACY_ALIASES","hasOwn","$concat","$spliceApply","splice","$replace","$strSlice","$exec","exec","rePropName","reEscapeChar","getBaseIntrinsic","alias","intrinsicName","first","last","number","quote","subString","stringToPath","intrinsicBaseName","intrinsicRealName","skipFurtherCaching","isOwn","part","hasown","reflectGetProto","originalGetProto","getDunderProto","getOwnPropertyDescriptor","origSymbol","hasSymbolSham","sym","symObj","syms","propertyIsEnumerable","descriptor","$hasOwn","http","https","validateParams","params","protocol","request","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt","LN2","ctor","superCtor","super_","TempCtor","cleanWrapCharacters","startsWith","endsWith","libSimpleLog","pInfoLog","pErrorLog","logInfo","logError","translationTable","translationCount","addTranslation","pTranslation","pTranslationSource","removeTranslationHash","pTranslationHash","removeTranslation","clearTranslations","translate","logToConsole","pLogLine","libGetObjectValue","fCleanWrapCharacters","_MockFable","DataFormat","getObjectValueClass","checkAddressExists","pAddress","pRootObject","tmpRootObject","tmpAddressPartBeginning","stringGetFirstSegment","tmpBracketStartIndex","tmpBracketStopIndex","tmpFunctionStartIndex","stringCountEnclosures","tmpFunctionAddress","tmpBoxedPropertyName","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","tmpSubObjectName","tmpNewAddress","tmpFunctionArguments","stringGetSegments","stringGetEnclosureValueByIndex","tmpArgumentValues","getValueAtAddress","fParseConditionals","checkRecordFilters","pRecord","deleteValueAtAddress","pParentAddress","tmpParentAddress","tmpObjectTypeMarkerIndex","tmpInputArray","tmpObjectPropertyName","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpObjectProperty","tmpObjectPropertyKeys","tmpParentAddressParts","tmpBackNavigationCount","tmpParentAddressLength","tmpRecurseAddress","tmpOutputArray","DEFAULT_START_SYMBOL_MAP","DEFAULT_END_SYMBOL_MAP","stringCountSegments","pSeparator","pEnclosureStartSymbolMap","pEnclosureEndSymbolMap","tmpString","tmpSeparator","tmpEnclosureStartSymbolMap","tmpEnclosureEndSymbolMap","tmpSegmentCount","tmpEnclosureStack","tmpCurrentSegmentStart","tmpSegmentList","pEnclosureStart","pEnclosureEnd","tmpEnclosureStart","tmpEnclosureEnd","tmpEnclosureCount","tmpEnclosureDepth","pEnclosureIndexToGet","tmpEnclosureIndexToGet","tmpMatchedEnclosureIndex","tmpEnclosedValueStartIndex","tmpEnclosedValueEndIndex","setValueAtAddress","pValue","tmpIndexIsNumeric","generateAddressses","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpObjectType","tmpSchemaObjectEntry","Address","Name","InSchema","DataType","Default","tmpObjectProperties","_ConditionalStanzaStart","_ConditionalStanzaEnd","testCondition","pManyfest","pSearchAddress","pSearchComparator","parseConditionals","tmpKeepRecord","tmpStartIndex","tmpStopIndex","tmpMagicComparisonPatternSet","tmpSearchAddress","tmpSearchComparator","tmpSearchValue","resolveAddressMappings","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpDescriptor","tmpNewDescriptorAddress","tmpOldDescriptorAddress","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","mergeAddressMappings","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libHashTranslation","libObjectAddressCheckAddressExists","libObjectAddressGetValue","libObjectAddressSetValue","libObjectAddressDeleteValue","libObjectAddressGeneration","libSchemaManipulation","_DefaultConfiguration","Scope","Descriptors","Manyfest","objectAddressCheckAddressExists","objectAddressGetValue","objectAddressSetValue","objectAddressDeleteValue","defaultValues","Float","Integer","PreciseNumber","Binary","DateTime","Null","scope","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","schemaManipulations","objectAddressGeneration","hashTranslations","numberRegex","tmpNewOptions","tmpNewManyfest","HashTranslations","getManifest","tmpAddress","deserialize","pManifestString","tmpManifest","tmpDescriptorKeys","tmpDescriptionAddresses","addDescriptor","pDescriptor","getDescriptorByHash","getDescriptor","resolveHashAddress","eachDescriptor","tmpDescriptorAddresses","checkAddressExistsByHash","tmpInElementHashTable","tmpInTranslationTable","getValueByHash","getDefaultValue","lintAddress","tmpLintedAddress","setValueByHash","deleteValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction","$isNaN","hasMap","mapSizeDescriptor","mapSize","mapForEach","hasSet","setSizeDescriptor","setSize","setForEach","weakMapHas","has","weakSetHas","weakRefDeref","deref","booleanValueOf","objectToString","functionToString","$match","$slice","$toUpperCase","toUpperCase","$toLowerCase","$test","$join","$arrSlice","$floor","bigIntValueOf","gOPS","symToString","hasShammedSymbols","toStringTag","isEnumerable","gPO","addNumericSeparator","sepRegex","int","intStr","utilInspect","inspectCustom","custom","inspectSymbol","isSymbol","quotes","double","single","quoteREs","wrapQuotes","defaultStyle","opts","style","quoteStyle","quoteChar","canTrustToString","isRegExp","inspect_","depth","seen","maxStringLength","customInspect","indent","numericSeparator","inspectString","bigIntStr","maxDepth","baseIndent","prev","getIndent","noIndent","newOpts","nameOf","arrObjKeys","symString","markBoxed","HTMLElement","nodeName","getAttribute","isElement","attrs","attributes","childNodes","xs","singleLineValues","indentedJoin","isError","cause","isMap","mapParts","collectionOf","isSet","setParts","isWeakMap","weakCollectionOf","isWeakSet","isWeakRef","isNumber","isBigInt","isBoolean","isString","isDate","ys","isPlainObject","protoTag","stringTag","tag","trailer","quoteRE","lastIndex","lowbyte","entries","lineJoiner","isArr","symMap","wrappy","called","onceStrict","onceError","proto","assertPath","normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","lastSlashIndex","posix","cwd","resolvedPath","resolvedAbsolute","isAbsolute","trailingSeparator","joined","relative","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","_makeLong","dirname","hasRoot","matchedSlash","basename","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","pathObject","sep","root","_format","delimiter","win32","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Asynchronous","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchEnd","appendOutputBuffer","pParserState","flushOutputBuffer","resetOutputBuffer","PatternStartNode","StartPatternMatchComplete","EndPatternMatchBegan","parseCharacter","PatternEnd","Parse","PatternStartString","PatternEndString","tmpParserState","addChild","pTree","pPattern","addEndChild","fParser","tmpLeaf","tmpPatternEnd","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","run","marker","runClearTimeout","Item","nextTick","title","argv","versions","binding","chdir","umask","freeExports","nodeType","freeModule","freeGlobal","punycode","maxInt","regexPunycode","regexNonASCII","regexSeparators","errors","overflow","stringFromCharCode","map","mapDomain","ucs2decode","extra","counter","ucs2encode","basicToDigit","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","baseMinusTMin","input","basic","oldi","baseMinusT","inputLength","bias","handledCPCount","basicLength","currentValue","handledCPCountPlusOne","qMinusT","ucs2","toASCII","toUnicode","percentTwenties","Format","formatters","RFC1738","RFC3986","formats","utils","defaults","allowDots","allowEmptyArrays","allowPrototypes","allowSparse","arrayLimit","charset","charsetSentinel","comma","decodeDotInKeys","decoder","duplicates","ignoreQueryPrefix","interpretNumericEntities","parameterLimit","parseArrays","plainObjects","strictDepth","strictMerge","strictNullHandling","throwOnLimitExceeded","$0","numberStr","parseArrayValue","currentArrayLength","parseKeys","givenKey","valuesParsed","child","segment","parent","segmentContent","splitKeyIntoSegments","chain","parentKey","leaf","isOverflow","combine","cleanRoot","decodedRoot","isValidArrayIndex","markOverflow","parseObject","normalizeParseOptions","tempObj","cleanStr","skipIndex","bracketEqualsPos","maybeMap","encodedVal","parseValues","newObj","compact","getSideChannel","arrayPrefixGenerators","brackets","prefix","indices","repeat","pushToArray","valueOrArray","toISO","defaultFormat","addQueryPrefix","arrayFormat","commaRoundTrip","encodeDotInKeys","encoder","encodeValuesOnly","filter","formatter","serializeDate","skipNulls","sentinel","object","generateArrayPrefix","sort","sideChannel","tmpSc","step","findFlag","objKeys","values","encodedPrefix","adjustedPrefix","encodedKey","keyPrefix","valueSideChannel","normalizeStringifyOptions","overflowChannel","maxIndex","getMaxIndex","setMaxIndex","hexTable","arrayToObject","source","reduce","acc","newIndex","prop","refs","item","compacted","compactQueue","defaultDecoder","strWithoutPlus","unescape","defaultEncoder","kind","escape","mapped","nextIndex","sourceKeys","combined","mergeTarget","targetItem","keyNum","qs","regexp","maxKeys","kstr","vstr","idx","stringifyPrimitive","objectKeys","ks","copyProps","SafeBuffer","listGetNode","isDelete","curr","$o","channel","assert","delete","deletedNode","objects","listDelete","node","listGet","listHas","listSet","callBound","$Map","$mapGet","$mapSet","$mapHas","$mapDelete","$mapSize","getSideChannelMap","$WeakMap","$weakMapGet","$weakMapSet","$weakMapHas","$weakMapDelete","$wm","getSideChannelList","makeChannel","$channelData","stream","chunks","chunk","simpleGet","decompressResponse","querystring","isStream","pipe","maxRedirects","hostname","port","auth","headers","body","json","form","method","accept","originalHost","req","followRedirects","statusCode","location","host","resume","redirectHost","authorization","tryUnzip","abort","ClientRequest","response","statusCodes","defaultProtocol","IncomingMessage","Agent","defaultMaxSockets","globalAgent","STATUS_CODES","METHODS","xtend","xhr","getXHR","XMLHttpRequest","open","XDomainRequest","checkTypeSupport","responseType","isFunction","fetch","ReadableStream","writableStream","WritableStream","abortController","AbortController","arraybuffer","msstream","mozchunkedarraybuffer","overrideMimeType","capability","inherits","rStates","readyStates","preferBinary","Writable","_body","_headers","setHeader","useFetch","mode","_mode","decideMode","_fetchTimer","_socketTimeout","_socketTimer","_onFinish","lowerName","unsafeHeaders","getHeader","header","removeHeader","_destroyed","headersObj","Blob","headersList","keyName","signal","controller","_fetchAbortController","requestTimeout","credentials","withCredentials","then","_fetchResponse","_resetTimers","_connect","reason","_xhr","ontimeout","setRequestHeader","_response","onreadystatechange","readyState","LOADING","DONE","_onXHRProgress","onprogress","onerror","send","status","statusValid","_write","destroy","flushHeaders","setNoDelay","setSocketKeepAlive","UNSENT","OPENED","HEADERS_RECEIVED","resetTimers","Readable","rawHeaders","trailers","rawTrailers","statusMessage","statusText","_resumeFetch","close","pipeTo","catch","reader","getReader","_pos","responseURL","getAllResponseHeaders","matches","_charset","mimeType","charsetMatch","_read","responseText","newData","MSStreamReader","onload","readAsArrayBuffer","codes","createErrorType","Base","NodeError","_Base","subClass","superClass","arg1","arg2","arg3","getMessage","oneOf","expected","thing","determiner","msg","this_len","Duplex","allowHalfOpen","readable","onend","_writableState","ended","onEndNT","highWaterMark","getBuffer","_readableState","destroyed","PassThrough","Transform","_transform","ReadableState","EElistenerCount","Stream","OurUint8Array","debugUtil","debuglog","StringDecoder","createReadableStreamAsyncIterator","BufferList","destroyImpl","getHighWaterMark","_require$codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","errorOrDestroy","kProxyEvents","isDuplex","objectMode","readableObjectMode","pipes","pipesCount","flowing","endEmitted","reading","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","defaultEncoding","awaitDrain","readingMore","_destroy","readableAddChunk","addToFront","skipChunkCheck","emitReadable","emitReadable_","onEofChunk","chunkInvalid","_uint8ArrayToBuffer","addChunk","maybeReadMore","_undestroy","undestroy","isPaused","setEncoding","content","clear","MAX_HWM","howMuchToRead","computeNewHighWaterMark","flow","maybeReadMore_","updateReadableListening","nReadingNextTick","resume_","fromList","consume","endReadable","endReadableNT","wState","finished","nOrig","doRead","dest","pipeOpts","endFn","stdout","stderr","unpipe","onunpipe","unpipeInfo","hasUnpiped","onclose","onfinish","ondrain","ondata","cleanedUp","needDrain","pipeOnDrain","pause","event","dests","ev","wrap","_this","asyncIterator","_fromList","iterable","util","ERR_MULTIPLE_CALLBACK","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","afterTransform","ts","_transformState","transforming","writecb","writechunk","rs","needTransform","writeencoding","transform","flush","_flush","prefinish","err2","CorkedRequest","entry","finish","corkReq","pendingcb","corkedRequestsFree","onCorkedFinish","WritableState","internalUtil","deprecate","realHasInstance","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","nop","writableObjectMode","finalCalled","ending","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writelen","onwriteStateUpdate","finishMaybe","errorEmitted","onwriteError","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","prefinished","bufferedRequestCount","writev","_writev","final","_final","doWrite","onwriteDrain","holder","allBuffers","isBuf","callFinal","need","rState","current","hasInstance","writeAfterEnd","validChunk","newChunk","decodeChunk","writeOrBuffer","cork","uncork","setDefaultEncoding","endWritable","_Object$setPrototypeO","_defineProperty","hint","prim","_toPrimitive","_toPropertyKey","kLastResolve","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","readAndResolve","iter","onReadable","AsyncIteratorPrototype","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","promise","lastPromise","wrapForNext","_this2","_Object$create","enumerableOnly","symbols","_objectSpread","getOwnPropertyDescriptors","defineProperties","_defineProperties","props","copyBuffer","instance","Constructor","_classCallCheck","protoProps","staticProps","hasStrings","_getString","_getBuffer","nb","emitErrorAndCloseNT","emitErrorNT","emitCloseNT","readableDestroyed","writableDestroyed","ERR_STREAM_PREMATURE_CLOSE","eos","_len","_key","onlegacyfinish","writableEnded","readableEnded","onrequest","isRequest","ERR_MISSING_ARGS","streams","popCallback","destroys","closed","destroyer","ERR_INVALID_OPT_VALUE","duplexKey","hwm","highWaterMarkFrom","pipeline","nenc","retried","_normalizeEncoding","normalizeEncoding","text","utf16Text","utf16End","fillLast","utf8FillLast","base64Text","base64End","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","utf8CheckByte","byte","utf8CheckExtraBytes","total","utf8CheckIncomplete","clearImmediate","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","Url","slashes","hash","query","pathname","href","protocolPattern","portPattern","simplePathPattern","unwise","autoEscape","nonHostChars","hostEndingChars","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","hostlessProtocol","slashedProtocol","ftp","gopher","file","urlParse","parseQueryString","slashesDenoteHost","queryIndex","splitter","uSplit","simplePath","lowerProto","atSign","hostEnd","hec","parseHost","ipv6Hostname","hostparts","newpart","validParts","notHost","bit","ae","esc","qm","resolveObject","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","authInHost","hasTrailingSlash","up","config","localStorage","wrapper","cachetrax","manyfest","libFableSettings","libFableUUID","libFableLog","libFableServiceBase","serviceTypes","serviceClasses","extraServiceInitialization","LogNoisiness","SettingsManager","ServiceManager","serviceManager","connectPreinitServiceProviderInstance","addAndInstantiateServiceType","addServiceType","settingsManager","newAnticipate","instantiateServiceProviderWithoutRegistration","newManyfest","pManifestDefinition","pServiceType","pServiceClass","isFableService","addServiceTypeIfNotExists","instantiateServiceProvider","addAndInstantiateServiceTypeIfNotExists","addAndInstantiateSingletonService","instantiateServiceProviderFromPrototype","pCustomServiceHash","pServicePrototype","tmpService","setDefaultServiceInstantiation","instantiateServiceProviderIfNotExists","pServiceInstance","tmpServiceType","tmpServiceHash","pOverwriteService","tmpOverwriteService","generateFileNameDateStamp","pDate","padStart","ServiceProviderBase","operationQueue","erroredOperations","executingOperationCount","completedOperationCount","callDepth","maxOperations","lastError","waitingFunctions","checkQueue","tmpOperation","buildAnticipatorCallback","anticipate","fAsynchronousFunction","tmpCallbackState","Called","OperationSet","wait","fCallback","Header","HeaderFieldNames","Delimiter","QuoteCharacter","CleanCharacters","HeaderLineIndex","HasHeader","HasSetHeader","EmitHeader","EmitJSON","EscapedQuoteString","CurrentLine","CurrentRecord","InQuote","InEscapedQuote","LinesParsed","RowsEmitted","marshalRowToJSON","pRowArray","pHeaderArray","resetRowState","pushLine","emitRow","pFormatAsJSON","tmpFormatAsJSON","tmpCompletedRecord","parseCSVLine","pLineString","pTargetLength","pPadString","stringGeneratePaddingString","_Regex_formatterInsertCommas","_Regex_formatterAddCommasToNumber","_Regex_formatterDollarsRemoveCommas","_Regex_formatterCleanNonAlphaChar","_Regex_formatterCapitalizeEachWord","_Regex_matcherHTMLEntities","_Value_MoneySign_Currency","_Value_NaN_Currency","_Value_GroupSeparator_Number","_Value_Prefix_StringHash","_Value_Clean_formatterCleanNonAlpha","_UseEngineStringStartsWith","_UseEngineStringEndsWith","_SanitizeObjectKeyRegex","_SanitizeObjectKeyReplacement","_SanitizeObjectKeyInvalid","stringReverse","stringStartsWith","pSearchString","pStartIndex","stringStartsWith_Polyfill","stringEndsWith","pEndIndex","stringEndsWith_Polyfill","insecureStringHash","tmpStringLength","tmpCharacterIndex","capitalizeEachWord","pMatch","resolveHtmlEntities","pEntity","tmpNumericalValue","concatenateStrings","_len2","pStrings","_key2","joinStrings","concatenateStringsInternal","pParams","tmpFlattenedArrays","Utility","flattenArrayOfSolverInputs","pJoin","_len3","_key3","joinStringsInternal","pJoinOn","concatenateStringsRaw","_len4","pValues","_key4","joinStringsRaw","concatenateStringsRawInternal","pValueObjectSetAddress","_len5","_key5","joinStringsRawInternal","cleanEnclosureWrapCharacters","pWrapCharacter","cleanNonAlphaCharacters","sanitizeObjectKey","formatterInsertCommas","tmpReversedWithCommas","processAddCommasToNumberRegex","pSign","pZeros","pBefore","pDecimal","pAfter","formatterAddCommasToNumber","pNumber","formatterDollars","pPrecision","pRoundingMethod","tmpDollarAmountArbitrary","parsePrecise","tmpPrecision","tmpDollarAmount","toFixedPrecise","formatterRoundNumber","pDigits","tmpDigits","bigNumber","tmpTargetLength","tmpPadString","tmpPadLength","formatTimeSpan","pTimeSpan","stringPadStart","formatTimeDelta","pTimeStart","pTimeEnd","getMonthFromDate","pJavascriptDate","getMonthAbbreviatedFromDate","formatMonthDayYearFromDate","pStrict","tmpStrict","tmpMonth","tmpDay","tmpYear","formatSortableStringFromDate","stringBeforeMatch","stringAfterMatch","tmpStringSplitLocation","stringEncodeURIComponent","stringDecodeURIComponent","Log","stringEncodeForJavascript","_Regex_matcherJavascriptEncode","stringDecodeForJavascript","_Regex_matcherJavascriptDecode","stringRemoveEnclosureByIndex","pEnclosureIndexToRemove","tmpEnclosureIndexToRemove","tmpEnclosureStartIndex","tmpEnclosureEndIndex","tmpReturnString","DefaultIntegerMinimum","DefaultIntegerMaximum","DefaultNumericStringLength","MonthSet","WeekDaySet","ColorSet","SurNameSet","NameSet","defaultData","randomIntegerBetween","pMinimum","pMaximum","tmpMinimum","tmpMaximum","Minimum","Maximum","randomIntegerUpTo","randomInteger","randomFloatBetween","addPrecise","multiplyPrecise","subtractPrecise","randomFloatUpTo","randomFloat","randomNumericString","pLength","pMaxNumber","tmpMaxNumber","randomMonth","randomDayOfWeek","randomColor","randomName","randomSurname","dayJS","plugin_weekOfYear","plugin_weekday","plugin_isoWeek","plugin_timezone","plugin_relativetime","plugin_utc","plugin_advancedFormat","dateMillisecondDifference","pDateStart","pDateEnd","pRequireEndDate","tmpStartDate","dateSecondDifference","dateMinuteDifference","dateHourDifference","dateDayDifference","dateWeekDifference","dateMonthDifference","dateYearDifference","dateAddMilliseconds","pAmount","dateMath","dateAddSeconds","dateAddMinutes","dateAddHours","dateAddDays","dateAddWeeks","dateAddMonths","dateAddYears","pUnit","pOperation","dateFromParts","pYear","pMonth","pDay","pHour","pMinute","pSecond","pMillisecond","millisecond","Environment","tokenMap","tokenMaxPrecedence","tokenRadix","tmpTokenKeys","tmpTokenKey","tmpToken","Token","Length","tmpTokenStartCharacter","TokenCount","Literal","TokenKeys","TokenMap","pLeft","pRight","Precedence","functionMap","Tokenizer","TokenizerDirectiveMutation","Linter","Postfix","ValueMarshal","Solver","Messaging","connectExpressionParser","GenericManifest","tokenize","pExpression","pResultObject","lintTokenizedExpression","pTokenizedExpression","buildPostfixedSolveList","substituteValuesInTokenizedObjects","pTokenizedObjects","pDataSource","solvePostfixedExpression","pPostfixedExpression","pDataDestinationObject","addSolverFunction","pFunctionName","pFunctionAddress","pFunctionComment","tmpFunctionName","_prepareDirectiveParameters","pParameters","pDefaults","pDataSourceObject","tmpResults","tmpParameter","ExpressionParser","getTokenContainerObject","Resolved","Value","solve","tmpResultsObject","tmpDataSourceObject","tmpDataDestinationObject","RawTokens","SolverDirectives","Code","tmpStep","tmpFrom","tmpTo","Step","From","To","ExpressionParserLog","comparePrecise","tmpIterations","floorPrecise","dividePrecise","tmpValueArray","tmpCurrentValueOfN","tmpPreviousValueOfN","tmpSeriesStepDataSourceObject","prev_n","stepIndex","tmpMutatedValues","PostfixTokenObjects","PostfixSolveList","tmpAssignmentManifestHash","PostfixedAssignmentAddress","OriginalRawTokens","tmpDirectiveValues","Values","tmpDirectiveValueKeys","ValueKeys","tmpVariableDescription","tmpControllingSet","tmpVariableKey","tmpPreviousValueKey","tmpSampleCount","SampleCount","tmpMonteCarloOutput","Samples","tmpVariableKeys","Distribution","ValueSequence","tmpResolvedPoints","Points","tmpPointToken","tmpPointValue","ResolvedPoints","FirstPoint","DomainRangeStart","LastPoint","DomainLength","tmpPointManifestHash","tmpPointManifest","generateValueFromEasingDescription","tmpDistributionRoundPrecision","DistributionRoundPrecision","tmpDistributionPointValue","roundPrecise","numberTest","pExpressionParser","getTokenType","pToken","Type","pTokenType","Descriptor","libExpressionParserOperationBase","directiveTypes","SOLVE","SERIES","MONTECARLO","MAP","defaultDirective","parseSeriesDirective","pTokens","tmpNewSeriesDirectiveDescription","parseMonteCarloDirective","tmpNewMonteCarloDirectiveDescription","tmpVariableToken","Easing","tmpTokenIndexSkip","tmpVariableValueString","tmpVariableValue","tmpEasingType","parseMapDirective","tmpNewMapDirectiveDescription","parseDirectives","SolverDirectiveTokens","tmpDirectiveTokenStartIndex","tmpDirectiveTokenEndIndex","RawExpression","tmpCurrentTokenType","tmpCurrentToken","tmpCharacter","tmpTokenRadix","percent","rad","pi","euler","exp","sin","cos","tan","countset","sortset","bucketset","sorthistogram","sorthistogrambykeys","sum","avg","mean","median","var","vara","varp","stdev","stdeva","stdevp","tofixed","cumulativesummation","subtractingsummation","iterativeseries","countsetelements","getvalue","setvalue","objectkeystoarray","objectvaluestoarray","generatearrayofobjectsfromsets","objectvaluessortbyexternalobjectarray","setkeystoarray","setvaluestoarray","histogramkeystoarray","histogramvaluestoarray","createarrayfromabsolutevalues","flatten","findfirstvaluebyexactmatch","findfirstvaluebystringincludes","resolvehtmlentities","concatraw","arrayconcat","joinraw","if","when","entryinset","smallestinset","largestinset","aggregationhistogram","aggregationhistogrambyobject","distributionhistogram","distributionhistogrambyobject","setconcatenate","getvaluearray","getvalueobject","cleanvaluearray","cleanvalueobject","polynomialregression","randominteger","randomintegerbetween","randomintegerupto","randomfloat","randomfloatbetween","randomfloatupto","datemilliseconddifference","dateseconddifference","dateminutedifference","datehourdifference","datedaydifference","dateweekdifference","datemonthdifference","dateyeardifference","datemathadd","dateaddmilliseconds","dateaddseconds","dateaddminutes","dateaddhours","dateadddays","dateaddweeks","dateaddmonths","dateaddyears","datefromparts","createvalueobjectbyhashes","leastsquares","linest","matrixtranspose","matrixmultiply","matrixvectormultiply","matrixinverse","gaussianelimination","predict","stringcountsegments","stringgetsegments","bezierpoint","beziercurvefit","LinterResults","tmpParenthesisDepth","tmpInStateAddress","tmpEqualityAssignmentCount","tmpEqualityAssignmentIndex","tmpTokenPrevious","getOperationVirtualSymbolName","pOperationToken","VirtualSymbolName","getVirtualTokenValue","pOperationResults","tmpVirtualSymbol","tmpVirtualSymbolData","VirtualSymbols","getTokenAddressString","getTokenSymbolString","pExpressionToken","getOperationSymbolMessage","tmpOperationVirtualSymbol","tmpOperationLeftValue","LeftValue","tmpOperationSymbol","Operation","tmpOperationRightValue","RightValue","tmpVirtualSymbolPrefix","getOperationValueMessage","getOperationOutcomeMessage","logFunctionOutcome","tmpAssignmentAddress","tmpRawExpression","tmpRawResult","RawResult","tmpTokenSymbolMessage","tmpTokenValueMessage","tmpTokenOutcome","logFunctionSolve","getPosfixSolveListOperation","pLeftValue","pRightValue","pDepthSolveList","pDepthSolveIndex","LeftVirtualSymbolName","RightVirtualSymbolName","Parsed","PostfixedAssignmentOperator","tmpEqualsIndex","tmpDepth","tmpVirtualParenthesisIndex","tmpSolveLayerStack","Depth","SolveLayerStack","tmpSolveLayerMap","tmpSolveLayerMaxDepth","tmpSolveLayerKeys","tmpVirtualSymbolIndex","pLeftLayer","pRightLayer","PostfixLayerstackMap","unaryEligibleOperationTokens","unaryOperationPrefixTriggerTypes","tmpSolveLayerIndex","tmpSolveLayerTokens","tmpPrecedence","tmpFunctionCacheLIFOStack","tmpPostfixTokenObject","ParenthesisStack","IsFunction","tmpVirtualSymbolName","tmpOpenParenthesis","tmpParenthesisStack","tmpLastOperator","PreviousOperator","NextOperator","tmpLastPrecedence","tmpFinalChainToken","tmpDecreasingPrecedenceStack","tmpLastToken","tmpAbstractAssignToken","tmpAbstractMultiplyToken","tmpSolveResultToken","tmpFinalAssignmentInstruction","libSetConcatArray","tmpPassedInFable","tmpStepResultObject","ExpressionStep","ExpressionStepIndex","ResultsObject","Manifest","LastResult","tmpIsFunction","tmpResult","tmpFunction","tmpFunctionBinding","tmpArguments","Stack","stack","SolverFinalVirtualSymbol","tmpSolverResultValue","OnlyEmpty","addressIsNullOrEmpty","tmpDataSource","Resolve","tmpValueParsed","libReadline","Mode","joinPath","resolvePath","existsSync","pPath","exists","deleteFileSync","pFileName","unlinkSync","deleteFolderSync","rmdirSync","readFileSync","pFilePath","tmpOptions","readFile","readFileCSV","fRecordFunction","fCompleteFunction","fErrorFunction","tmpCSVParser","tmpRecordFunction","tmpCompleteFunction","tmpErrorFunction","lineReaderFactory","pLine","tmpRecord","appendFileSync","pAppendContent","writeFileSync","pFileContent","writeFileSyncFromObject","writeFileSyncFromArray","pFileArray","writeFile","fOnLine","fOnComplete","fOnError","tmpLineReader","filePath","fileStream","createReadStream","createInterface","crlfDelay","makeFolderRecursive","tmpParameters","Path","CurrentPathIndex","ActualPath","ActualPathParts","CurrentPath","pFileDescriptor","closeSync","mkdir","pCreateError","readline","checkIf","pComparisonOperator","pOnTrue","pOnFalse","tmpMathLeft","tmpMathRight","tmpCheckResult","ltPrecise","ltePrecise","gtPrecise","gtePrecise","comparePreciseWithin","pCheckForTruthy","errorReturnValue","ln2Cache","pNonNumberValue","tmpNumber","assignValue","expressionBegin","percentagePrecise","pIs","pOf","tmpLeftValue","tmpRightValue","setConcatenate","pDecimals","tmpDecimals","tmpRoundingMethod","powerPrecise","modPrecise","sqrtPrecise","absPrecise","ceilPrecise","pEpsilon","tmpLeftArbitraryValue","radPrecise","pDegrees","tmpDegrees","PI","piPrecise","eulerPrecise","pRadians","tmpRadians","countSetElements","pValueSet","sortSetPrecise","tmpSortedSet","bucketSetPrecise","pBucketSize","tmpBucketedSet","tmpBucketSize","tmpBucket","histogramPrecise","sortHistogramPrecise","pHistogram","tmpSortedHistogram","sortHistogramByKeys","pDescending","tmpDescending","cleanValueArray","pValueArray","pRemoveZeroes","tmpRemoveZeroes","tmpCleanedArray","arbitraryNaturalLogOfTwo","tmpPrecisionKey","tmpTwoConstant","y2","tmpSummation","tmpTermination","tmpDenominator","tmpEpsilon","tmpNaturalLogOfTwo","arbitraryNaturalLog","pNumberToCompute","tmpNumberToCompute","TWO","tmpUpperBounds","tmpLowerBounds","tmpSeriesTermination","tmpNaturalLog","tmpPrecisionNaturalLog","logPrecise","pNumberToGenerateLogarithmFor","pBase","tmpBase","tmpWorkingPrecision","tmpSavedBigDecimalPrecision","tmpSavedBigRoundingMethod","N","B","tmpNaturalLogOfN","tmpNaturalLogOfB","finalResult","expPrecise","pDecimalPrecision","tmpDecimalPrecision","tmpNaturalLogMaxDouble","tmpNaturalLogMinimumValue","pErrorRounding","tmpTolerance","tmpTwo","tmpAbsoluteValueOfK","tmpTwoToThePowerOfAbsoluteK","cleanValueObject","pValueObject","tmpCleanedObject","histogramDistributionByExactValue","pValueObjectSet","pValueAddress","tmpHistogram","histogramDistributionByExactValueFromInternalState","tmpValueObjectSet","getInternalValueByHash","histogramAggregationByExactValue","pValueAmountAddress","tmpAmount","histogramAggregationByExactValueFromInternalState","entryInSet","pEntryIndex","tmpEntryIndex","toSorted","smallestInSet","largestInSet","cumulativeSummation","pCumulationResultAddress","iterativeSeries","subtractingSummation","pStartingValue","tmpProcessFirstRow","pValueMultiplier","pSummationOperation","pProcessFirstRowWithAValue","tmpValueMultiplier","tmpSummationValue","tmpFirstRowWithValue","maxPrecise","tmpMaxValue","tmpComparisonValue","minPrecise","tmpMinValue","sumPrecise","tmpSumValue","meanPrecise","tmpCount","averagePrecise","medianPrecise","tmpSortedValueSet","tmpMiddleElement","tmpLeftMiddleValue","tmpRightMiddleValue","modePrecise","tmpMaxCount","tmpHistogramValueSet","tmpModeValueSet","variancePrecise","pIsPopulation","tmpValueSet","pKey","tmpMeanValue","tmpVarianceSum","pAccumulator","tmpDiff","tmpSquaredDiff","populationVariancePrecise","standardDeviationPrecise","populationStandardDeviationPrecise","polynomialRegression","pXVector","pYVector","tmpXMatrix","tmpYVector","row","X_T","matrixTranspose","XTX","matrixMultiply","XTY","XTX_inv","matrixInverse","leastSquares","pIndependentVariableVectors","pDependentVariableVector","tmpIndependentVariableVectors","tmpDependentVariableVector","tmpIndependentVariableMatrixWithBiasTerm","tmpIndependentTermTranpose","tmpDependentTransposeMultiplication","tmpIndependentTransposeMultiplication","matrixVectorMultiply","gaussianElimination","pInputMatrix","pLHSMatrix","pRHSMatrix","pMatrix","pVector","tmpIdentityMatrix","tmpAugmentedMatrix","maxRow","tmpPivotValue","tmpFactor","pCoefficientMatrix","tmpSwapValue","pEasingConfiguration","tmpDomainRange","tmpRandomFraction","tmpScaledValue","predictFromRegressionModel","pRegressionCoefficients","pIndependentVariableVector","tmpIndependentVariableVector","bezierPoint","pP0","pP1","pP2","pP3","pT","tmpT","tmpOneMinusT","tmpTerm0","tmpTerm1","tmpTerm2","tmpTerm3","bezierCurveFit","pXValues","pYValues","tmpN","tmpP0x","tmpP0y","tmpP3x","tmpP3y","tmpP1x","tmpP1y","tmpP2x","tmpP2y","tmpDistances","tmpDx","tmpDy","tmpDist","tmpTotalLength","tmpTValues","tmpC11","tmpC12","tmpC22","tmpRx1","tmpRx2","tmpRy1","tmpRy2","tmpA1","tmpA2","tmpB0","tmpB3","tmpResidualX","tmpResidualY","tmpDet","pParserContext","addPatternBoth","pParserPromise","pDataContext","pScope","pState","TemplateData","tmpFunctionContext","ParserContext","executePatternAsync","isAsync","ParseAsync","pAsyncOutput","PatternStart","parseCharacterAsync","tmpPreviousDataContext","tmpDataContext","tmpAnticipate","fParserAsync","Summary","Version","Status","Completed","StepCount","Steps","_OperationStatePrototypeString","timeStamps","stepMap","stepFunctions","progressTrackerSet","OverallProgressTracker","createProgressTracker","execute","fExecutionCompleteCallback","StartTimeStamp","setProgressTrackerTotalOperations","startProgressTracker","fNext","GUIDStep","ProgressTracker","metadata","getProgressTracker","logProgressTrackerStatus","getProgressTrackerStatusString","OperationState","StepState","endProgressTracker","tmpStepTimingMessage","incrementProgressTracker","tmpOperationTimingMessage","addStep","fStepFunction","pStepMetadata","pStepName","pStepDescription","pGUIDStep","DataGeneration","Description","fDone","setStepTotalOperations","pTotalOperationCount","writeOperationLog","writeOperationErrors","formatTimeDuration","pTimeDurationInMilliseconds","tmpTimeDuration","tmpTimeDurationString","createTimeStamp","pTimeStampHash","tmpTimeStampHash","getTimeStampValue","updateTimeStampValue","pReferenceTime","tmpReferenceTime","tmpReference","removeTimeStamp","getTimeStampDelta","getDurationBetweenTimestamps","pTimeStampHashStart","pTimeStampHashEnd","tmpTimeStampHashStart","tmpTimeStampHashEnd","getTimeStampDeltaMessage","tmpOperationTime","logTimeStampDelta","pProgressTrackerSet","pProgressTrackerHash","progressTrackerHash","getProgressTrackerData","updateProgressTracker","pProgressAmount","pProgressIncrementAmount","libProgressTrackerClass","progressTrackers","progressTimes","tmpProgressTrackerHash","pTotalOperations","tmpProgressTracker","StartTimeHash","CurrentTimeStamp","EndTimeHash","EndTimeStamp","PercentComplete","AllowTruePercentComplete","ElapsedTime","AverageOperationTime","EstimatedCompletionTime","TotalCount","CurrentCount","tmpTotalOperations","solveProgressTrackerStatus","pCurrentOperations","tmpCurrentOperations","pOperationIncrementAmount","tmpOperationIncrementAmount","getProgressTrackerCompletedOperationCountString","getProgressTrackerPercentCompleteString","libSimpleGet","libCookie","TraceLog","dataFormat","prepareRequestOptions","prepareCookies","pRequestOptions","tmpCookieObject","tmpCookieKeys","preRequest","RestClientURLPrefix","executeChunkedRequest","RequestStartTime","pResponse","tmpConnectTime","tmpData","pChunk","tmpChunkTime","tmpCompletionTime","executeChunkedRequestBinary","tmpDataBuffer","executeJSONRequest","tmpJSONData","getJSON","pOptionsOrURL","tmpRequestOptions","putJSON","postJSON","patchJSON","headJSON","delJSON","getRawText","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","templateString","renderTemplate","templateFunction","buildTemplateFunction","pTemplateText","TemplateSource","pCode","TemplateSourceCompiled","libAsyncWaterfall","libAsyncEachLimit","libBigNumber","templates","waterfall","eachLimit","pDestinationObject","tmpSourceObject","template","buildHashedTemplate","pTemplateHash","tmpTemplate","pInput","pChunkSize","pChunkCache","tmpChunkSize","tmpChunkCache","setInternalValueByHash","manifest","createValueArrayByHashes","pValueHashes","tmpEndIndex","createValueArrayByHashesFromInternal","createValueArrayByHashParametersFromInternal","tmpValueHashes","createValueObjectByHashes","tmpValueObject","createValueObjectByHashesFromInternal","createValueObjectByHashParametersFromInternal","objectKeysToArray","objectValuesToArray","tmpValues","objectValuesSortByExternalArray","pArray","pObjectArray","tmpSearchAddresses","tmpSortHelperArray","SortValue","SortObject","pSortHelperArrayObject","isoStringToDate","pISOString","Dates","findFirstValueByStringIncludes","pValueToMatchAddress","pValueToMatch","tmpValueToMatch","findFirstValueByStringIncludesInternal","pFableAddress","tmpObjectArray","findFirstValueByExactMatch","findFirstValueByExactMatchInternal","findIndexInternal","pValueToFind","pSearchArray","pSearchMode","tmpSearchArray","tmpIsNumericSearch","tmpComparisonFunction","pCandidate","pInputArray","flatMap","generateArrayOfObjectsFromSets","tmpResultArray","tmpPropertyNames","tmpValueArrays","tmpPropertyName","createArrayFromAbsoluteValues","tmpArray","concatenateArrays","SetConcatArray"],"mappings":"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","file":"fable.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fable = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n\n},{\"async.util.eachoflimit\":3,\"async.util.withoutindex\":14}],2:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n\n},{}],3:[function(require,module,exports){\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n\n},{\"async.util.keyiterator\":7,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.onlyonce\":11}],4:[function(require,module,exports){\n'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n\n},{\"async.util.restparam\":12,\"async.util.setimmediate\":13}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n\n},{\"async.util.isarray\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n\n},{\"async.util.isarraylike\":6,\"async.util.keys\":8}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function noop () {};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n\n},{}],13:[function(require,module,exports){\n(function (setImmediate){(function (){\n'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"timers\":144}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n\n},{\"async.iterator\":2,\"async.util.ensureasync\":4,\"async.util.isarray\":5,\"async.util.noop\":9,\"async.util.once\":10,\"async.util.restparam\":12}],16:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],17:[function(require,module,exports){\n/*\r\n *  big.js v7.0.1\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2025 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */\r\n;(function (GLOBAL) {\r\n  'use strict';\r\n  var Big,\r\n\r\n\r\n/************************************** EDITABLE DEFAULTS *****************************************/\r\n\r\n\r\n    // The default values below must be integers within the stated ranges.\r\n\r\n    /*\r\n     * The maximum number of decimal places (DP) of the results of operations involving division:\r\n     * div and sqrt, and pow with negative exponents.\r\n     */\r\n    DP = 20,            // 0 to MAX_DP\r\n\r\n    /*\r\n     * The rounding mode (RM) used when rounding to the above decimal places.\r\n     *\r\n     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n     *  3  Away from zero.                                  (ROUND_UP)\r\n     */\r\n    RM = 1,             // 0, 1, 2 or 3\r\n\r\n    // The maximum value of DP and Big.DP.\r\n    MAX_DP = 1E6,       // 0 to 1000000\r\n\r\n    // The maximum magnitude of the exponent argument to the pow method.\r\n    MAX_POWER = 1E6,    // 1 to 1000000\r\n\r\n    /*\r\n     * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n     * (JavaScript numbers: -7)\r\n     * -1000000 is the minimum recommended exponent value of a Big.\r\n     */\r\n    NE = -7,            // 0 to -1000000\r\n\r\n    /*\r\n     * The positive exponent (PE) at and above which toString returns exponential notation.\r\n     * (JavaScript numbers: 21)\r\n     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n     */\r\n    PE = 21,            // 0 to 1000000\r\n\r\n    /*\r\n     * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n     * primitive number without a loss of precision.\r\n     */\r\n    STRICT = false,     // true or false\r\n\r\n\r\n/**************************************************************************************************/\r\n\r\n\r\n    // Error messages.\r\n    NAME = '[big.js] ',\r\n    INVALID = NAME + 'Invalid ',\r\n    INVALID_DP = INVALID + 'decimal places',\r\n    INVALID_RM = INVALID + 'rounding mode',\r\n    DIV_BY_ZERO = NAME + 'Division by zero',\r\n\r\n    // The shared prototype object.\r\n    P = {},\r\n    UNDEFINED = void 0,\r\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\r\n\r\n\r\n  /*\r\n   * Create and return a Big constructor.\r\n   */\r\n  function _Big_() {\r\n\r\n    /*\r\n     * The Big constructor and exported function.\r\n     * Create and return a new instance of a Big number object.\r\n     *\r\n     * n {number|string|Big} A numeric value.\r\n     */\r\n    function Big(n) {\r\n      var x = this;\r\n\r\n      // Enable constructor usage without new.\r\n      if (!(x instanceof Big)) {\r\n        return n === UNDEFINED && arguments.length === 0 ? _Big_() : new Big(n);\r\n      }\r\n\r\n      // Duplicate.\r\n      if (n instanceof Big) {\r\n        x.s = n.s;\r\n        x.e = n.e;\r\n        x.c = n.c.slice();\r\n      } else {\r\n        if (typeof n !== 'string') {\r\n          if (Big.strict === true && typeof n !== 'bigint') {\r\n            throw TypeError(INVALID + 'value');\r\n          }\r\n\r\n          // Minus zero?\r\n          n = n === 0 && 1 / n < 0 ? '-0' : String(n);\r\n        }\r\n\r\n        parse(x, n);\r\n      }\r\n\r\n      // Retain a reference to this Big constructor.\r\n      // Shadow Big.prototype.constructor which points to Object.\r\n      x.constructor = Big;\r\n    }\r\n\r\n    Big.prototype = P;\r\n    Big.DP = DP;\r\n    Big.RM = RM;\r\n    Big.NE = NE;\r\n    Big.PE = PE;\r\n    Big.strict = STRICT;\r\n    Big.roundDown = 0;\r\n    Big.roundHalfUp = 1;\r\n    Big.roundHalfEven = 2;\r\n    Big.roundUp = 3;\r\n\r\n    return Big;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the number or string value passed to a Big constructor.\r\n   *\r\n   * x {Big} A Big number instance.\r\n   * n {number|string} A numeric value.\r\n   */\r\n  function parse(x, n) {\r\n    var e, i, nl;\r\n\r\n    if (!NUMERIC.test(n)) {\r\n      throw Error(INVALID + 'number');\r\n    }\r\n\r\n    // Determine sign.\r\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n    // Decimal point?\r\n    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = n.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +n.slice(i + 1);\r\n      n = n.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = n.length;\r\n    }\r\n\r\n    nl = n.length;\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\r\n\r\n    if (i == nl) {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    } else {\r\n\r\n      // Determine trailing zeros.\r\n      for (; nl > 0 && n.charAt(--nl) == '0';);\r\n      x.e = e - i - 1;\r\n      x.c = [];\r\n\r\n      // Convert string to array of digits without leading/trailing zeros.\r\n      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n   *\r\n   * x {Big} The Big to round.\r\n   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   * [more] {boolean} Whether the result of division was truncated.\r\n   */\r\n  function round(x, sd, rm, more) {\r\n    var xc = x.c;\r\n\r\n    if (rm === UNDEFINED) rm = x.constructor.RM;\r\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\r\n      throw Error(INVALID_RM);\r\n    }\r\n\r\n    if (sd < 1) {\r\n      more =\r\n        rm === 3 && (more || !!xc[0]) || sd === 0 && (\r\n        rm === 1 && xc[0] >= 5 ||\r\n        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\r\n      );\r\n\r\n      xc.length = 1;\r\n\r\n      if (more) {\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        x.e = x.e - sd + 1;\r\n        xc[0] = 1;\r\n      } else {\r\n\r\n        // Zero.\r\n        xc[0] = x.e = 0;\r\n      }\r\n    } else if (sd < xc.length) {\r\n\r\n      // xc[sd] is the digit after the digit that may be rounded up.\r\n      more =\r\n        rm === 1 && xc[sd] >= 5 ||\r\n        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\r\n          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\r\n        rm === 3 && (more || !!xc[0]);\r\n\r\n      // Remove any digits after the required precision.\r\n      xc.length = sd;\r\n\r\n      // Round up?\r\n      if (more) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up.\r\n        for (; ++xc[--sd] > 9;) {\r\n          xc[sd] = 0;\r\n          if (sd === 0) {\r\n            ++x.e;\r\n            xc.unshift(1);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (sd = xc.length; !xc[--sd];) xc.pop();\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of Big x in normal or exponential notation.\r\n   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n   */\r\n  function stringify(x, doExponential, isNonzero) {\r\n    var e = x.e,\r\n      s = x.c.join(''),\r\n      n = s.length;\r\n\r\n    // Exponential notation?\r\n    if (doExponential) {\r\n      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\r\n\r\n    // Normal notation.\r\n    } else if (e < 0) {\r\n      for (; ++e;) s = '0' + s;\r\n      s = '0.' + s;\r\n    } else if (e > 0) {\r\n      if (++e > n) {\r\n        for (e -= n; e--;) s += '0';\r\n      } else if (e < n) {\r\n        s = s.slice(0, e) + '.' + s.slice(e);\r\n      }\r\n    } else if (n > 1) {\r\n      s = s.charAt(0) + '.' + s.slice(1);\r\n    }\r\n\r\n    return x.s < 0 && isNonzero ? '-' + s : s;\r\n  }\r\n\r\n\r\n  // Prototype/instance methods\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the absolute value of this Big.\r\n   */\r\n  P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return 1 if the value of this Big is greater than the value of Big y,\r\n   *       -1 if the value of this Big is less than the value of Big y, or\r\n   *        0 if they have the same value.\r\n   */\r\n  P.cmp = function (y) {\r\n    var isneg,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new x.constructor(y)).c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    isneg = i < 0;\r\n\r\n    // Compare exponents.\r\n    if (k != l) return k > l ^ isneg ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = -1; ++i < j;) {\r\n      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.div = function (y) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      a = x.c,                  // dividend\r\n      b = (y = new Big(y)).c,   // divisor\r\n      k = x.s == y.s ? 1 : -1,\r\n      dp = Big.DP;\r\n\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n\r\n    // Divisor is zero?\r\n    if (!b[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    // Dividend is 0? Return +-0.\r\n    if (!a[0]) {\r\n      y.s = k;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    var bl, bt, n, cmp, ri,\r\n      bz = b.slice(),\r\n      ai = bl = b.length,\r\n      al = a.length,\r\n      r = a.slice(0, bl),   // remainder\r\n      rl = r.length,\r\n      q = y,                // quotient\r\n      qc = q.c = [],\r\n      qi = 0,\r\n      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\r\n\r\n    q.s = k;\r\n    k = p < 0 ? 0 : p;\r\n\r\n    // Create version of divisor with leading zero.\r\n    bz.unshift(0);\r\n\r\n    // Add zeros to make remainder as long as divisor.\r\n    for (; rl++ < bl;) r.push(0);\r\n\r\n    do {\r\n\r\n      // n is how many times the divisor goes into current remainder.\r\n      for (n = 0; n < 10; n++) {\r\n\r\n        // Compare divisor and remainder.\r\n        if (bl != (rl = r.length)) {\r\n          cmp = bl > rl ? 1 : -1;\r\n        } else {\r\n          for (ri = -1, cmp = 0; ++ri < bl;) {\r\n            if (b[ri] != r[ri]) {\r\n              cmp = b[ri] > r[ri] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // If divisor < remainder, subtract divisor from remainder.\r\n        if (cmp < 0) {\r\n\r\n          // Remainder can't be more than 1 digit longer than divisor.\r\n          // Equalise lengths using divisor with extra leading zero?\r\n          for (bt = rl == bl ? b : bz; rl;) {\r\n            if (r[--rl] < bt[rl]) {\r\n              ri = rl;\r\n              for (; ri && !r[--ri];) r[ri] = 9;\r\n              --r[ri];\r\n              r[rl] += 10;\r\n            }\r\n            r[rl] -= bt[rl];\r\n          }\r\n\r\n          for (; !r[0];) r.shift();\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Add the digit n to the result array.\r\n      qc[qi++] = cmp ? n : ++n;\r\n\r\n      // Update the remainder.\r\n      if (r[0] && cmp) r[rl] = a[ai] || 0;\r\n      else r = [a[ai]];\r\n\r\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\r\n\r\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n    if (!qc[0] && qi != 1) {\r\n\r\n      // There can't be more than one zero.\r\n      qc.shift();\r\n      q.e--;\r\n      p--;\r\n    }\r\n\r\n    // Round?\r\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\r\n\r\n    return q;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n   */\r\n  P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n   * false.\r\n   */\r\n  P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.gte = function (y) {\r\n    return this.cmp(y) > -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n   */\r\n  P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var i, j, t, xlty,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xc = x.c.slice(),\r\n      xe = x.e,\r\n      yc = y.c,\r\n      ye = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (yc[0]) {\r\n        y.s = -b;\r\n      } else if (xc[0]) {\r\n        y = new Big(x);\r\n      } else {\r\n        y.s = 1;\r\n      }\r\n      return y;\r\n    }\r\n\r\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\r\n    if (a = xe - ye) {\r\n\r\n      if (xlty = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (b = a; b--;) t.push(0);\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = ((xlty = xc.length < yc.length) ? xc : yc).length;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n        if (xc[b] != yc[b]) {\r\n          xlty = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xlty) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    /*\r\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n     * needs to start at yc.length.\r\n     */\r\n    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\r\n\r\n    // Subtract yc from xc.\r\n    for (b = i; j > a;) {\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i];) xc[i] = 9;\r\n        --xc[i];\r\n        xc[j] += 10;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xc[--b] === 0;) xc.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] === 0;) {\r\n      xc.shift();\r\n      --ye;\r\n    }\r\n\r\n    if (!xc[0]) {\r\n\r\n      // n - n = +0\r\n      y.s = 1;\r\n\r\n      // Result must be zero.\r\n      xc = [ye = 0];\r\n    }\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n   */\r\n  P.mod = function (y) {\r\n    var ygtx,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    if (!y.c[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    x.s = y.s = 1;\r\n    ygtx = y.cmp(x) == 1;\r\n    x.s = a;\r\n    y.s = b;\r\n\r\n    if (ygtx) return new Big(x);\r\n\r\n    a = Big.DP;\r\n    b = Big.RM;\r\n    Big.DP = Big.RM = 0;\r\n    x = x.div(y);\r\n    Big.DP = a;\r\n    Big.RM = b;\r\n\r\n    return this.minus(x.times(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big negated.\r\n   */\r\n  P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var e, k, t,\r\n      x = this,\r\n      Big = x.constructor;\r\n\r\n    y = new Big(y);\r\n\r\n    // Signs differ?\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e,\r\n      xc = x.c,\r\n      ye = y.e,\r\n      yc = y.c;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (!yc[0]) {\r\n        if (xc[0]) {\r\n          y = new Big(x);\r\n        } else {\r\n          y.s = x.s;\r\n        }\r\n      }\r\n      return y;\r\n    }\r\n\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    // Note: reverse faster than unshifts.\r\n    if (e = xe - ye) {\r\n      if (e > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        e = -e;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; e--;) t.push(0);\r\n      t.reverse();\r\n    }\r\n\r\n    // Point xc to the longer array.\r\n    if (xc.length - yc.length < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n    }\r\n\r\n    e = yc.length;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\r\n    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n    if (k) {\r\n      xc.unshift(k);\r\n      ++ye;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (e = xc.length; xc[--e] === 0;) xc.pop();\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a Big whose value is the value of this Big raised to the power n.\r\n   * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n   * mode Big.RM.\r\n   *\r\n   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n   */\r\n  P.pow = function (n) {\r\n    var x = this,\r\n      one = new x.constructor('1'),\r\n      y = one,\r\n      isneg = n < 0;\r\n\r\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n      throw Error(INVALID + 'exponent');\r\n    }\r\n\r\n    if (isneg) n = -n;\r\n\r\n    for (;;) {\r\n      if (n & 1) y = y.times(x);\r\n      n >>= 1;\r\n      if (!n) break;\r\n      x = x.times(x);\r\n    }\r\n\r\n    return isneg ? one.div(y) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n   * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.prec = function (sd, rm) {\r\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n      throw Error(INVALID + 'precision');\r\n    }\r\n    return round(new this.constructor(this), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n   * using rounding mode rm, or Big.RM if rm is not specified.\r\n   * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n   * If dp is not specified, round to 0 decimal places.\r\n   *\r\n   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.round = function (dp, rm) {\r\n    if (dp === UNDEFINED) dp = 0;\r\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    return round(new this.constructor(this), dp + this.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.sqrt = function () {\r\n    var r, c, t,\r\n      x = this,\r\n      Big = x.constructor,\r\n      s = x.s,\r\n      e = x.e,\r\n      half = new Big('0.5');\r\n\r\n    // Zero?\r\n    if (!x.c[0]) return new Big(x);\r\n\r\n    // Negative?\r\n    if (s < 0) {\r\n      throw Error(NAME + 'No square root');\r\n    }\r\n\r\n    // Estimate.\r\n    s = Math.sqrt(+stringify(x, true, true));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\r\n    if (s === 0 || s === 1 / 0) {\r\n      c = x.c.join('');\r\n      if (!(c.length + e & 1)) c += '0';\r\n      s = Math.sqrt(c);\r\n      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\r\n    } else {\r\n      r = new Big(s + '');\r\n    }\r\n\r\n    e = r.e + (Big.DP += 4);\r\n\r\n    // Newton-Raphson iteration.\r\n    do {\r\n      t = r;\r\n      r = half.times(t.plus(x.div(t)));\r\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\r\n\r\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big times the value of Big y.\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var c,\r\n      x = this,\r\n      Big = x.constructor,\r\n      xc = x.c,\r\n      yc = (y = new Big(y)).c,\r\n      a = xc.length,\r\n      b = yc.length,\r\n      i = x.e,\r\n      j = y.e;\r\n\r\n    // Determine sign of result.\r\n    y.s = x.s == y.s ? 1 : -1;\r\n\r\n    // Return signed 0 if either 0.\r\n    if (!xc[0] || !yc[0]) {\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // Initialise exponent of result as x.e + y.e.\r\n    y.e = i + j;\r\n\r\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n    if (a < b) {\r\n      c = xc;\r\n      xc = yc;\r\n      yc = c;\r\n      j = a;\r\n      a = b;\r\n      b = j;\r\n    }\r\n\r\n    // Initialise coefficient array of result with zeros.\r\n    for (c = new Array(j = a + b); j--;) c[j] = 0;\r\n\r\n    // Multiply.\r\n\r\n    // i is initially xc.length.\r\n    for (i = b; i--;) {\r\n      b = 0;\r\n\r\n      // a is yc.length.\r\n      for (j = a + i; j > i;) {\r\n\r\n        // Current sum of products at this digit position, plus carry.\r\n        b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n        c[j--] = b % 10;\r\n\r\n        // carry\r\n        b = b / 10 | 0;\r\n      }\r\n\r\n      c[j] = b;\r\n    }\r\n\r\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\r\n    if (b) ++y.e;\r\n    else c.shift();\r\n\r\n    // Remove trailing zeros.\r\n    for (i = c.length; !c[--i];) c.pop();\r\n    y.c = c;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), ++dp, rm);\r\n      for (; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, true, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), dp + x.e + 1, rm);\r\n\r\n      // x.e may have changed if the value is rounded up.\r\n      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, false, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Omit the sign for negative zero.\r\n   */\r\n  P.toJSON = P.toString = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Big as a primitve number.\r\n   */\r\n  P.toNumber = function () {\r\n    var n = +stringify(this, true, true);\r\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\r\n      throw Error(NAME + 'Imprecise conversion');\r\n    }\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big rounded to sd significant digits using\r\n   * rounding mode rm, or Big.RM if rm is not specified.\r\n   * Use exponential notation if sd is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      n = x.c[0];\r\n\r\n    if (sd !== UNDEFINED) {\r\n      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n        throw Error(INVALID + 'precision');\r\n      }\r\n      x = round(new Big(x), sd, rm);\r\n      for (; x.c.length < sd;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Include the sign for negative zero.\r\n   */\r\n  P.valueOf = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    if (Big.strict === true) {\r\n      throw Error(NAME + 'valueOf disallowed');\r\n    }\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\r\n  };\r\n\r\n\r\n  // Export\r\n\r\n\r\n  Big = _Big_();\r\n\r\n  Big['default'] = Big.Big = Big;\r\n\r\n  //AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () { return Big; });\r\n\r\n  // Node and other CommonJS-like environments that support module.exports.\r\n  } else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Big;\r\n\r\n  //Browser.\r\n  } else {\r\n    GLOBAL.Big = Big;\r\n  }\r\n})(this);\r\n\n},{}],18:[function(require,module,exports){\n\n},{}],19:[function(require,module,exports){\narguments[4][18][0].apply(exports,arguments)\n},{\"dup\":18}],20:[function(require,module,exports){\n(function (Buffer){(function (){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"base64-js\":16,\"buffer\":20,\"ieee754\":79}],21:[function(require,module,exports){\nmodule.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n\n},{}],22:[function(require,module,exports){\n/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - pet friendly\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'ObjectCache';\n\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._RecordMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\tget RecordMap()\n\t{\n\t\treturn this._RecordMap;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\tthis._RecordMap[pHash] = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\t\tthis._RecordMap[pHash] = pData;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._RecordMap[pHash];\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t{\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\t\t\t}\n\t\t}\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;\n},{\"./LinkedList.js\":24,\"fable-serviceproviderbase\":59}],23:[function(require,module,exports){\n/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;\n},{}],24:[function(require,module,exports){\n\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;\n},{\"./LinkedList-Node.js\":23}],25:[function(require,module,exports){\n'use strict';\n\nvar bind = require('function-bind');\n\nvar $apply = require('./functionApply');\nvar $call = require('./functionCall');\nvar $reflectApply = require('./reflectApply');\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n\n},{\"./functionApply\":26,\"./functionCall\":27,\"./reflectApply\":29,\"function-bind\":68}],26:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n\n},{}],27:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\nvar bind = require('function-bind');\nvar $TypeError = require('es-errors/type');\n\nvar $call = require('./functionCall');\nvar $actualApply = require('./actualApply');\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n\n},{\"./actualApply\":25,\"./functionCall\":27,\"es-errors/type\":47,\"function-bind\":68}],29:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n\n},{}],30:[function(require,module,exports){\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBindBasic = require('call-bind-apply-helpers');\n\n/** @type {(thisArg: string, searchString: string, position?: number) => number} */\nvar $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);\n\n/** @type {import('.')} */\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\t/* eslint no-extra-parens: 0 */\n\n\tvar intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBindBasic(/** @type {const} */ ([intrinsic]));\n\t}\n\treturn intrinsic;\n};\n\n},{\"call-bind-apply-helpers\":28,\"get-intrinsic\":69}],31:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCookie = parseCookie;\nexports.parse = parseCookie;\nexports.stringifyCookie = stringifyCookie;\nexports.stringifySetCookie = stringifySetCookie;\nexports.serialize = stringifySetCookie;\nexports.parseSetCookie = parseSetCookie;\nexports.stringifySetCookie = stringifySetCookie;\nexports.serialize = stringifySetCookie;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n/**\n * RegExp to match max-age-value in RFC 6265 sec 5.6.2\n */\nconst maxAgeRegExp = /^-?\\d+$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a `Cookie` header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parseCookie(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = eqIndex(str, index, len);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const endIdx = endIndex(str, index, len);\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const key = valueSlice(str, index, eqIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\n/**\n * Stringifies an object into an HTTP `Cookie` header.\n */\nfunction stringifyCookie(cookie, options) {\n    const enc = options?.encode || encodeURIComponent;\n    const cookieStrings = [];\n    for (const name of Object.keys(cookie)) {\n        const val = cookie[name];\n        if (val === undefined)\n            continue;\n        if (!cookieNameRegExp.test(name)) {\n            throw new TypeError(`cookie name is invalid: ${name}`);\n        }\n        const value = enc(val);\n        if (!cookieValueRegExp.test(value)) {\n            throw new TypeError(`cookie val is invalid: ${val}`);\n        }\n        cookieStrings.push(`${name}=${value}`);\n    }\n    return cookieStrings.join(\"; \");\n}\nfunction stringifySetCookie(_name, _val, _opts) {\n    const cookie = typeof _name === \"object\"\n        ? _name\n        : { ..._opts, name: _name, value: String(_val) };\n    const options = typeof _val === \"object\" ? _val : _opts;\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(cookie.name)) {\n        throw new TypeError(`argument name is invalid: ${cookie.name}`);\n    }\n    const value = cookie.value ? enc(cookie.value) : \"\";\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${cookie.value}`);\n    }\n    let str = cookie.name + \"=\" + value;\n    if (cookie.maxAge !== undefined) {\n        if (!Number.isInteger(cookie.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);\n        }\n        str += \"; Max-Age=\" + cookie.maxAge;\n    }\n    if (cookie.domain) {\n        if (!domainValueRegExp.test(cookie.domain)) {\n            throw new TypeError(`option domain is invalid: ${cookie.domain}`);\n        }\n        str += \"; Domain=\" + cookie.domain;\n    }\n    if (cookie.path) {\n        if (!pathValueRegExp.test(cookie.path)) {\n            throw new TypeError(`option path is invalid: ${cookie.path}`);\n        }\n        str += \"; Path=\" + cookie.path;\n    }\n    if (cookie.expires) {\n        if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${cookie.expires}`);\n        }\n        str += \"; Expires=\" + cookie.expires.toUTCString();\n    }\n    if (cookie.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (cookie.secure) {\n        str += \"; Secure\";\n    }\n    if (cookie.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (cookie.priority) {\n        const priority = typeof cookie.priority === \"string\"\n            ? cookie.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${cookie.priority}`);\n        }\n    }\n    if (cookie.sameSite) {\n        const sameSite = typeof cookie.sameSite === \"string\"\n            ? cookie.sameSite.toLowerCase()\n            : cookie.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * Deserialize a `Set-Cookie` header into an object.\n *\n * deserialize('foo=bar; httpOnly')\n *   => { name: 'foo', value: 'bar', httpOnly: true }\n */\nfunction parseSetCookie(str, options) {\n    const dec = options?.decode || decode;\n    const len = str.length;\n    const endIdx = endIndex(str, 0, len);\n    const eqIdx = eqIndex(str, 0, endIdx);\n    const setCookie = eqIdx === -1\n        ? { name: \"\", value: dec(valueSlice(str, 0, endIdx)) }\n        : {\n            name: valueSlice(str, 0, eqIdx),\n            value: dec(valueSlice(str, eqIdx + 1, endIdx)),\n        };\n    let index = endIdx + 1;\n    while (index < len) {\n        const endIdx = endIndex(str, index, len);\n        const eqIdx = eqIndex(str, index, endIdx);\n        const attr = eqIdx === -1\n            ? valueSlice(str, index, endIdx)\n            : valueSlice(str, index, eqIdx);\n        const val = eqIdx === -1 ? undefined : valueSlice(str, eqIdx + 1, endIdx);\n        switch (attr.toLowerCase()) {\n            case \"httponly\":\n                setCookie.httpOnly = true;\n                break;\n            case \"secure\":\n                setCookie.secure = true;\n                break;\n            case \"partitioned\":\n                setCookie.partitioned = true;\n                break;\n            case \"domain\":\n                setCookie.domain = val;\n                break;\n            case \"path\":\n                setCookie.path = val;\n                break;\n            case \"max-age\":\n                if (val && maxAgeRegExp.test(val))\n                    setCookie.maxAge = Number(val);\n                break;\n            case \"expires\":\n                if (!val)\n                    break;\n                const date = new Date(val);\n                if (Number.isFinite(date.valueOf()))\n                    setCookie.expires = date;\n                break;\n            case \"priority\":\n                if (!val)\n                    break;\n                const priority = val.toLowerCase();\n                if (priority === \"low\" ||\n                    priority === \"medium\" ||\n                    priority === \"high\") {\n                    setCookie.priority = priority;\n                }\n                break;\n            case \"samesite\":\n                if (!val)\n                    break;\n                const sameSite = val.toLowerCase();\n                if (sameSite === \"lax\" ||\n                    sameSite === \"strict\" ||\n                    sameSite === \"none\") {\n                    setCookie.sameSite = sameSite;\n                }\n                break;\n        }\n        index = endIdx + 1;\n    }\n    return setCookie;\n}\n/**\n * Find the `;` character between `min` and `len` in str.\n */\nfunction endIndex(str, min, len) {\n    const index = str.indexOf(\";\", min);\n    return index === -1 ? len : index;\n}\n/**\n * Find the `=` character between `min` and `max` in str.\n */\nfunction eqIndex(str, min, max) {\n    const index = str.indexOf(\"=\", min);\n    return index < max ? index : -1;\n}\n/**\n * Slice out a value between startPod to max.\n */\nfunction valueSlice(str, min, max) {\n    let start = min;\n    let end = max;\n    do {\n        const code = str.charCodeAt(start);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            break;\n    } while (++start < end);\n    while (end > start) {\n        const code = str.charCodeAt(end - 1);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            break;\n        end--;\n    }\n    return str.slice(start, end);\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n\n},{}],32:[function(require,module,exports){\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));\n},{}],33:[function(require,module,exports){\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_advancedFormat=t()}(this,(function(){\"use strict\";return function(e,t){var r=t.prototype,n=r.format;r.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return n.bind(this)(e);var s=this.$utils(),a=(e||\"YYYY-MM-DDTHH:mm:ssZ\").replace(/\\[([^\\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case\"Q\":return Math.ceil((t.$M+1)/3);case\"Do\":return r.ordinal(t.$D);case\"gggg\":return t.weekYear();case\"GGGG\":return t.isoWeekYear();case\"wo\":return r.ordinal(t.week(),\"W\");case\"w\":case\"ww\":return s.s(t.week(),\"w\"===e?1:2,\"0\");case\"W\":case\"WW\":return s.s(t.isoWeek(),\"W\"===e?1:2,\"0\");case\"k\":case\"kk\":return s.s(String(0===t.$H?24:t.$H),\"k\"===e?1:2,\"0\");case\"X\":return Math.floor(t.$d.getTime()/1e3);case\"x\":return t.$d.getTime();case\"z\":return\"[\"+t.offsetName()+\"]\";case\"zzz\":return\"[\"+t.offsetName(\"long\")+\"]\";default:return e}}));return n.bind(this)(a)}}}));\n},{}],34:[function(require,module,exports){\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_isoWeek=t()}(this,(function(){\"use strict\";var e=\"day\";return function(t,i,s){var a=function(t){return t.add(4-t.isoWeekday(),e)},d=i.prototype;d.isoWeekYear=function(){return a(this).year()},d.isoWeek=function(t){if(!this.$utils().u(t))return this.add(7*(t-this.isoWeek()),e);var i,d,n,o,r=a(this),u=(i=this.isoWeekYear(),d=this.$u,n=(d?s.utc:s)().year(i).startOf(\"year\"),o=4-n.isoWeekday(),n.isoWeekday()>4&&(o+=7),n.add(o,e));return r.diff(u,\"week\")+1},d.isoWeekday=function(e){return this.$utils().u(e)?this.day()||7:this.day(this.day()%7?e:e-7)};var n=d.startOf;d.startOf=function(e,t){var i=this.$utils(),s=!!i.u(t)||t;return\"isoweek\"===i.p(e)?s?this.date(this.date()-(this.isoWeekday()-1)).startOf(\"day\"):this.date(this.date()-1-(this.isoWeekday()-1)+7).endOf(\"day\"):n.bind(this)(e,t)}}}));\n},{}],35:[function(require,module,exports){\n!function(r,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(r=\"undefined\"!=typeof globalThis?globalThis:r||self).dayjs_plugin_relativeTime=e()}(this,(function(){\"use strict\";return function(r,e,t){r=r||{};var n=e.prototype,o={future:\"in %s\",past:\"%s ago\",s:\"a few seconds\",m:\"a minute\",mm:\"%d minutes\",h:\"an hour\",hh:\"%d hours\",d:\"a day\",dd:\"%d days\",M:\"a month\",MM:\"%d months\",y:\"a year\",yy:\"%d years\"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:\"s\",r:44,d:\"second\"},{l:\"m\",r:89},{l:\"mm\",r:44,d:\"minute\"},{l:\"h\",r:89},{l:\"hh\",r:21,d:\"hour\"},{l:\"d\",r:35},{l:\"dd\",r:25,d:\"day\"},{l:\"M\",r:45},{l:\"MM\",r:10,d:\"month\"},{l:\"y\",r:17},{l:\"yy\",d:\"year\"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(\"\"+p)),a=\"string\"==typeof v?v.replace(\"%d\",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return\"function\"==typeof M?M(a):M.replace(\"%s\",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));\n},{}],36:[function(require,module,exports){\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_timezone=e()}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,h=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n,i=this.utcOffset(),a=this.toDate(),u=a.toLocaleString(\"en-US\",{timeZone:t}),f=Math.round((a-new Date(u))/1e3/60),s=15*-Math.round(a.getTimezoneOffset()/15)-f;if(!Number(s))n=this.utcOffset(0,e);else if(n=o(u,{locale:this.$L}).$set(\"millisecond\",this.$ms).utcOffset(s,!0),e){var m=n.utcOffset();n=n.add(i-m,\"minute\")}return n.$x.$timezone=t,n},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));\n},{}],37:[function(require,module,exports){\n!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_utc=i()}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var r=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),r.call(this,t)};var o=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else o.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s;if(0===u)return this.utc(f);var r=this.clone();if(f)return r.$offset=u,r.$u=!1,r;var o=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();return(r=this.local().add(u+o,t)).$offset=u,r.$x.$localOffset=o,r};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));\n},{}],38:[function(require,module,exports){\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekOfYear=t()}(this,(function(){\"use strict\";var e=\"week\",t=\"year\";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),\"day\");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,\"millisecond\"),o=this.diff(a,e,!0);return o<0?r(this).startOf(\"week\").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}));\n},{}],39:[function(require,module,exports){\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekday=t()}(this,(function(){\"use strict\";return function(e,t){t.prototype.weekday=function(e){var t=this.$locale().weekStart||0,i=this.$W,n=(i<t?i+7:i)-t;return this.$utils().u(e)?n:this.subtract(n,\"day\").add(e,\"day\")}}}));\n},{}],40:[function(require,module,exports){\n'use strict';\n\nvar callBind = require('call-bind-apply-helpers');\nvar gOPD = require('gopd');\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n\n},{\"call-bind-apply-helpers\":28,\"gopd\":74}],41:[function(require,module,exports){\n'use strict';\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n\n},{}],42:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n\n},{}],43:[function(require,module,exports){\n'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n\n},{}],44:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n\n},{}],45:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n\n},{}],46:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n\n},{}],47:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n\n},{}],48:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n\n},{}],49:[function(require,module,exports){\n'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Object;\n\n},{}],50:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n},{}],51:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"fable-log\",\n    \"version\": \"3.0.17\",\n    \"description\": \"A simple logging wrapper.\",\n    \"main\": \"source/Fable-Log.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-Log.js\",\n        \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n        \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"browser\": {\n        \"./source/Fable-Log-DefaultProviders-Node.js\": \"./source/Fable-Log-DefaultProviders-Web.js\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-log.git\"\n    },\n    \"keywords\": [\n        \"logging\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-log/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-log\",\n    \"devDependencies\": {\n        \"quackage\": \"^1.0.51\"\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.17\"\n    }\n}\n\n},{}],52:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass BaseLogger extends libFableServiceProviderBase\n{\n\tconstructor(pLogStreamSettings, pLogStreamHash)\n\t{\n\t\tsuper(pLogStreamSettings, pLogStreamHash);\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\tthis.serviceType = 'Logging-Provider';\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{\"fable-serviceproviderbase\":59}],53:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":55}],54:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],55:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = ('showtimestamps' in this._Settings) ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = ('formattedtimestamps' in this._Settings) ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = ('Context' in this._Settings) ? `(${this._Settings.Context})` :\n\t\t\t\t\t\t\t\t('Product' in pFableLog._Settings) ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = ('outputloglinestoconsole' in this._Settings) ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = ('outputobjectstoconsole' in this._Settings) ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":52}],56:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t}\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":55,\"fs\":19,\"path\":103}],57:[function(require,module,exports){\n/**\n* Fable Logging Service\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nconst libPackage = require('../package.json');\n\nclass FableLog extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'Logging';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\tlet tmpSettings = (typeof(pSettings) === 'object') ? pSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (('LogStreams' in tmpSettings)) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (pLogger.loggerUUID in this.activeLogStreams)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!(tmpStreamDefinition.loggertype in this._Providers))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\nmodule.exports = FableLog;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderFlatfile = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"../package.json\":51,\"./Fable-Log-BaseLogger.js\":52,\"./Fable-Log-DefaultProviders-Node.js\":53,\"./Fable-Log-DefaultStreams.json\":54,\"./Fable-Log-Logger-Console.js\":55,\"./Fable-Log-Logger-SimpleFlatFile.js\":56,\"fable-serviceproviderbase\":59}],58:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.18\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"types\": \"tsc -p ./tsconfig.build.json\",\n        \"check\": \"tsc -p . --noEmit\"\n    },\n    \"types\": \"types/source/Fable-ServiceProviderBase.d.ts\",\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"@types/mocha\": \"^10.0.10\",\n        \"fable\": \"^3.1.55\",\n        \"quackage\": \"^1.0.51\",\n        \"typescript\": \"^5.9.3\"\n    }\n}\n\n},{}],59:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t/**\n\t * The constructor can be used in two ways:\n\t * 1) With a fable, options object and service hash (the options object and service hash are optional)a\n\t * 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\t *\n\t * @param {import('fable')|Record<string, any>} [pFable] - (optional) The fable instance, or the options object if there is no fable\n\t * @param {Record<string, any>|string} [pOptions] - (optional) The options object, or the service hash if there is no fable\n\t * @param {string} [pServiceHash] - (optional) The service hash to identify this service instance\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t/** @type {import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.options;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.services;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.servicesMap;\n\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Record<string, any>} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\t/**\n\t * @param {import('fable')} pFable\n\t */\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n\n},{\"../package.json\":58}],60:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"fable-settings\",\n  \"version\": \"3.0.15\",\n  \"description\": \"A simple, tolerant configuration chain.\",\n  \"main\": \"source/Fable-Settings.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable-Settings.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"./node_modules/.bin/gulp build\",\n    \"docker-dev-build-image\": \"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-settings:local\",\n    \"docker-dev-run\": \"docker run -it -d --name retold-fable-settings-dev -p 30003:8080 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable-settings\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" retold/fable-settings:local\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable-settings.git\"\n  },\n  \"keywords\": [\n    \"configuration\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable-settings/issues\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable-settings\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"fable-serviceproviderbase\": \"^3.0.17\",\n    \"precedent\": \"^1.0.15\"\n  }\n}\n\n},{}],61:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],62:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\nconst libPrecedent = require('precedent');\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new libPrecedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\tconst tmpDefaultValue = tmpSeparatorIndex >= 0 ? tmpTemplateValue.substring(tmpSeparatorIndex+1) : '';\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (tmpEnvironmentVariableName in process.env)\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":107,\"precedent\":104}],63:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'SettingsManager';\n\n\t\tthis._Package = require('../package.json');\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor();\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\n},{\"../package.json\":60,\"./Fable-Settings-Default\":61,\"./Fable-Settings-TemplateProcessor.js\":62,\"fable-serviceproviderbase\":59}],64:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"fable-uuid\",\n  \"version\": \"3.0.12\",\n  \"description\": \"A simple UUID Generator.\",\n  \"main\": \"source/Fable-UUID.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable-UUID.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"./node_modules/.bin/gulp build\",\n    \"docker-dev-build-image\": \"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-uuid:local\",\n    \"docker-dev-run\": \"docker run -it -d --name retold-fable-uuid-dev -p 30002:8080 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable-uuid\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" retold/fable-uuid:local\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable-uuid.git\"\n  },\n  \"keywords\": [\n    \"logging\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable-uuid/issues\"\n  },\n  \"browser\": {\n    \"./source/Fable-UUID-Random.js\": \"./source/Fable-UUID-Random-Browser.js\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable-uuid\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"fable-serviceproviderbase\": \"^3.0.17\"\n  }\n}\n\n},{}],65:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],66:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;0\n\nconst libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nconst libPackage = require('../package.json');\n\nclass FableUUID extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'UUID';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && ('UUIDModeRandom' in pSettings) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && ('UUIDLength' in pSettings) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && ('UUIDDictionary' in pSettings) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"../package.json\":64,\"./Fable-UUID-Random.js\":65,\"fable-serviceproviderbase\":59}],67:[function(require,module,exports){\n'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n},{}],68:[function(require,module,exports){\n'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n\n},{\"./implementation\":67}],69:[function(require,module,exports){\n'use strict';\n\nvar undefined;\n\nvar $Object = require('es-object-atoms');\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar abs = require('math-intrinsics/abs');\nvar floor = require('math-intrinsics/floor');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar pow = require('math-intrinsics/pow');\nvar round = require('math-intrinsics/round');\nvar sign = require('math-intrinsics/sign');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = require('gopd');\nvar $defineProperty = require('es-define-property');\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = require('get-proto');\nvar $ObjectGPO = require('get-proto/Object.getPrototypeOf');\nvar $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');\n\nvar $apply = require('call-bind-apply-helpers/functionApply');\nvar $call = require('call-bind-apply-helpers/functionCall');\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n},{\"call-bind-apply-helpers/functionApply\":26,\"call-bind-apply-helpers/functionCall\":27,\"es-define-property\":41,\"es-errors\":43,\"es-errors/eval\":42,\"es-errors/range\":44,\"es-errors/ref\":45,\"es-errors/syntax\":46,\"es-errors/type\":47,\"es-errors/uri\":48,\"es-object-atoms\":49,\"function-bind\":68,\"get-proto\":72,\"get-proto/Object.getPrototypeOf\":70,\"get-proto/Reflect.getPrototypeOf\":71,\"gopd\":74,\"has-symbols\":75,\"hasown\":77,\"math-intrinsics/abs\":93,\"math-intrinsics/floor\":94,\"math-intrinsics/max\":96,\"math-intrinsics/min\":97,\"math-intrinsics/pow\":98,\"math-intrinsics/round\":99,\"math-intrinsics/sign\":100}],70:[function(require,module,exports){\n'use strict';\n\nvar $Object = require('es-object-atoms');\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n\n},{\"es-object-atoms\":49}],71:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n\n},{}],72:[function(require,module,exports){\n'use strict';\n\nvar reflectGetProto = require('./Reflect.getPrototypeOf');\nvar originalGetProto = require('./Object.getPrototypeOf');\n\nvar getDunderProto = require('dunder-proto/get');\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n\n},{\"./Object.getPrototypeOf\":70,\"./Reflect.getPrototypeOf\":71,\"dunder-proto/get\":40}],73:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n\n},{}],74:[function(require,module,exports){\n'use strict';\n\n/** @type {import('.')} */\nvar $gOPD = require('./gOPD');\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n},{\"./gOPD\":73}],75:[function(require,module,exports){\n'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n},{\"./shams\":76}],76:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n},{}],77:[function(require,module,exports){\n'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n\n},{\"function-bind\":68}],78:[function(require,module,exports){\nvar http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n\n},{\"http\":124,\"url\":145}],79:[function(require,module,exports){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],80:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n},{}],81:[function(require,module,exports){\n// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\n/**\n * @param {string} pCharacter - The character to remove from the start and end of the string\n * @param {string} pString - The string to clean\n *\n * @return {string} The cleaned string\n */\nconst cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;\n\n},{}],82:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n    /**\n     * @param {function} [pInfoLog] - (optional) A logging function for info messages\n     * @param {function} [pErrorLog] - (optional) A logging function for error messages\n     */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    /**\n     * @return {number} The number of translations in the table\n     */\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    /**\n     * @param {object} pTranslation - An object containing source:destination hash pairs to add to the translation table\n     */\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    /**\n     * @param {string} pTranslationHash - The source hash to remove from the translation table\n     */\n    removeTranslationHash(pTranslationHash)\n    {\n        delete this.translationTable[pTranslationHash];\n    }\n\n    /**\n     * This removes translations.\n     * If passed a string, just removes the single one.\n     * If passed an object, it does all the source keys.\n     *\n     * @param {string|object} pTranslation - Either a source hash string to remove, or an object containing source:destination hash pairs to remove\n     *\n     * @return {boolean} True if the removal was successful, false otherwise\n     */\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    /**\n     * @param {string} pTranslation - The source hash to translate\n     *\n     * @return {string} The translated hash, or the original if no translation exists\n     */\n    translate(pTranslation)\n    {\n        if (pTranslation in this.translationTable)\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;\n\n},{\"./Manyfest-LogToConsole.js\":83}],83:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;\n},{}],84:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Manyfest-LogToConsole.js');\n// This is for resolving functions mid-address\nconst libGetObjectValue = require('./Manyfest-ObjectAddress-GetValue.js');\n\nconst fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n// TODO: Just until this is a fable service.\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) Function to use for info logging\n\t * @param {function} [pErrorLog] - (optional) Function to use for error logging\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.getObjectValueClass = new libGetObjectValue(this.logInfo, this.logError);\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * Check if an address exists.\n\t *\n\t * This is necessary because the getValueAtAddress function is ambiguous on\n\t * whether the element/property is actually there or not (it returns\n\t * undefined whether the property exists or not).  This function checks for\n\t * existance and returns true or false dependent.\n\t *\n\t * @param {object} pObject - The object to check within\n\t * @param {string} pAddress - The address to check for\n\t * @param {object} [pRootObject] - (optional) The root object for function resolution context\n\t *\n\t * @return {boolean} - True if the address exists, false if it does not\n\t */\n\tcheckAddressExists(pObject, pAddress, pRootObject)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\t// NOTE: This was added to support functions mid-stream\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (((tmpFunctionAddress in pObject)) && (typeof(pObject[tmpFunctionAddress]) == 'function'))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn (tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn (pAddress in pObject);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\t//tmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// NOTE: This is where the resolves get really tricky.  Recursion within recursion.  Programming gom jabbar, yo.\n\t\t\t\t\t\ttmpArgumentValues.push(this.getObjectValueClass.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t//return this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// The sub-object doesn't exist, so the address doesn't exist\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;\n\n},{\"./Manyfest-CleanWrapCharacters.js\":81,\"./Manyfest-LogToConsole.js\":83,\"./Manyfest-ObjectAddress-GetValue.js\":86,\"./Manyfest-ObjectAddress-Parser.js\":87}],85:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`)\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// TODO: Dry me\n\t/**\n\t * @param {string} pAddress - The address being evaluated\n\t * @param {object} pRecord - The record being evaluated\n\t *\n\t * @return {boolean} True if the record passes the filters, false if it does not\n\t */\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t/**\n\t * Delete the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to delete the value from\n\t * @param {string} pAddress - The address to delete the value at\n\t * @param {string} [pParentAddress] - (optional) The parent address for recursion\n\t *\n\t * @return {boolean|object|undefined} - True if the value was deleted, false if it could not be deleted, undefined on error\n\t */\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Use enclosure-aware parser to find the first segment separator\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;\n\n},{\"../source/Manyfest-ParseConditionals.js\":90,\"./Manyfest-CleanWrapCharacters.js\":81,\"./Manyfest-LogToConsole.js\":83,\"./Manyfest-ObjectAddress-Parser.js\":87}],86:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`);\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * @param {string} pAddress - The address of the record to check\n\t * @param {object} pRecord - The record to check against the filters\n\t *\n\t * @return {boolean} - True if the record passes the filters, false otherwise\n\t */\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t/**\n\t * Get the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to resolve the address against\n\t * @param {string} pAddress - The address to resolve\n\t * @param {string} [pParentAddress] - (optional) The parent address for back-navigation\n\t * @param {object} [pRootObject] - (optional) The root object for function argument resolution\n\t *\n\t * @return {any} The value at the address, or undefined if not found\n\t */\n\tgetValueAtAddress (pObject, pAddress, pParentAddress, pRootObject)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tif (pObject === null)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// Adding simple back-navigation in objects\n\t\tif (tmpAddressPartBeginning == '')\n\t\t{\n\t\t\t// Given an address of \"Bundle.Contract.IDContract...Project.IDProject\" the ... would be interpreted as two back-navigations from IDContract.\n\t\t\t// When the address is passed in, though, the first . is already eliminated.  So we can count the dots.\n\t\t\tlet tmpParentAddressParts = _MockFable.DataFormat.stringGetSegments(tmpParentAddress);\n\n\t\t\tlet tmpBackNavigationCount = 0;\n\n\t\t\t// Count the number of dots\n\t\t\tfor (let i = 0; i < pAddress.length; i++)\n\t\t\t{\n\t\t\t\tif (pAddress.charAt(i) != '.')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpBackNavigationCount++;\n\t\t\t}\n\n\t\t\tlet tmpParentAddressLength = tmpParentAddressParts.length - tmpBackNavigationCount;\n\n\t\t\tif (tmpParentAddressLength < 0)\n\t\t\t{\n\t\t\t\t// We are trying to back navigate more than we can.\n\t\t\t\t// TODO: Should this be undefined or should we bank out at the bottom and try to go forward?\n\t\t\t\t// This seems safest for now.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are trying to back navigate to a parent object.\n\t\t\t\t// Recurse with the back-propagated parent address, and, the new address without the back-navigation dots.\n\t\t\t\tlet tmpRecurseAddress = pAddress.slice(tmpBackNavigationCount);\n\t\t\t\tif (tmpParentAddressLength > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRecurseAddress = `${tmpParentAddressParts.slice(0, tmpParentAddressLength).join('.')}.${tmpRecurseAddress}`;\n\t\t\t\t}\n\t\t\t\tthis.logInfo(`Back-navigation detected.  Recursing back to address [${tmpRecurseAddress}]`);\n\t\t\t\treturn this.getValueAtAddress(tmpRootObject, tmpRecurseAddress);\n\t\t\t}\n\t\t}\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// TODO: Optimize this by having these calls only happen when the previous fails.\n\t\t\t// TODO: Alternatively look for all markers in one pass?\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(pAddress.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tif (typeof(pObject[pAddress]) != 'undefined')\n\t\t\t\t{\n\t\t\t\t\treturn pObject[pAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//let tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\t//let tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;\n\n},{\"../source/Manyfest-ParseConditionals.js\":90,\"./Manyfest-CleanWrapCharacters.js\":81,\"./Manyfest-LogToConsole.js\":83,\"./Manyfest-ObjectAddress-Parser.js\":87}],87:[function(require,module,exports){\n// TODO: This is an inelegant solution to delay the rewrite of Manyfest.\n\n// Fable 3.0 has a service for data formatting that deals well with nested enclosures.\n\n// The Manyfest library predates fable 3.0 and the services structure of it, so the functions\n// are more or less pure javascript and as functional as they can be made to be.\n\n// Until we shift Manyfest to be a fable service, these three functions were pulled out of\n// fable to aid in parsing functions with nested enclosures.\n\nconst DEFAULT_START_SYMBOL_MAP = { '{': 0, '[': 1, '(': 2 };\nconst DEFAULT_END_SYMBOL_MAP = { '}': 0, ']': 1, ')': 2 };\n\nmodule.exports = {\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {number} - The number of segments in the string\n\t */\n\tstringCountSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t},\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {string} - the first segment in the string as a string\n\t */\n\tstringGetFirstSegment: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t},\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {Array<string>} - the segments in the string as an array of strings\n\t */\n\tstringGetSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t},\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} [pEnclosureStart]\n\t * @param {string} [pEnclosureEnd]\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures: (pString, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t},\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} [pEnclosureStart]\n\t * @param {string} [pEnclosureEnd]\n\t *\n\t * @return {string} - The value of the enclosure at the specified index\n\t */\n\tstringGetEnclosureValueByIndex: (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n}\n\n},{}],88:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * Set the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to set the value in\n\t * @param {string} pAddress - The address to set the value at\n\t * @param {any} pValue - The value to set at the address\n\t *\n\t * @return {boolean} True if the value was set, false otherwise\n\t */\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Use enclosure-aware parser to find the first segment separator\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\t\t\t\tlet tmpIndexIsNumeric = !isNaN(tmpBoxedPropertyNumber);\n\n\t\t\t\tif (pObject[tmpBoxedPropertyName] == null)\n\t\t\t\t{\n\t\t\t\t\tif (tmpIndexIsNumeric)\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = [];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\tif (!(tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\t//TODO: For cases where we have chained [][] properties, this needs to recurse somehow\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(pObject[tmpBoxedPropertyName].length < (tmpBoxedPropertyNumber + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName].push({});\n\t\t\t\t\t}\n\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\t\t\t\tlet tmpIndexIsNumeric = !isNaN(tmpBoxedPropertyNumber);\n\n\t\t\t\t//if (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\tif (pObject[tmpBoxedPropertyName] == null)\n\t\t\t\t{\n\t\t\t\t\tif (tmpIndexIsNumeric)\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = [];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) != tmpIndexIsNumeric)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\tif (!(tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(pObject[tmpBoxedPropertyName].length < (tmpBoxedPropertyNumber + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName].push({});\n\t\t\t\t\t}\n\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!('__ERROR' in pObject))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;\n\n},{\"./Manyfest-CleanWrapCharacters.js\":81,\"./Manyfest-LogToConsole.js\":83,\"./Manyfest-ObjectAddress-Parser.js\":87}],89:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t/**\n\t * generateAddressses\n\t *\n\t * This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t * POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t * quickly.  This is not meant to be used directly to generate schemas, but\n\t * instead as a starting point for scripts or UIs.\n\t *\n\t * This will return a mega set of key:value pairs with all possible schema\n\t * permutations and default values (when not an object) and everything else.\n\t *\n\t * @param {any} pObject - The object to generate addresses for\n\t * @param {string} [pBaseAddress] - (optional) The base address to start from\n\t * @param {object} [pSchema] - (optional) The schema object to append to\n\t *\n\t * @return {object} The generated schema object\n\t */\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'undefined';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;\n\n},{\"./Manyfest-LogToConsole.js\":83}],90:[function(require,module,exports){\n// Given a string, parse out any conditional expressions and set whether or not to keep the record.\n//\n// For instance:\n// \t\t'files[]<<~?format,==,Thumbnail?~>>'\n//      'files[]<<~?format,==,Metadata?~>>'\n//      'files[]<<~?size,>,4000?~>>'\n//\n// The wrapping parts are the <<~? and ?~>> megabrackets.\n//\n// The function does not need to alter the string -- just check the conditionals within.\n\n// TODO: Consider making this an es6 class\n\n// Let's use indexOf since it is apparently the fastest.\nconst _ConditionalStanzaStart = '<<~?';\nconst _ConditionalStanzaStartLength = _ConditionalStanzaStart.length;\nconst _ConditionalStanzaEnd = '?~>>';\nconst _ConditionalStanzaEndLength = _ConditionalStanzaEnd.length;\n\n// Ugh dependency injection.  Can't wait to make these all fable services.\n//let libObjectAddressCheckAddressExists = new (require('./Manyfest-ObjectAddress-CheckAddressExists.js'))();\n\n// Test the condition of a value in a record\nconst testCondition = (pManyfest, pRecord, pSearchAddress, pSearchComparator, pValue) =>\n{\n\tswitch(pSearchComparator)\n\t{\n\t\tcase 'TRUE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === true);\n\t\tcase 'FALSE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === false);\n\t\tcase 'LNGT':\n\t\tcase 'LENGTH_GREATER_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'LNLT':\n\t\tcase 'LENGTH_LESS_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t// TODO: Welcome to dependency hell.  This fixes itself when we move to fable services.\n\t\t// case 'EX':\n\t\t// case 'EXISTS':\n\t\t// \treturn libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\t// case 'DNEX':\n\t\t// case 'DOES_NOT_EXIST':\n\t\t// \treturn !libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\tcase '!=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) != pValue);\n\t\tcase '<':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) < pValue);\n\t\tcase '>':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) > pValue);\n\t\tcase '<=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) <= pValue);\n\t\tcase '>=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) >= pValue);\n\t\tcase '===':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === pValue);\n\t\tcase '==':\n\t\tdefault:\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) == pValue);\n\t}\n};\n\nconst parseConditionals = (pManyfest, pAddress, pRecord) =>\n{\n\tlet tmpKeepRecord = true;\n\n\t/*\n\t\tAlgorithm is simple:\n\n\t\t1.  Enuerate start points\n\t\t2.  Find stop points within each start point\n\t\t3. Check the conditional\n\t*/\n\tlet tmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart);\n\n\twhile (tmpStartIndex != -1)\n\t{\n\t\tlet tmpStopIndex = pAddress.indexOf(_ConditionalStanzaEnd, tmpStartIndex+_ConditionalStanzaStartLength);\n\n\t\tif (tmpStopIndex != -1)\n\t\t{\n\t\t\tlet tmpMagicComparisonPatternSet = pAddress.substring(tmpStartIndex+_ConditionalStanzaStartLength, tmpStopIndex).split(',');\n\n\t\t\t// The address to search for\n\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\n\t\t\t// The copmparison expression (EXISTS as default)\n\t\t\tlet tmpSearchComparator = 'EXISTS';\n\t\t\tif (tmpMagicComparisonPatternSet.length > 1)\n\t\t\t{\n\t\t\t\ttmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t}\n\n\t\t\t// The value to search for\n\t\t\tlet tmpSearchValue = false;\n\t\t\tif (tmpMagicComparisonPatternSet.length > 2)\n\t\t\t{\n\t\t\t\ttmpSearchValue = tmpMagicComparisonPatternSet[2];\n\t\t\t}\n\n\t\t\t// Process the piece\n\t\t\ttmpKeepRecord = tmpKeepRecord && testCondition(pManyfest, pRecord, tmpSearchAddress, tmpSearchComparator, tmpSearchValue);\n\t\t\ttmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart, tmpStopIndex+_ConditionalStanzaEndLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpStartIndex = -1;\n\t\t}\n\n\t}\n\n\treturn tmpKeepRecord;\n}\n\nmodule.exports = parseConditionals;\n\n},{}],91:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t/**\n     * This translates the default address mappings to something different.\n     *\n     * For instance you can pass in manyfest schema descriptor object:\n     * \t{\n\t *\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t *\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t *  }\n     *\n     *\n     * And then an address mapping (basically a Hash->Address map)\n     *  {\n     *    \"a\": \"New.Address.Of.a\",\n     *    \"b\": \"New.Address.Of.b\"\n     *  }\n     *\n     * NOTE: This mutates the schema object permanently, altering the base hash.\n     *       If there is a collision with an existing address, it can lead to overwrites.\n     * TODO: Discuss what should happen on collisions.\n\t *\n\t * @param {object} pManyfestSchemaDescriptors - The manyfest schema descriptors to resolve address mappings for\n\t * @param {object} pAddressMapping - The address mapping object to use for remapping\n\t *\n\t * @return {boolean} True if successful, false if there was an error\n\t */\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif ('Hash' in pManyfestSchemaDescriptors[pAddress])\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = null;\n\t\t\t\tlet tmpDescriptor;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pInputAddress in pManyfestSchemaDescriptors)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (pInputAddress in tmpHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {object} pManyfestSchemaDescriptors - The manyfest schema descriptors to resolve address mappings for\n\t * @param {object} pAddressMapping - The address mapping object to use for remapping\n\t *\n\t * @return {object} A new object containing the remapped schema descriptors\n\t */\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\t/**\n\t * @param {object} pManyfestSchemaDescriptorsDestination - The destination manyfest schema descriptors\n\t * @param {object} pManyfestSchemaDescriptorsSource - The source manyfest schema descriptors\n\t *\n\t * @return {object} A new object containing the merged schema descriptors\n\t */\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!(pDescriptorAddress in tmpNewManyfestSchemaDescriptors))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;\n\n},{\"./Manyfest-LogToConsole.js\":83}],92:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\nconst _DefaultConfiguration = { Scope:'DEFAULT', Descriptors: {} }\n\n/**\n * @typedef {{\n *   Hash?: string,\n *   Name?: string,\n *   DataType?: string,\n *   Required?: boolean,\n *   Address?: string,\n *   Description?: string,\n *   [key: string]: any,\n * }} ManifestDescriptor\n */\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n\t\t/** @type {import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.options;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\n        this.serviceType = 'Manifest';\n\n\t\t// Wire in logging\n\t\tthis.logInfo = libSimpleLog;\n\t\tthis.logError = libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tif (!('defaultValues' in this.options))\n\t\t{\n\t\t\tthis.options.defaultValues = (\n\t\t\t\t{\n\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\"PreciseNumber\": \"0.0\",\n\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\"Null\": null\n\t\t\t\t});\n\t\t}\n\t\tif (!('strict' in this.options))\n\t\t{\n\t\t\tthis.options.strict = false;\n\t\t}\n\n\t\t/** @type {string} */\n\t\tthis.scope = undefined;\n\t\t/** @type {Array<string>} */\n\t\tthis.elementAddresses = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.elementHashes = undefined;\n\t\t/** @type {Record<string, ManifestDescriptor>} */\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(this.options) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(this.options);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\n\t\tthis.numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.fable, tmpNewOptions, this.Hash);\n\t\ttmpNewManyfest.logInfo = this.logInfo;\n\t\ttmpNewManyfest.logError = this.logError;\n\t\t//FIXME: mostly written by co-pilot\n\t\tconst { Scope, Descriptors, HashTranslations } = this.getManifest();\n\t\ttmpNewManyfest.scope = Scope;\n\t\ttmpNewManyfest.elementDescriptors = Descriptors;\n\t\ttmpNewManyfest.elementAddresses = Object.keys(Descriptors);\n\t\t// Rebuild the element hashes\n\t\tfor (let i = 0; i < tmpNewManyfest.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpAddress = tmpNewManyfest.elementAddresses[i];\n\t\t\tlet tmpDescriptor = tmpNewManyfest.elementDescriptors[tmpAddress];\n\t\t\ttmpNewManyfest.elementHashes[tmpAddress] = tmpAddress;\n\t\t\tif ('Hash' in tmpDescriptor)\n\t\t\t{\n\t\t\t\ttmpNewManyfest.elementHashes[tmpDescriptor.Hash] = tmpAddress;\n\t\t\t}\n\t\t}\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\t/**\n\t * @param {string} pManifestString - The manifest string to deserialize\n\t *\n\t * @return {Manyfest} The deserialized manifest\n\t */\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\tthis.loadManifest(JSON.parse(pManifestString));\n\t\treturn this;\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t}\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : {};\n\n\t\tlet tmpDescriptorKeys = Object.keys(_DefaultConfiguration);\n\n\t\tfor (let i = 0; i < tmpDescriptorKeys.length; i++)\n\t\t{\n\t\t\tif (!(tmpDescriptorKeys[i] in tmpManifest))\n\t\t\t{\n\t\t\t\ttmpManifest[tmpDescriptorKeys[i]] = JSON.parse(JSON.stringify(_DefaultConfiguration[tmpDescriptorKeys[i]]));\n\t\t\t}\n\t\t}\n\n\t\tif ('Scope' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = tmpManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(tmpManifest.Scope)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, tmpManifest);\n\t\t}\n\n\t\tif ('Descriptors' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(tmpManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], tmpManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(tmpManifest.Descriptors)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, tmpManifest);\n\t\t}\n\n\t\tif ('HashTranslations' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.HashTranslations) === 'object')\n\t\t\t{\n\t\t\t\t// HashTranslations is serialized as a plain object of source:target pairs\n\t\t\t\tthis.hashTranslations.addTranslation(tmpManifest.HashTranslations);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Serialize the Manifest to a string\n\t *\n\t * @return {string} - The serialized manifest\n\t */\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\t/**\n\t * @return {{ Scope: string, Descriptors: Record<string, ManifestDescriptor>, HashTranslations: Record<string, string> }} - A copy of the manifest state.\n\t */\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors)),\n\t\t\t\tHashTranslations: JSON.parse(JSON.stringify(this.hashTranslations.translationTable))\n\t\t\t});\n\t}\n\n\t/**\n\t * Add a descriptor to the manifest\n\t *\n\t * @param {string} pAddress - The address of the element to add the descriptor for.\n\t * @param {ManifestDescriptor} pDescriptor - The descriptor object to add.\n\t */\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!('Address' in pDescriptor))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!(pAddress in this.elementDescriptors))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif ('Hash' in pDescriptor)\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} pHash - The hash of the address to resolve.\n\t *\n\t * @return {ManifestDescriptor} The descriptor for the address\n\t */\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\t/**\n\t * @param {string} pAddress - The address of the element to get the descriptor for.\n\t *\n\t * @return {ManifestDescriptor} The descriptor for the address\n\t */\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/**\n\t * execute an action function for each descriptor\n\t * @param {(d: ManifestDescriptor) => void} fAction - The action function to execute for each descriptor.\n\t */\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = (pHash in this.elementHashes);\n\t\tlet tmpInTranslationTable = (pHash in this.hashTranslations.translationTable);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && (this.hashTranslations.translate(pHash) in this.elementHashes))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\tlintAddress(pAddress)\n\t{\n\t\t// Guard against non-string input\n\t\tif (typeof(pAddress) != 'string')\n\t\t{\n\t\t\treturn '';\n\t\t}\n\t\tlet tmpLintedAddress = pAddress.trim();\n\t\t// Check for a single trailing . (but not a ..) at the end of the address and remove it.\n\t\t// We must not strip '..' because that is back-navigation syntax.\n\t\tif (tmpLintedAddress.endsWith('.') && !tmpLintedAddress.endsWith('..'))\n\t\t{\n\t\t\ttmpLintedAddress = tmpLintedAddress.slice(0, -1);\n\t\t}\n\n\t\treturn tmpLintedAddress;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\tif (tmpLintedAddress == '')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error getting value at address; address is an empty string.`, pObject);\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, tmpLintedAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(tmpLintedAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, tmpLintedAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, tmpLintedAddress);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"precisenumber\":\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!this.numberRegex.test(tmpValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not a valid number`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tif (tmpElementType != 'boolean')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'datetime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t/**\n\t * Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\t *\n\t * @param {ManifestDescriptor} pDescriptor - The descriptor definition.\n\t */\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ('Default' in pDescriptor)\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = ('DataType' in pDescriptor) ? pDescriptor.DataType : 'String';\n\t\t\tif (tmpDataType in this.options.defaultValues)\n\t\t\t{\n\t\t\t\tlet tmpDefaultValue = this.options.defaultValues[tmpDataType];\n\t\t\t\t// Return a copy of mutable defaults (Array and Object) to prevent shared state\n\t\t\t\tif (typeof(tmpDefaultValue) == 'object' && tmpDefaultValue !== null)\n\t\t\t\t{\n\t\t\t\t\treturn JSON.parse(JSON.stringify(tmpDefaultValue));\n\t\t\t\t}\n\t\t\t\treturn tmpDefaultValue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn ('Default' in pDescriptor);\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;\n\n},{\"./Manyfest-HashTranslation.js\":82,\"./Manyfest-LogToConsole.js\":83,\"./Manyfest-ObjectAddress-CheckAddressExists.js\":84,\"./Manyfest-ObjectAddress-DeleteValue.js\":85,\"./Manyfest-ObjectAddress-GetValue.js\":86,\"./Manyfest-ObjectAddress-SetValue.js\":88,\"./Manyfest-ObjectAddressGeneration.js\":89,\"./Manyfest-SchemaManipulation.js\":91,\"fable-serviceproviderbase\":59}],93:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n\n},{}],94:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n\n},{}],95:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\n},{}],96:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n\n},{}],97:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n\n},{}],98:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n\n},{}],99:[function(require,module,exports){\n'use strict';\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n\n},{}],100:[function(require,module,exports){\n'use strict';\n\nvar $isNaN = require('./isNaN');\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n\n},{\"./isNaN\":95}],101:[function(require,module,exports){\n(function (global){(function (){\nvar hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = require('./util.inspect');\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nvar quotes = {\n    __proto__: null,\n    'double': '\"',\n    single: \"'\"\n};\nvar quoteREs = {\n    __proto__: null,\n    'double': /([\"\\\\])/g,\n    single: /(['\\\\])/g\n};\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (\n        (typeof globalThis !== 'undefined' && obj === globalThis)\n        || (typeof global !== 'undefined' && obj === global)\n    ) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var style = opts.quoteStyle || defaultStyle;\n    var quoteChar = quotes[style];\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction canTrustToString(obj) {\n    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));\n}\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    var quoteRE = quoteREs[opts.quoteStyle || 'single'];\n    quoteRE.lastIndex = 0;\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, quoteRE, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util.inspect\":18}],102:[function(require,module,exports){\nvar wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n},{\"wrappy\":147}],103:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":107}],104:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":105,\"./WordTree.js\":106}],105:[function(require,module,exports){\n/**\n* String Parser\n* @author      Steven Velozo <steven@velozo.com>\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tAsynchronous: false,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: {},\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchEnd: false\n\t\t});\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\tresetOutputBuffer (pParserState)\n\t{\n\t\t// Flush the output buffer.\n\t\tthis.flushOutputBuffer(pParserState);\n\t\t// End pattern mode\n\t\tpParserState.Pattern = false;\n\t\tpParserState.PatternStartNode = false;\n\t\tpParserState.StartPatternMatchComplete = false;\n\t\tpParserState.EndPatternMatchBegan = false;\n\t\tpParserState.PatternMatch = false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && pParserState.Pattern.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif (pParserState.Pattern.hasOwnProperty('Parse'))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the function\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData);\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pParserState.PatternStartNode.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pParserState.Pattern.hasOwnProperty('PatternEnd'))\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif (pParserState.Pattern.hasOwnProperty('Parse'))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the t*mplate function\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData);\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\tif (!pParserState.PatternMatch)\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t */\n\tparseString (pString, pParseTree, pData)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData);\n\t\t}\n\n\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],106:[function(require,module,exports){\n/**\n* Word Tree\n* @author      Steven Velozo <steven@velozo.com>\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern))\n\t\t{\n\t\t\tpTree[pPattern] = {};\n\t\t}\n\n\t\treturn pTree[pPattern];\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree PatternEnd subtree\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddEndChild (pTree, pPattern)\n\t{\n\t\tif (!pTree.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\tpTree.PatternEnd = {};\n\t\t}\n\n\t\tpTree.PatternEnd[pPattern] = {};\n\n\t\treturn pTree.PatternEnd[pPattern];\n\t}\n\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, fParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart[i], i);\n\t\t}\n\n\t\tif (!tmpLeaf.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\ttmpLeaf.PatternEnd = {};\n\t\t}\n\n\t\tlet tmpPatternEnd = (typeof(pPatternEnd) === 'string') ? pPatternEnd : pPatternStart;\n\t\tfor (let i = 0; i < tmpPatternEnd.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addEndChild(tmpLeaf, tmpPatternEnd[i], i);\n\t\t}\n\n\t\ttmpLeaf.PatternStartString = pPatternStart;\n\t\ttmpLeaf.PatternEndString = tmpPatternEnd;\n\t\ttmpLeaf.Parse = (typeof(fParser) === 'function') ? fParser :\n\t\t\t\t\t\t(typeof(fParser) === 'string') ? () => { return fParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],107:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],108:[function(require,module,exports){\n(function (global){(function (){\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],109:[function(require,module,exports){\n'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = {\n    'default': Format.RFC3986,\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return String(value);\n        }\n    },\n    RFC1738: Format.RFC1738,\n    RFC3986: Format.RFC3986\n};\n\n},{}],110:[function(require,module,exports){\n'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n\n},{\"./formats\":109,\"./parse\":111,\"./stringify\":112}],111:[function(require,module,exports){\n'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowEmptyArrays: false,\n    allowPrototypes: false,\n    allowSparse: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decodeDotInKeys: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    duplicates: 'combine',\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictDepth: false,\n    strictMerge: true,\n    strictNullHandling: false,\n    throwOnLimitExceeded: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\nvar parseArrayValue = function (val, options, currentArrayLength) {\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n        return val.split(',');\n    }\n\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n\n    return val;\n};\n\n// This is what browsers will submit when the  character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the  character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = { __proto__: null };\n\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n\n    var limit = options.parameterLimit === Infinity ? void undefined : options.parameterLimit;\n    var parts = cleanStr.split(\n        options.delimiter,\n        options.throwOnLimitExceeded ? limit + 1 : limit\n    );\n\n    if (options.throwOnLimitExceeded && parts.length > limit) {\n        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');\n    }\n\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key;\n        var val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n\n            if (key !== null) {\n                val = utils.maybeMap(\n                    parseArrayValue(\n                        part.slice(pos + 1),\n                        options,\n                        isArray(obj[key]) ? obj[key].length : 0\n                    ),\n                    function (encodedVal) {\n                        return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n                    }\n                );\n            }\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(String(val));\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        if (options.comma && isArray(val) && val.length > options.arrayLimit) {\n            if (options.throwOnLimitExceeded) {\n                throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n            }\n            val = utils.combine([], val, options.arrayLimit, options.plainObjects);\n        }\n\n        if (key !== null) {\n            var existing = has.call(obj, key);\n            if (existing && (options.duplicates === 'combine' || part.indexOf('[]=') > -1)) {\n                obj[key] = utils.combine(\n                    obj[key],\n                    val,\n                    options.arrayLimit,\n                    options.plainObjects\n                );\n            } else if (!existing || options.duplicates === 'last') {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options, valuesParsed) {\n    var currentArrayLength = 0;\n    if (chain.length > 0 && chain[chain.length - 1] === '[]') {\n        var parentKey = chain.slice(0, -1).join('');\n        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;\n    }\n\n    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            if (utils.isOverflow(leaf)) {\n                // leaf is already an overflow object, preserve it\n                obj = leaf;\n            } else {\n                obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n                    ? []\n                    : utils.combine(\n                        [],\n                        leaf,\n                        options.arrayLimit,\n                        options.plainObjects\n                    );\n            }\n        } else {\n            obj = options.plainObjects ? { __proto__: null } : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;\n            var index = parseInt(decodedRoot, 10);\n            var isValidArrayIndex = !isNaN(index)\n                && root !== decodedRoot\n                && String(index) === decodedRoot\n                && index >= 0\n                && options.parseArrays;\n            if (!options.parseArrays && decodedRoot === '') {\n                obj = { 0: leaf };\n            } else if (isValidArrayIndex && index < options.arrayLimit) {\n                obj = [];\n                obj[index] = leaf;\n            } else if (isValidArrayIndex && options.throwOnLimitExceeded) {\n                throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n            } else if (isValidArrayIndex) {\n                obj[index] = leaf;\n                utils.markOverflow(obj, index);\n            } else if (decodedRoot !== '__proto__') {\n                obj[decodedRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar splitKeyIntoSegments = function splitKeyIntoSegments(givenKey, options) {\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    if (options.depth <= 0) {\n        if (!options.plainObjects && has.call(Object.prototype, key)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        return [key];\n    }\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    var keys = [];\n\n    if (parent) {\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys[keys.length] = parent;\n    }\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n\n        var segmentContent = segment[1].slice(1, -1);\n        if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys[keys.length] = segment[1];\n    }\n\n    if (segment) {\n        if (options.strictDepth === true) {\n            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');\n        }\n\n        keys[keys.length] = '[' + key.slice(segment.index) + ']';\n    }\n\n    return keys;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n    if (!givenKey) {\n        return;\n    }\n\n    var keys = splitKeyIntoSegments(givenKey, options);\n\n    if (!keys) {\n        return;\n    }\n\n    return parseObject(keys, val, options, valuesParsed);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {\n        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {\n        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');\n    }\n\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;\n\n    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {\n        throw new TypeError('The duplicates option must be either combine, first, or last');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        duplicates: duplicates,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,\n        strictMerge: typeof opts.strictMerge === 'boolean' ? !!opts.strictMerge : defaults.strictMerge,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? { __proto__: null } : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? { __proto__: null } : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    if (options.allowSparse === true) {\n        return obj;\n    }\n\n    return utils.compact(obj);\n};\n\n},{\"./utils\":113}],112:[function(require,module,exports){\n'use strict';\n\nvar getSideChannel = require('side-channel');\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    commaRoundTrip: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    filter: void undefined,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar sentinel = {};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    commaRoundTrip,\n    allowEmptyArrays,\n    strictNullHandling,\n    skipNulls,\n    encodeDotInKeys,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    format,\n    formatter,\n    encodeValuesOnly,\n    charset,\n    sideChannel\n) {\n    var obj = object;\n\n    var tmpSc = sideChannel;\n    var step = 0;\n    var findFlag = false;\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n        // Where object last appeared in the ref tree\n        var pos = tmpSc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            } else {\n                findFlag = true; // Break while\n            }\n        }\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = utils.maybeMap(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            return value;\n        });\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            obj = utils.maybeMap(obj, encoder);\n        }\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    } else if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;\n\n    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {\n        return adjustedPrefix + '[]';\n    }\n\n    for (var j = 0; j < objKeys.length; ++j) {\n        var key = objKeys[j];\n        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'\n            ? key.value\n            : obj[key];\n\n        if (skipNulls && value === null) {\n            continue;\n        }\n\n        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\\./g, '%2E') : String(key);\n        var keyPrefix = isArray(obj)\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix\n            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');\n\n        sideChannel.set(object, step);\n        var valueSideChannel = getSideChannel();\n        valueSideChannel.set(sentinel, sideChannel);\n        pushToArray(values, stringify(\n            value,\n            keyPrefix,\n            generateArrayPrefix,\n            commaRoundTrip,\n            allowEmptyArrays,\n            strictNullHandling,\n            skipNulls,\n            encodeDotInKeys,\n            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            format,\n            formatter,\n            encodeValuesOnly,\n            charset,\n            valueSideChannel\n        ));\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    var arrayFormat;\n    if (opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = defaults.arrayFormat;\n    }\n\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];\n    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    var sideChannel = getSideChannel();\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n        var value = obj[key];\n\n        if (options.skipNulls && value === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            value,\n            key,\n            generateArrayPrefix,\n            commaRoundTrip,\n            options.allowEmptyArrays,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encodeDotInKeys,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.format,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset,\n            sideChannel\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n\n},{\"./formats\":109,\"./utils\":113,\"side-channel\":121}],113:[function(require,module,exports){\n'use strict';\n\nvar formats = require('./formats');\nvar getSideChannel = require('side-channel');\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\n// Track objects created from arrayLimit overflow using side-channel\n// Stores the current max numeric index for O(1) lookup\nvar overflowChannel = getSideChannel();\n\nvar markOverflow = function markOverflow(obj, maxIndex) {\n    overflowChannel.set(obj, maxIndex);\n    return obj;\n};\n\nvar isOverflow = function isOverflow(obj) {\n    return overflowChannel.has(obj);\n};\n\nvar getMaxIndex = function getMaxIndex(obj) {\n    return overflowChannel.get(obj);\n};\n\nvar setMaxIndex = function setMaxIndex(obj, maxIndex) {\n    overflowChannel.set(obj, maxIndex);\n};\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array[array.length] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted[compacted.length] = obj[j];\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? { __proto__: null } : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object' && typeof source !== 'function') {\n        if (isArray(target)) {\n            var nextIndex = target.length;\n            if (options && typeof options.arrayLimit === 'number' && nextIndex > options.arrayLimit) {\n                return markOverflow(arrayToObject(target.concat(source), options), nextIndex);\n            }\n            target[nextIndex] = source;\n        } else if (target && typeof target === 'object') {\n            if (isOverflow(target)) {\n                // Add at next numeric index for overflow objects\n                var newIndex = getMaxIndex(target) + 1;\n                target[newIndex] = source;\n                setMaxIndex(target, newIndex);\n            } else if (options && options.strictMerge) {\n                return [target, source];\n            } else if (\n                (options && (options.plainObjects || options.allowPrototypes))\n                || !has.call(Object.prototype, source)\n            ) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        if (isOverflow(source)) {\n            // Create new object with target at 0, source values shifted by 1\n            var sourceKeys = Object.keys(source);\n            var result = options && options.plainObjects\n                ? { __proto__: null, 0: target }\n                : { 0: target };\n            for (var m = 0; m < sourceKeys.length; m++) {\n                var oldKey = parseInt(sourceKeys[m], 10);\n                result[oldKey + 1] = source[sourceKeys[m]];\n            }\n            return markOverflow(result, getMaxIndex(source) + 1);\n        }\n        var combined = [target].concat(source);\n        if (options && typeof options.arrayLimit === 'number' && combined.length > options.arrayLimit) {\n            return markOverflow(arrayToObject(combined, options), combined.length - 1);\n        }\n        return combined;\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target[target.length] = item;\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n\n        if (isOverflow(source) && !isOverflow(acc)) {\n            markOverflow(acc, getMaxIndex(source));\n        }\n        if (isOverflow(acc)) {\n            var keyNum = parseInt(key, 10);\n            if (String(keyNum) === key && keyNum >= 0 && keyNum > getMaxIndex(acc)) {\n                setMaxIndex(acc, keyNum);\n            }\n        }\n\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, defaultDecoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar limit = 1024;\n\n/* eslint operator-linebreak: [2, \"before\"] */\n\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var j = 0; j < string.length; j += limit) {\n        var segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        var arr = [];\n\n        for (var i = 0; i < segment.length; ++i) {\n            var c = segment.charCodeAt(i);\n            if (\n                c === 0x2D // -\n                || c === 0x2E // .\n                || c === 0x5F // _\n                || c === 0x7E // ~\n                || (c >= 0x30 && c <= 0x39) // 0-9\n                || (c >= 0x41 && c <= 0x5A) // a-z\n                || (c >= 0x61 && c <= 0x7A) // A-Z\n                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n\n            if (c < 0x80) {\n                arr[arr.length] = hexTable[c];\n                continue;\n            }\n\n            if (c < 0x800) {\n                arr[arr.length] = hexTable[0xC0 | (c >> 6)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            if (c < 0xD800 || c >= 0xE000) {\n                arr[arr.length] = hexTable[0xE0 | (c >> 12)]\n                    + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            i += 1;\n            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));\n\n            arr[arr.length] = hexTable[0xF0 | (c >> 18)]\n                + hexTable[0x80 | ((c >> 12) & 0x3F)]\n                + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                + hexTable[0x80 | (c & 0x3F)];\n        }\n\n        out += arr.join('');\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue[queue.length] = { obj: obj, prop: key };\n                refs[refs.length] = val;\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b, arrayLimit, plainObjects) {\n    // If 'a' is already an overflow object, add to it\n    if (isOverflow(a)) {\n        var newIndex = getMaxIndex(a) + 1;\n        a[newIndex] = b;\n        setMaxIndex(a, newIndex);\n        return a;\n    }\n\n    var result = [].concat(a, b);\n    if (result.length > arrayLimit) {\n        return markOverflow(arrayToObject(result, { plainObjects: plainObjects }), result.length - 1);\n    }\n    return result;\n};\n\nvar maybeMap = function maybeMap(val, fn) {\n    if (isArray(val)) {\n        var mapped = [];\n        for (var i = 0; i < val.length; i += 1) {\n            mapped[mapped.length] = fn(val[i]);\n        }\n        return mapped;\n    }\n    return fn(val);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isOverflow: isOverflow,\n    isRegExp: isRegExp,\n    markOverflow: markOverflow,\n    maybeMap: maybeMap,\n    merge: merge\n};\n\n},{\"./formats\":109,\"side-channel\":121}],114:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],115:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],116:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":114,\"./encode\":115}],117:[function(require,module,exports){\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":20}],118:[function(require,module,exports){\n'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n\n},{\"es-errors/type\":47,\"object-inspect\":101}],119:[function(require,module,exports){\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\nvar $Map = GetIntrinsic('%Map%', true);\n\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */\nvar $mapGet = callBound('Map.prototype.get', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */\nvar $mapSet = callBound('Map.prototype.set', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapHas = callBound('Map.prototype.has', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapDelete = callBound('Map.prototype.delete', true);\n/** @type {<K, V>(thisArg: Map<K, V>) => number} */\nvar $mapSize = callBound('Map.prototype.size', true);\n\n/** @type {import('.')} */\nmodule.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {\n\t/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {Map<K, V> | undefined} */ var $m;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tif ($m) {\n\t\t\t\tvar result = $mapDelete($m, key);\n\t\t\t\tif ($mapSize($m) === 0) {\n\t\t\t\t\t$m = void undefined;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($m) {\n\t\t\t\treturn $mapGet($m, key);\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($m) {\n\t\t\t\treturn $mapHas($m, key);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$m) {\n\t\t\t\t// @ts-expect-error TS can't handle narrowing a variable inside a closure\n\t\t\t\t$m = new $Map();\n\t\t\t}\n\t\t\t$mapSet($m, key, value);\n\t\t}\n\t};\n\n\t// @ts-expect-error TODO: figure out why TS is erroring here\n\treturn channel;\n};\n\n},{\"call-bound\":30,\"es-errors/type\":47,\"get-intrinsic\":69,\"object-inspect\":101}],120:[function(require,module,exports){\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\nvar getSideChannelMap = require('side-channel-map');\n\nvar $TypeError = require('es-errors/type');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapDelete = callBound('WeakMap.prototype.delete', true);\n\n/** @type {import('.')} */\nmodule.exports = $WeakMap\n\t? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {\n\t\t/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */\n\t\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t\t/** @type {WeakMap<K & object, V> | undefined} */ var $wm;\n\t\t/** @type {Channel | undefined} */ var $m;\n\n\t\t/** @type {Channel} */\n\t\tvar channel = {\n\t\t\tassert: function (key) {\n\t\t\t\tif (!channel.has(key)) {\n\t\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t\t}\n\t\t\t},\n\t\t\t'delete': function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapDelete($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $m['delete'](key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tget: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $m && $m.get(key);\n\t\t\t},\n\t\t\thas: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!$m && $m.has(key);\n\t\t\t},\n\t\t\tset: function (key, value) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif (!$wm) {\n\t\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t\t}\n\t\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif (!$m) {\n\t\t\t\t\t\t$m = getSideChannelMap();\n\t\t\t\t\t}\n\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\t/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// @ts-expect-error TODO: figure out why this is erroring\n\t\treturn channel;\n\t}\n\t: getSideChannelMap;\n\n},{\"call-bound\":30,\"es-errors/type\":47,\"get-intrinsic\":69,\"object-inspect\":101,\"side-channel-map\":119}],121:[function(require,module,exports){\n'use strict';\n\nvar $TypeError = require('es-errors/type');\nvar inspect = require('object-inspect');\nvar getSideChannelList = require('side-channel-list');\nvar getSideChannelMap = require('side-channel-map');\nvar getSideChannelWeakMap = require('side-channel-weakmap');\n\nvar makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannel() {\n\t/** @typedef {ReturnType<typeof getSideChannel>} Channel */\n\n\t/** @type {Channel | undefined} */ var $channelData;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\treturn !!$channelData && $channelData['delete'](key);\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn $channelData && $channelData.get(key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn !!$channelData && $channelData.has(key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$channelData) {\n\t\t\t\t$channelData = makeChannel();\n\t\t\t}\n\n\t\t\t$channelData.set(key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n\n},{\"es-errors/type\":47,\"object-inspect\":101,\"side-channel-list\":118,\"side-channel-map\":119,\"side-channel-weakmap\":120}],122:[function(require,module,exports){\n(function (Buffer){(function (){\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":20}],123:[function(require,module,exports){\n(function (Buffer){(function (){\n/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":20,\"decompress-response\":18,\"http\":124,\"https\":78,\"once\":102,\"querystring\":116,\"simple-concat\":122,\"url\":145}],124:[function(require,module,exports){\n(function (global){(function (){\nvar ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./lib/request\":126,\"./lib/response\":127,\"builtin-status-codes\":21,\"url\":145,\"xtend\":148}],125:[function(require,module,exports){\n(function (global){(function (){\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],126:[function(require,module,exports){\n(function (process,global,Buffer){(function (){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":125,\"./response\":127,\"_process\":107,\"buffer\":20,\"inherits\":80,\"readable-stream\":142}],127:[function(require,module,exports){\n(function (process,global,Buffer){(function (){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":125,\"_process\":107,\"buffer\":20,\"inherits\":80,\"readable-stream\":142}],128:[function(require,module,exports){\n'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n},{}],129:[function(require,module,exports){\n(function (process){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n}).call(this)}).call(this,require('_process'))\n\n},{\"./_stream_readable\":131,\"./_stream_writable\":133,\"_process\":107,\"inherits\":80}],130:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":132,\"inherits\":80}],131:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":128,\"./_stream_duplex\":129,\"./internal/streams/async_iterator\":134,\"./internal/streams/buffer_list\":135,\"./internal/streams/destroy\":136,\"./internal/streams/from\":138,\"./internal/streams/state\":140,\"./internal/streams/stream\":141,\"_process\":107,\"buffer\":20,\"events\":50,\"inherits\":80,\"string_decoder/\":143,\"util\":18}],132:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n},{\"../errors\":128,\"./_stream_duplex\":129,\"inherits\":80}],133:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":128,\"./_stream_duplex\":129,\"./internal/streams/destroy\":136,\"./internal/streams/state\":140,\"./internal/streams/stream\":141,\"_process\":107,\"buffer\":20,\"inherits\":80,\"util-deprecate\":146}],134:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;\n}).call(this)}).call(this,require('_process'))\n\n},{\"./end-of-stream\":137,\"_process\":107}],135:[function(require,module,exports){\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();\n},{\"buffer\":20,\"util\":18}],136:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":107}],137:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;\n},{\"../../../errors\":128}],138:[function(require,module,exports){\nmodule.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n},{}],139:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;\n},{\"../../../errors\":128,\"./end-of-stream\":137}],140:[function(require,module,exports){\n'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n},{\"../../../errors\":128}],141:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":50}],142:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n\n},{\"./lib/_stream_duplex.js\":129,\"./lib/_stream_passthrough.js\":130,\"./lib/_stream_readable.js\":131,\"./lib/_stream_transform.js\":132,\"./lib/_stream_writable.js\":133,\"./lib/internal/streams/end-of-stream.js\":137,\"./lib/internal/streams/pipeline.js\":139}],143:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":117}],144:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":107,\"timers\":144}],145:[function(require,module,exports){\n/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n'use strict';\n\nvar punycode = require('punycode/');\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n/*\n * define these here so at least they only have to be\n * compiled once on the first module load.\n */\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/,\n\n  /*\n   * RFC 2396: characters reserved for delimiting URLs.\n   * We actually just auto-escape these.\n   */\n  delims = [\n    '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'\n  ],\n\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [\n    '{', '}', '|', '\\\\', '^', '`'\n  ].concat(delims),\n\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  /*\n   * Characters that are never ever allowed in a hostname.\n   * Note that any invalid chars are also handled, but these\n   * are the ones that are *expected* to be seen, so we fast-path\n   * them.\n   */\n  nonHostChars = [\n    '%', '/', '?', ';', '#'\n  ].concat(autoEscape),\n  hostEndingChars = [\n    '/', '?', '#'\n  ],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = require('qs');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === 'object' && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  /*\n   * Copy chrome, IE, opera backslash-handling behavior.\n   * Back slashes before the query string get converted to forward slashes\n   * See: https://code.google.com/p/chromium/issues/detail?id=25916\n   */\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  /*\n   * trim before proceeding.\n   * This is to support parse stuff like \"  http://foo.com  \\n\"\n   */\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  /*\n   * figure out if it's got a host\n   * user@server is *always* interpreted as a hostname, and url\n   * resolution will treat //foo/bar as host=foo,path=bar because that's\n   * how the browser resolves relative URLs.\n   */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\n\n    /*\n     * there's a hostname.\n     * the first instance of /, ?, ;, or # ends the host.\n     *\n     * If there is an @ in the hostname, then non-host chars *are* allowed\n     * to the left of the last @ sign, unless some host-ending character\n     * comes *before* the @-sign.\n     * URLs are obnoxious.\n     *\n     * ex:\n     * http://a@b@c/ => user:a@b host:c\n     * http://a@b?@c => user:a host:c path:/?@c\n     */\n\n    /*\n     * v0.12 TODO(isaacs): This is not quite how Chrome does things.\n     * Review our test case against browsers more comprehensively.\n     */\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n\n    /*\n     * at this point, either we have an explicit point where the\n     * auth portion cannot go past, or the last @ char is the decider.\n     */\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      /*\n       * atSign must be in auth portion.\n       * http://a@b/c@d => host:b auth:a path:/c@d\n       */\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    /*\n     * Now we have a portion which is definitely the auth.\n     * Pull that off.\n     */\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    /*\n     * we've indicated that there is a hostname,\n     * so even if it's empty, it has to be present.\n     */\n    this.hostname = this.hostname || '';\n\n    /*\n     * if hostname begins with [ and ends with ]\n     * assume that it's an IPv6 address.\n     */\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              /*\n               * we replace non-ASCII char with a temporary placeholder\n               * we need this to make sure size of hostname is not\n               * broken by replacing non-ASCII by nothing\n               */\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      /*\n       * IDNA Support: Returns a punycoded representation of \"domain\".\n       * It only converts parts of the domain name that\n       * have non-ASCII characters, i.e. it doesn't matter if\n       * you call it with a domain that already is ASCII-only.\n       */\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    /*\n     * strip [ and ] from the hostname\n     * the host field still retains them, though\n     */\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  /*\n   * now rest is set to the post-host stuff.\n   * chop off any delim chars.\n   */\n  if (!unsafeProtocol[lowerProto]) {\n\n    /*\n     * First, make 100% sure that any \"autoEscape\" chars get\n     * escaped, even if encodeURIComponent doesn't think they\n     * need to be.\n     */\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  /*\n   * ensure it's an object, and not a string url.\n   * If it's an obj, this is a no-op.\n   * this way, you can call url_format() on strings\n   * to clean up potentially wonky urls.\n   */\n  if (typeof obj === 'string') { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query, {\n      arrayFormat: 'repeat',\n      addQueryPrefix: false\n    });\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  /*\n   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   * unless they had them to begin with.\n   */\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  /*\n   * hash is always overridden, no matter what.\n   * even href=\"\" will remove it.\n   */\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.pathname = '/';\n      result.path = result.pathname;\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    /*\n     * if it's a known url protocol, then changing\n     * the protocol does weird things\n     * first, if it's not file:, then we MUST have a host,\n     * and if there was a path\n     * to begin with, then we MUST have a path.\n     * if it is file:, then the host is dropped,\n     * because that's known to be hostless.\n     * anything else is assumed to be absolute.\n     */\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())) { }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  /*\n   * if the url is a non-slashed url, then relative\n   * links like ../.. should be able\n   * to crawl up to the hostname, as well.  This is strange.\n   * result.protocol has already been set by now.\n   * Later on, put the first path part into the host field.\n   */\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    /*\n     * it's relative\n     * throw away the existing file, and take the new path instead.\n     */\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search != null) {\n    /*\n     * just pull out the search.\n     * like href='?foo'.\n     * Put this after the other two cases because it simplifies the booleans\n     */\n    if (psychotic) {\n      result.host = srcPath.shift();\n      result.hostname = result.host;\n      /*\n       * occationaly the auth can get stuck only in host\n       * this especially happens in cases like\n       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n       */\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.hostname = authInHost.shift();\n        result.host = result.hostname;\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    /*\n     * no path at all.  easy.\n     * we've already handled the other stuff above.\n     */\n    result.pathname = null;\n    // to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  /*\n   * if a url ENDs in . or .., then it must get a trailing slash.\n   * however, if it ends in anything else non-slashy,\n   * then it must NOT get a trailing slash.\n   */\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  /*\n   * strip single dots, resolve double dots to parent dir\n   * if the path tries to go above the root, `up` ends up > 0\n   */\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    result.host = result.hostname;\n    /*\n     * occationaly the auth can get stuck only in host\n     * this especially happens in cases like\n     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n     */\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.hostname = authInHost.shift();\n      result.host = result.hostname;\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (srcPath.length > 0) {\n    result.pathname = srcPath.join('/');\n  } else {\n    result.pathname = null;\n    result.path = null;\n  }\n\n  // to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\n},{\"punycode/\":108,\"qs\":110}],146:[function(require,module,exports){\n(function (global){(function (){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],147:[function(require,module,exports){\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n},{}],148:[function(require,module,exports){\nmodule.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],149:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"fable\",\n  \"version\": \"3.1.58\",\n  \"description\": \"A service dependency injection, configuration and logging library.\",\n  \"main\": \"source/Fable.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"npx quack build\",\n    \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t fable-image:local\",\n    \"docker-dev-run\": \"docker run -it -d --name fable-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" fable-image:local\",\n    \"docker-dev-shell\": \"docker exec -it fable-dev /bin/bash\",\n    \"tests\": \"./node_modules/mocha/bin/_mocha -u tdd --exit -R spec --grep\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"browser\": {\n    \"./source/service/Fable-Service-EnvironmentData.js\": \"./source/service/Fable-Service-EnvironmentData-Web.js\",\n    \"./source/service/Fable-Service-FilePersistence.js\": \"./source/service/Fable-Service-FilePersistence-Web.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable.git\"\n  },\n  \"keywords\": [\n    \"entity\",\n    \"behavior\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable/issues\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"async.eachlimit\": \"^0.5.2\",\n    \"async.waterfall\": \"^0.5.2\",\n    \"big.js\": \"^7.0.1\",\n    \"cachetrax\": \"^1.0.5\",\n    \"cookie\": \"^1.1.1\",\n    \"data-arithmatic\": \"^1.0.7\",\n    \"dayjs\": \"^1.11.19\",\n    \"fable-log\": \"^3.0.17\",\n    \"fable-serviceproviderbase\": \"^3.0.18\",\n    \"fable-settings\": \"^3.0.15\",\n    \"fable-uuid\": \"^3.0.12\",\n    \"manyfest\": \"^1.0.46\",\n    \"simple-get\": \"^4.0.1\"\n  }\n}\n\n},{}],150:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @author <steven@velozo.com>\n*/\n// Pre-init services\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libPackage = require('../package.json');\n\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass Fable extends libFableServiceBase.CoreServiceProviderBase\n{\n\tconstructor(pSettings)\n\t{\n\t\tsuper(pSettings);\n\n\t\t// Initialization Phase 0: Set up the lowest level state (fable is a utility service manager at heart)\n\t\tthis.serviceType = 'ServiceManager';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\t// An array of the types of services available\n\t\tthis.serviceTypes = [];\n\t\t// A map of instantiated services\n\t\tthis.servicesMap = {};\n\t\t// A map of the default instantiated service by type\n\t\tthis.services = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\n\t\t// If we need extra service initialization capabilities\n\t\tthis.extraServiceInitialization = false;\n\n\t\t// Set how noisy the system is about signaling complexity\n\t\tthis.LogNoisiness = 0;\n\n\t\t// Initialization Phase 1: Set up the core utility services\n\t\t// These are things like power, water, and sewage.  They are required for fable to run (e.g. logging, settings, etc)\n\n\t\t// Instantiate the default Settings Manager\n\t\tthis.SettingsManager = new libFableSettings(pSettings);\n\t\tthis.SettingsManager = this.SettingsManager;\n\t\t// Instantiate the UUID generator\n\t\tthis.UUID = new libFableUUID(this.SettingsManager.settings);\n\t\t// Instantiate the logging system\n\t\tthis.Logging = new libFableLog(this.SettingsManager.settings);\n\t\tthis.Logging.initialize();\n\n\t\t// Initialization Phase 1.5: Instantiate the service manager\n\t\t// This is the start actual bootstrapping point for fable.\n\t\t// For consistency fable is treated as a service.\n\t\tthis.ServiceManager = this;\n\t\t// TODO: Remove this when Orator and meadow-endpoints are shifted to this new pattern\n\t\tthis.serviceManager = this;\n\t\t// END TODO\n\t\tthis.connectFable(this);\n\t\t// --> Bootstrapping of fable into the Service Manager is complete\n\n\t\t// Initialization Phase 2: Map in the default services.\n\t\t// They will then be available in the Default service provider set as well.\n\t\tthis.connectPreinitServiceProviderInstance(this.UUID);\n\t\tthis.connectPreinitServiceProviderInstance(this.Logging);\n\t\tthis.connectPreinitServiceProviderInstance(this.SettingsManager);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.addAndInstantiateServiceType('EnvironmentData', require('./services/Fable-Service-EnvironmentData.js'));\n\t\tthis.addServiceType('Template', require('./services/Fable-Service-Template.js'));\n\t\tthis.addServiceType('MetaTemplate', require('./services/Fable-Service-MetaTemplate.js'));\n\t\tthis.addServiceType('Anticipate', require('./services/Fable-Service-Anticipate.js'));\n\t\tthis.addAndInstantiateServiceType('Dates', require('./services/Fable-Service-DateManipulation.js'));\n\t\tthis.addAndInstantiateServiceType('DataFormat', require('./services/Fable-Service-DataFormat.js'));\n\t\tthis.addAndInstantiateServiceType('DataGeneration', require('./services/Fable-Service-DataGeneration.js'));\n\t\tthis.addAndInstantiateServiceType('Utility', require('./services/Fable-Service-Utility.js'));\n\t\tthis.addAndInstantiateServiceType('Logic', require('./services/Fable-Service-Logic.js'));\n\t\tthis.addAndInstantiateServiceType('Math', require('./services/Fable-Service-Math.js'));\n\t\tthis.addServiceType('ExpressionParser', require('./services/Fable-Service-ExpressionParser.js'));\n\t\tthis.addServiceType('RestClient', require('./services/Fable-Service-RestClient.js'));\n\t\tthis.addServiceType('Manifest', require('manyfest'));\n\t\tthis.addServiceType('ObjectCache', require('cachetrax'));\n\t\tthis.addAndInstantiateServiceType('ProgressTime', require('./services/Fable-Service-ProgressTime.js'));\n\t\tthis.addServiceType('ProgressTrackerSet', require('./services/Fable-Service-ProgressTrackerSet.js'));\n\t\tthis.addServiceType('Operation', require('./services/Fable-Service-Operation.js'));\n\t\tthis.addServiceType('CSVParser', require('./services/Fable-Service-CSVParser.js'));\n\t\tthis.addServiceType('FilePersistence', require('./services/Fable-Service-FilePersistence.js'));\n\t}\n\n\t/* State Accessors */\n\tget isFable()\n\t{\n\t\treturn true;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.SettingsManager.settings;\n\t}\n\n\tget settingsManager()\n\t{\n\t\treturn this.SettingsManager;\n\t}\n\n\t// For backwards compatibility\n\tgetUUID()\n\t{\n\t\treturn this.UUID.getUUID();\n\t}\n\n\tnewAnticipate()\n\t{\n\t\treturn this.instantiateServiceProviderWithoutRegistration('Anticipate');\n\t}\n\n\tnewManyfest(pManifestDefinition)\n\t{\n\t\treturn this.instantiateServiceProviderWithoutRegistration('Manifest', pManifestDefinition);\n\t}\n\n\t/* Service Manager Methods */\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\tif (pServiceType in this.servicesMap)\n\t\t{\n\t\t\t//this.log.warn(`Adding a service type [${pServiceType}] that already exists.  This will change the default class prototype for this service.`);\n\t\t\t// This broke command-line utilities that overrode services and wanted to strictly control log output\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the container for instantiated services to go in\n\t\t\tthis.servicesMap[pServiceType] = {};\n\n\t\t\t// Add the type to the list of types\n\t\t\tthis.serviceTypes.push(pServiceType);\n\t\t}\n\n\t\t// Using the static member of the class is a much more reliable way to check if it is a service class than instanceof\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.isFableService))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.log.error(`Attempted to add service type [${pServiceType}] with an invalid class.  Using base service class, which will not crash but won't provide meaningful services.`);\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\n\t\treturn this.serviceClasses[pServiceType];\n\t}\n\n\taddServiceTypeIfNotExists(pServiceType, pServiceClass)\n\t{\n\t\tif (!(pServiceType in this.servicesMap))\n\t\t{\n\t\t\treturn this.addServiceType(pServiceType, pServiceClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.serviceClasses[pServiceType];\n\t\t}\n\t}\n\n\t// This is for the services that are meant to run mostly single-instance so need a default at initialization\n\taddAndInstantiateServiceType(pServiceType, pServiceClass)\n\t{\n\t\tthis.addServiceType(pServiceType, pServiceClass);\n\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t}\n\n\taddAndInstantiateServiceTypeIfNotExists(pServiceType, pServiceClass)\n\t{\n\t\tthis.addServiceTypeIfNotExists(pServiceType, pServiceClass);\n\n\t\tif ((!(pServiceType in this.servicesMap)) || (!(pServiceType in this.fable)))\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this[pServiceType];\n\t\t}\n\t}\n\n\taddAndInstantiateSingletonService(pServiceType, pOptions, pServiceClass)\n\t{\n\t\tthis.addServiceTypeIfNotExists(pServiceType, pServiceClass);\n\n\t\tif ((!(pServiceType in this.servicesMap)) || (!(pServiceType in this.fable)))\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this[pServiceType];\n\t\t}\n\t}\n\n\t// Some services expect to be overloaded / customized class.\n\tinstantiateServiceProviderFromPrototype(pServiceType, pOptions, pCustomServiceHash, pServicePrototype)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new pServicePrototype(this, pOptions, pCustomServiceHash);\n\n\t\tif (this.extraServiceInitialization)\n\t\t{\n\t\t\ttmpService = this.extraServiceInitialization(tmpService);\n\t\t}\n\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(pServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(pServiceType, tmpService.Hash)\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(pServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(pServiceType, tmpService.Hash)\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\tinstantiateServiceProviderIfNotExists(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\tif (pServiceType in this.services)\n\t\t{\n\t\t\treturn this.services[pServiceType];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash);\n\t\t}\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this, pOptions, pCustomServiceHash);\n\t\tif (this.extraServiceInitialization)\n\t\t{\n\t\t\ttmpService = this.extraServiceInitialization(tmpService);\n\t\t}\n\t\treturn tmpService;\n\t}\n\n\t// Connect an initialized service provider that came before Fable was initialized\n\tconnectPreinitServiceProviderInstance(pServiceInstance)\n\t{\n\t\tlet tmpServiceType = pServiceInstance.serviceType;\n\t\tlet tmpServiceHash = pServiceInstance.Hash;\n\n\t\t// The service should already be instantiated, so just connect it to fable\n\t\tpServiceInstance.connectFable(this);\n\n\t\t// Add the service type to the map if it isn't there yet\n\t\tif (!(tmpServiceType in this.servicesMap))\n\t\t{\n\t\t\t// If the core service hasn't registered itself yet, create the service container for it.\n\t\t\t// This means you couldn't register another with this type unless it was later registered with a constructor class.\n\t\t\tthis.servicesMap[tmpServiceType] = {};\n\t\t}\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[tmpServiceType][tmpServiceHash] = pServiceInstance;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(tmpServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(tmpServiceType, tmpServiceHash, false);\n\t\t}\n\n\t\treturn pServiceInstance;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash, pOverwriteService)\n\t{\n\t\t// Overwrite services by default, unless told not to\n\t\tlet tmpOverwriteService = (typeof(pOverwriteService) === 'undefined') ? true : pOverwriteService;\n\t\t// Make sure the service exists\n\t\tif (pServiceHash in this.servicesMap[pServiceType])\n\t\t{\n\t\t\tif (!(pServiceType in this) || tmpOverwriteService)\n\t\t\t{\n\t\t\t\tthis[pServiceType] = this.servicesMap[pServiceType][pServiceHash];\n\t\t\t}\n\t\t\tif (!(pServiceType in this.services) || tmpOverwriteService)\n\t\t\t{\n\t\t\t\tthis.services[pServiceType] = this.servicesMap[pServiceType][pServiceHash];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate a safe string to use in filenames for a date.  Useful for log file uniqueness and temporary outputs.\n\t *\n\t * @static\n\t * @param {Date} pDate - An optional javascript Date object to generate a datestamp for.\n\t * @returns {string} - A string formatted as YYYY-MM-DD-HH-MM-SS\n\t */\n\tstatic generateFileNameDateStamp(pDate)\n\t{\n\t\tconst tmpDate = pDate || new Date();\n\t\tconst tmpYear = tmpDate.getFullYear();\n\t\tconst tmpMonth = String(tmpDate.getMonth() + 1).padStart(2, '0');\n\t\tconst tmpDay = String(tmpDate.getDate()).padStart(2, '0');\n\t\tconst tmpHour = String(tmpDate.getHours()).padStart(2, '0');\n\t\tconst tmpMinute = String(tmpDate.getMinutes()).padStart(2, '0');\n\t\tconst tmpSecond = String(tmpDate.getSeconds()).padStart(2, '0');\n\t\treturn `${tmpYear}-${tmpMonth}-${tmpDay}-${tmpHour}-${tmpMinute}-${tmpSecond}`;\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceBase;\nmodule.exports.CoreServiceProviderBase = libFableServiceBase.CoreServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n\n},{\"../package.json\":149,\"./services/Fable-Service-Anticipate.js\":151,\"./services/Fable-Service-CSVParser.js\":152,\"./services/Fable-Service-DataFormat.js\":153,\"./services/Fable-Service-DataGeneration.js\":155,\"./services/Fable-Service-DateManipulation.js\":156,\"./services/Fable-Service-EnvironmentData.js\":157,\"./services/Fable-Service-ExpressionParser.js\":158,\"./services/Fable-Service-FilePersistence.js\":169,\"./services/Fable-Service-Logic.js\":170,\"./services/Fable-Service-Math.js\":171,\"./services/Fable-Service-MetaTemplate.js\":172,\"./services/Fable-Service-Operation.js\":176,\"./services/Fable-Service-ProgressTime.js\":177,\"./services/Fable-Service-ProgressTrackerSet.js\":179,\"./services/Fable-Service-RestClient.js\":180,\"./services/Fable-Service-Template.js\":181,\"./services/Fable-Service-Utility.js\":182,\"cachetrax\":22,\"fable-log\":57,\"fable-serviceproviderbase\":59,\"fable-settings\":63,\"fable-uuid\":66,\"manyfest\":92}],151:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceAnticipate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'AsyncAnticipate';\n\n\t\t// The queue of operations waiting to run.\n\t\tthis.operationQueue = [];\n\t\tthis.erroredOperations = [];\n\n\t\tthis.executingOperationCount = 0;\n\t\tthis.completedOperationCount = 0;\n\n\t\tthis.callDepth = 0;\n\n\t\tthis.maxOperations = 1;\n\n\t\tthis.lastError = undefined;\n\t\tthis.waitingFunctions = [];\n\t}\n\n\tcheckQueue()\n\t{\n\t\t// This could be combined with the last else if stanza but the logic for errors and non-errors would be blended and more complex to follow so keeping it unrolled.\n\t\tif (this.lastError)\n\t\t{\n\t\t\t// If there are no operations left, and we have waiting functions, call them.\n\t\t\tfor (let i = 0; i < this.waitingFunctions.length; i++)\n\t\t\t{\n\t\t\t\t//this.log.trace('Calling waiting function.')\n\t\t\t\tthis.waitingFunctions[i](this.lastError);\n\t\t\t}\n\t\t\t// Reset our state\n\t\t\tthis.lastError = undefined;\n\t\t\tthis.waitingFunctions = [];\n\t\t}\n\t\t// This checks to see if we need to start any operations.\n\t\telse if (this.operationQueue.length > 0 && this.executingOperationCount < this.maxOperations)\n\t\t{\n\t\t\tlet tmpOperation = this.operationQueue.shift();\n\t\t\tthis.executingOperationCount += 1;\n\t\t\ttmpOperation(this.buildAnticipatorCallback());\n\t\t}\n\t\telse if (this.waitingFunctions.length > 0 && this.executingOperationCount < 1)\n\t\t{\n\t\t\t// If there are no operations left, and we have waiting functions, call them.\n\t\t\tfor (let i = 0; i < this.waitingFunctions.length; i++)\n\t\t\t{\n\t\t\t\t//this.log.trace('Calling waiting function.')\n\t\t\t\tthis.waitingFunctions[i](this.lastError);\n\t\t\t}\n\t\t\t// Reset our state\n\t\t\tthis.lastError = undefined;\n\t\t\tthis.waitingFunctions = [];\n\t\t}\n\t}\n\n\t// Expects a function fAsynchronousFunction(fCallback)\n\tanticipate(fAsynchronousFunction)\n\t{\n\t\t//this.log.trace('Adding a function...')\n\t\tthis.operationQueue.push(fAsynchronousFunction);\n\t\tthis.checkQueue();\n\t}\n\n\tbuildAnticipatorCallback()\n\t{\n\t\t// This uses closure-scoped state to track the callback state\n\t\tlet tmpCallbackState = (\n\t\t\t{\n\t\t\t\tCalled: false,\n\t\t\t\tError: undefined,\n\t\t\t\tOperationSet: this\n\t\t\t});\n\t\treturn hoistedCallback.bind(this);\n\t\tfunction hoistedCallback(pError)\n\t\t{\n\t\t\tif (tmpCallbackState.Called)\n\t\t\t{\n\t\t\t\t// If they call the callback twice, throw an error\n\t\t\t\tthrow new Error(\"Anticipation async callback called twice...\");\n\t\t\t}\n\t\t\ttmpCallbackState.Called = true;\n\t\t\tthis.lastError = pError;\n\n\t\t\ttmpCallbackState.OperationSet.executingOperationCount -= 1;\n\t\t\ttmpCallbackState.OperationSet.completedOperationCount += 1;\n\n\t\t\ttmpCallbackState.OperationSet.callDepth++;\n\n\t\t\t// TODO: Figure out a better pattern for chaining templates so the call stack doesn't get abused.\n\t\t\tif (tmpCallbackState.OperationSet.callDepth > 400)\n\t\t\t{\n\t\t\t\ttmpCallbackState.OperationSet.callDepth = 0;\n\t\t\t\tsetTimeout(tmpCallbackState.OperationSet.checkQueue.bind(this), 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpCallbackState.OperationSet.checkQueue();\n\t\t\t}\n\t\t}\n\t}\n\n\twait(fCallback)\n\t{\n\t\tthis.waitingFunctions.push(fCallback);\n\t\tthis.checkQueue();\n\t}\n}\n\nmodule.exports = FableServiceAnticipate;\n},{\"fable-serviceproviderbase\":59}],152:[function(require,module,exports){\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Parsing CSVs.  Why?  Because it's a thing that needs to be done.\n*\n* 1. And the other node CSV parsers had issues with the really messy files we had.\n*\n*\n* 2. None of the CSV parsers dealt with and multi-line quoted string columns\n*\twhich are apparently a-ok according to the official spec.\n* Plus a lot of them are asynchronous because apparently that's the best way to\n* do anything; unfortunately some files have a sequence issue with that.\n*\n* @class CSVParser\n*/\nclass CSVParser extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'CSVParser';\n\n\t\tthis.Header = [];\n\t\tthis.HeaderFieldNames = [];\n\n\t\tthis.Delimiter = ',';\n\t\tthis.QuoteCharacter = '\"';\n\n\t\tthis.CleanCharacters = ['\\r'];\n\n\t\tthis.HeaderLineIndex = 0;\n\t\tthis.HasHeader = true;\n\t\tthis.HasSetHeader = false;\n\t\tthis.EmitHeader = false;\n\n\t\tthis.EmitJSON = true;\n\n\t\tthis.EscapedQuoteString = '&quot;';\n\n\t\t// Current Line Parsing State\n\t\tthis.CurrentLine = '';\n\t\tthis.CurrentRecord = [];\n\n\t\tthis.InQuote = false;\n\t\tthis.InEscapedQuote = false;\n\n\t\tthis.LinesParsed = 0;\n\t\tthis.RowsEmitted = 0;\n\t}\n\n\tmarshalRowToJSON(pRowArray)\n\t{\n\t\tif (!Array.isArray(pRowArray))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = this.HeaderFieldNames.length; i < pRowArray.length; i++)\n\t\t{\n\t\t\tthis.HeaderFieldNames[i] = `${i}`;\n\t\t}\n\n\t\tlet tmpObject = {};\n\n\t\tfor (let i = 0; i < pRowArray.length; i++)\n\t\t{\n\t\t\ttmpObject[this.HeaderFieldNames[i]] = pRowArray[i];\n\t\t}\n\n\t\treturn tmpObject;\n\t}\n\n\t// Set the header data, for use in marshalling to JSON.\n\tsetHeader (pHeaderArray)\n\t{\n\t\tthis.Header = pHeaderArray;\n\n\t\tfor (let i = 0; i < this.Header.length; i++)\n\t\t{\n\t\t\tif (typeof(this.Header[i]) == 'undefined')\n\t\t\t{\n\t\t\t\tthis.HeaderFieldNames[i] = `${i}`;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.HeaderFieldNames[i] = this.Header[i].toString().trim();\n\t\t\t}\n\t\t}\n\t}\n\n\tresetRowState()\n\t{\n\t\tthis.CurrentRecord = [];\n\t}\n\n\tpushLine()\n\t{\n\t\tfor (let i = 0; i < this.CleanCharacters.length; i++)\n\t\t{\n\t\t\tthis.CurrentLine = this.CurrentLine.replace(this.CleanCharacters[i],'');\n\t\t}\n\t\tthis.CurrentRecord.push(this.CurrentLine);\n\t\tthis.CurrentLine = '';\n\t}\n\n\temitRow(pFormatAsJSON)\n\t{\n\t\tlet tmpFormatAsJSON = (typeof(pFormatAsJSON) == 'undefined') ? this.EmitJSON : pFormatAsJSON;\n\n\t\tthis.RowsEmitted++;\n\t\tlet tmpCompletedRecord = this.CurrentRecord;\n\t\tthis.CurrentRecord = [];\n\n\t\tif (tmpFormatAsJSON)\n\t\t{\n\t\t\treturn this.marshalRowToJSON(tmpCompletedRecord);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpCompletedRecord;\n\t\t}\n\t}\n\n\tparseCSVLine (pLineString)\n\t{\n\t\tthis.LinesParsed++;\n\n\t\tfor (let i = 0; i < pLineString.length; i++)\n\t\t{\n\t\t\tif ((!this.InQuote) && (pLineString[i] == this.Delimiter))\n\t\t\t{\n\t\t\t\tthis.pushLine();\n\t\t\t}\n\t\t\telse if (pLineString[i] == this.QuoteCharacter)\n\t\t\t{\n\t\t\t\t// If we are in the second part of an escaped quote, ignore it.\n\t\t\t\tif (this.InEscapedQuote)\n\t\t\t\t{\n\t\t\t\t\tthis.InEscapedQuote = false;\n\t\t\t\t}\n\t\t\t\t// If we aren't in a quote, enter quote\n\t\t\t\telse if (!this.InQuote)\n\t\t\t\t{\n\t\t\t\t\tthis.InQuote = true;\n\t\t\t\t}\n\t\t\t\t// We are in a quote, so peek forward to see if this is an \"escaped\" quote pair\n\t\t\t\telse if ((i < pLineString.length) && (pLineString[i+1] == this.QuoteCharacter))\n\t\t\t\t{\n\t\t\t\t\tthis.CurrentLine += this.EscapedQuoteString;\n\t\t\t\t\tthis.InEscapedQuote = true;\n\t\t\t\t}\n\t\t\t\t// We are in a quote, this isn't an \"escaped\" quote pair, so go out of quote mode\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.InQuote = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.CurrentLine += pLineString[i];\n\t\t\t}\n\t\t}\n\n\t\t// See if we are in a multiline quoted entry -- if not, emit the row.\n\t\tif (!this.InQuote)\n\t\t{\n\t\t\t// Push the last remaining column from the buffer to the current line.\n\t\t\tthis.pushLine();\n\n\t\t\t// Check to see if there is a header -- and if so, if this is the header row\n\t\t\tif (this.HasHeader && !this.HasSetHeader && (this.RowsEmitted == this.HeaderLineIndex))\n\t\t\t{\n\t\t\t\tthis.HasSetHeader = true;\n\t\t\t\t// Override the format as json bit\n\t\t\t\tthis.setHeader(this.emitRow(false));\n\n\t\t\t\t// No matter what, formatting this as JSON is silly and we don't want to go there anyway.\n\t\t\t\tif (this.EmitHeader)\n\t\t\t\t{\n\t\t\t\t\treturn this.Header;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.emitRow();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nmodule.exports = CSVParser;\n\n},{\"fable-serviceproviderbase\":59}],153:[function(require,module,exports){\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Data Formatting and Translation Functions\n*\n* @class DataFormat\n*/\nclass DataFormat extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'DataArithmatic';\n\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlphaChar = /[^a-zA-Z]/gi;\n\t\tthis._Regex_formatterCapitalizeEachWord = /([a-zA-Z]+)/g;\n\t\tthis._Regex_matcherHTMLEntities = /&(#?[a-zA-Z0-9]+);/g;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\n\t\tthis._SanitizeObjectKeyRegex = /[^a-zA-Z0-9_]/gi;\n\t\tthis._SanitizeObjectKeyReplacement = '_';\n\t\tthis._SanitizeObjectKeyInvalid = 'INVALID';\n\t}\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t\treturn pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {boolean}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t\tlet tmpHash = 0;\n\t\tlet tmpStringLength = pString.length;\n\t\tlet tmpCharacterIndex = 0;\n\n\t\twhile (tmpCharacterIndex < tmpStringLength)\n\t\t{\n\t\t\ttmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t\t}\n\n\t\treturn `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\tcapitalizeEachWord (pString)\n\t{\n\t\treturn pString.replace(this._Regex_formatterCapitalizeEachWord,\n\t\t\t(pMatch) =>\n\t\t\t{\n\t\t\t\treturn pMatch.charAt(0).toUpperCase() + pMatch.substr(1);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} pString - The string to resolve\n\t * @return {string} - The input string with all HTML entities resolved to their character counterparts\n\t */\n\tresolveHtmlEntities(pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn pString.replace(this._Regex_matcherHTMLEntities, (pMatch, pEntity) =>\n\t\t{\n\t\t\tswitch (pEntity)\n\t\t\t{\n\t\t\t\tcase 'comma':\n\t\t\t\t\treturn ',';\n\t\t\t\tcase 'amp':\n\t\t\t\t\treturn '&';\n\t\t\t\tcase 'lt':\n\t\t\t\t\treturn '<';\n\t\t\t\tcase 'gt':\n\t\t\t\t\treturn '>';\n\t\t\t\tcase 'times':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'divide':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'plus':\n\t\t\t\t\treturn '+';\n\t\t\t\tcase 'minus':\n\t\t\t\t\treturn '-';\n\t\t\t\tcase 'infin':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'ang':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'quot':\n\t\t\t\t\treturn '\"';\n\t\t\t\tcase 'apos':\n\t\t\t\t\treturn '\\'';\n\t\t\t\tcase 'nbsp':\n\t\t\t\t\treturn ' ';\n\t\t\t\tcase 'copy':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'reg':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'trade':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'euro':\n\t\t\t\t\treturn '';\n\t\t\t\tdefault:\n\t\t\t\t\tif (!pEntity.startsWith('#'))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn pMatch;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tconst tmpNumericalValue = parseInt(pEntity.substring(1), 10);\n\t\t\treturn String.fromCharCode(tmpNumericalValue);\n\t\t});\n\t}\n\n\t/**\n\t * Concatenate a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {...string} pStrings - The strings to concatenate\n\t * @return {string}\n\t */\n\tconcatenateStrings (...pStrings)\n\t{\n\t\treturn this.joinStrings('', ...pStrings);\n\t}\n\n\t/**\n\t * Concatenate a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tconcatenateStringsInternal ()\n\t{\n\t\tconst pParams = [ ...arguments ];\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.concatenateStrings(...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Join a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...string} pStrings - The strings to join\n\t * @return {string}\n\t */\n\tjoinStrings (pJoin, ...pStrings)\n\t{\n\t\treturn pStrings.filter((v) => typeof v === 'string' || typeof v === 'number').join(pJoin);\n\t}\n\n\t/**\n\t * Joins a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tjoinStringsInternal()\n\t{\n\t\tconst [ pJoinOn, ...pParams ] = arguments;\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.joinStrings(pJoinOn, ...tmpFlattenedArrays);\n\t}\n\n\n\t/**\n\t * Concatenate a list of values together into a string.\n\t *\n\t * @param {...any} pValues - The strings to concatenate\n\t * @return {string}\n\t */\n\tconcatenateStringsRaw (...pValues)\n\t{\n\t\treturn this.joinStringsRaw('', ...pValues);\n\t}\n\n\t/**\n\t * Concatenate a list of values together into a string.\n\t *\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tconcatenateStringsRawInternal (pValueObjectSetAddress)\n\t{\n\t\tconst pParams = [ ...arguments ];\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.concatenateStringsRaw(...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Join a list of values together into a string.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pValues - The strings to join\n\t * @return {string}\n\t */\n\tjoinStringsRaw (pJoin, ...pValues)\n\t{\n\t\treturn pValues.map(String).join(pJoin);\n\t}\n\n\t/**\n\t * Joins a list of values together into a string.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tjoinStringsRawInternal ()\n\t{\n\t\tconst [ pJoinOn, ...pParams ] = arguments;\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.joinStringsRaw(pJoinOn, ...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t * Clean a string of any non-alpha characters (including numbers)\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t\tif ((typeof(pString) == 'string') && (pString != ''))\n\t\t{\n\t\t\treturn pString.replace(this._Regex_formatterCleanNonAlphaChar, this._Value_Clean_formatterCleanNonAlpha);\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Clean a string of any characters to create a consistent object key.\n\t *\n\t * @param {string} pString  The string to clean.\n\t * @return {string} the cleaned string, or a placeholder if the input is invalid\n\t */\n\tsanitizeObjectKey(pString)\n\t{\n\t\tif (typeof pString !== 'string' || pString.length < 1)\n\t\t{\n\t\t\treturn this._SanitizeObjectKeyInvalid;\n\t\t}\n\t\treturn pString.replace(this._SanitizeObjectKeyRegex, this._SanitizeObjectKeyReplacement);\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t\t// Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t\tlet tmpReversed = this.stringReverse(pString);\n\t\t// Add commas every three characters\n\t\tlet tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t\t// Reverse again (back to normal direction)\n\t\treturn this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t\t// If the regex doesn't match, `replace` returns the string unmodified\n\t\treturn (pNumber.toString()).replace\n\t\t(\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t\t\tthis.processAddCommasToNumberRegex.bind(this)\n\t\t);\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue, pPrecision, pRoundingMethod)\n\t{\n\t\tif (isNaN(pValue))\n\t\t{\n\t\t\treturn this._Value_NaN_Currency;\n\t\t}\n\n\t\tif (pValue === null || pValue === undefined)\n\t\t{\n\t\t\treturn this._Value_NaN_Currency;\n\t\t}\n\n\t\tlet tmpDollarAmountArbitrary = this.fable.Math.parsePrecise(pValue);\n\t\tlet tmpPrecision = (typeof(pPrecision) == 'undefined') ? 2 : pPrecision;\n\t\tlet tmpDollarAmount = this.fable.Math.toFixedPrecise(tmpDollarAmountArbitrary, tmpPrecision, pRoundingMethod);\n\n\t\t// TODO: Get locale data and use that for this stuff.\n\t\treturn `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t\tlet tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t\tif (isNaN(pValue))\n\t\t{\n\t\t\tlet tmpZed = 0;\n\t\t\treturn tmpZed.toFixed(tmpDigits);\n\t\t}\n\n\t\tif (pValue === null || pValue === undefined)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpAmountArbitrary = this.fable.Utility.bigNumber(pValue);\n\t\tlet tmpValue = tmpAmountArbitrary.toFixed(tmpDigits);\n\n\t\tif (isNaN(tmpValue))\n\t\t{\n\t\t\tlet tmpZed = 0;\n\t\t\treturn tmpZed.toFixed(tmpDigits);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpValue;\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate a reapeating padding string to be appended before or after depending on\n\t * which padding function it uses.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringGeneratePaddingString(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpTargetLength = pTargetLength >> 0;\n\t\tlet tmpPadString = String((typeof pPadString !== 'undefined' ? pPadString : ' '));\n\t\tif (pString.length > pTargetLength)\n\t\t{\n\t\t\t// No padding string if the source string is already longer than the target length, return an empty string\n\t\t\treturn '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpPadLength = pTargetLength - pString.length;\n\t\t\tif (tmpPadLength > tmpPadString.length)\n\t\t\t{\n\t\t\t\ttmpPadString += tmpPadString.repeat(tmpTargetLength / tmpPadString.length);\n\t\t\t}\n\t\t\treturn tmpPadString.slice(0, tmpPadLength);\n\t\t}\n\t}\n\n\t/**\n\t * Pad the start of a string.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringPadStart = function(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpString = pString.toString();\n\t\treturn this.stringGeneratePaddingString(tmpString, pTargetLength, pPadString) + tmpString;\n\t}\n\n\t/**\n\t * Pad the end of a string.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringPadEnd = function(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpString = pString.toString();\n\t\treturn tmpString + this.stringGeneratePaddingString(tmpString, pTargetLength, pPadString);\n\t}\n\n\t/*************************************************************************\n\t * Time Formatting Functions (milliseconds)\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Format a time length in milliseconds into a human readable string.\n\t * @param {number} pTimeSpan\n\t * @returns {string} - HH:MM:SS.mmm\n\t */\n\tformatTimeSpan(pTimeSpan)\n\t{\n\t\tif (typeof(pTimeSpan) != 'number')\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpMs = parseInt(pTimeSpan%1000);\n\t\tlet tmpSeconds = parseInt((pTimeSpan/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeSpan/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeSpan/(1000*60*60));\n\n\t\treturn `${this.stringPadStart(tmpHours,2,'0')}:${this.stringPadStart(tmpMinutes,2,'0')}:${this.stringPadStart(tmpSeconds,2,'0')}.${this.stringPadStart(tmpMs,3,'0')}`;\n\t}\n\n\t/**\n\t * Format the time delta between two times in milliseconds into a human readable string.\n\t *\n\t * @param {number} pTimeStart\n\t * @param {number} pTimeEnd\n\t * @returns {string} - HH:MM:SS.mmm\n\t */\n\tformatTimeDelta(pTimeStart, pTimeEnd)\n\t{\n\t\tif ((typeof(pTimeStart) != 'number') || (typeof(pTimeEnd) != 'number'))\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.formatTimeSpan(pTimeEnd-pTimeStart);\n\t}\n\n\t// THE FOLLOWING TERRIBLE FUNCTIONS ARE FOR QT / WKHTMLTOPDF when luxon and moment don't work so well\n\tgetMonthFromDate (pJavascriptDate)\n\t{\n\t\tvar tmpMonths = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\t\treturn tmpMonths[pJavascriptDate.getMonth()];\n\t}\n\n\tgetMonthAbbreviatedFromDate (pJavascriptDate)\n\t{\n\t\tvar tmpMonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\t\treturn tmpMonths[pJavascriptDate.getMonth()];\n\t}\n\n\tformatMonthDayYearFromDate (pJavascriptDate, pStrict)\n\t{\n\t\tlet tmpStrict = (typeof(pStrict) !== 'undefined') ? pStrict : false;\n\n\t\tlet tmpMonth = pJavascriptDate.getMonth() + 1;\n\t\tlet tmpDay = pJavascriptDate.getDate();\n\t\tlet tmpYear = pJavascriptDate.getFullYear();\n\n\t\tif (tmpStrict)\n\t\t{\n\t\t\ttmpMonth = this.stringPadStart(tmpMonth, 2, '0');\n\t\t\ttmpDay = this.stringPadStart(tmpDay, 2, '0');\n\t\t\ttmpYear = this.stringPadStart(tmpYear, 4, '0');\n\t\t}\n\n\t\treturn `${tmpMonth}/${tmpDay}/${tmpYear}`;\n\t}\n\n\tformatSortableStringFromDate (pDate)\n\t{\n\t\treturn pDate.getFullYear()+this.stringPadStart(pDate.getMonth(),2,'0')+this.stringPadStart(pDate.getDate(),2,'0');\n\t}\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t\tlet tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\treturn pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the count of segments in the string as a number\n\t */\n\tstringCountSegments(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t}\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetSegments(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2, '\"':3, \"'\":4 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2, '\"':3, \"'\":4 };\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t}\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetFirstSegment(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t}\n\n\t/**\n\t * Encodes a string using encodeURIComponent, returning the encoded string.\n\t * If the input is not a string, returns the input unchanged.\n\t *\n\t * @param {string} pString - The string to encode.\n\t * @returns {string|*} The encoded string, or the original input if it is not a string.\n\t */\n\tstringEncodeURIComponent (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn encodeURIComponent(pString);\n\t}\n\n\t/**\n\t * Safely decodes a URI component string using decodeURIComponent.\n\t * If the input is not a string or decoding fails, returns the original input.\n\t *\n\t * @param {string} pString - The string to decode.\n\t * @returns {string} The decoded string, or the original input if decoding fails.\n\t */\n\tstringDecodeURIComponent (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\treturn decodeURIComponent(pString);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tthis.fable.Log.error(`Failed to decode URI component: ${pString}`, e);\n\t\t\treturn pString; // Return the original string if decoding fails\n\t\t}\n\t}\n\n\t/**\n\t * Encodes a string so that it can be safely embedded in JavaScript code.\n\t * Escapes special characters such as quotes, backslashes, and newlines.\n\t *\n\t * @param {string} pString - The input string to encode.\n\t * @returns {string} The encoded string with special characters escaped.\n\t */\n\tstringEncodeForJavascript (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\t//FIXME: missing regexp\n\t\treturn pString.replace(this._Regex_matcherJavascriptEncode, (pMatch) =>\n\t\t{\n\t\t\tswitch (pMatch)\n\t\t\t{\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn '\\\\\"';\n\t\t\t\tcase '\\'':\n\t\t\t\t\treturn '\\\\\\'';\n\t\t\t\tcase '\\\\':\n\t\t\t\t\treturn '\\\\\\\\';\n\t\t\t\tcase '\\n':\n\t\t\t\t\treturn '\\\\n';\n\t\t\t\tcase '\\r':\n\t\t\t\t\treturn '\\\\r';\n\t\t\t\tdefault:\n\t\t\t\t\treturn pMatch; // Return the original character if no encoding is needed\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a JavaScript-escaped string by replacing common escape sequences\n\t * (such as \\\" \\\\n \\\\r \\\\' and \\\\\\\\) with their actual character representations.\n\t *\n\t * @param {string} pString - The string to decode. If not a string, the input is returned as-is.\n\t * @returns {string} The decoded string with escape sequences replaced, or the original input if not a string.\n\t */\n\tstringDecodeForJavascript (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn pString.replace(this._Regex_matcherJavascriptDecode, (pMatch) =>\n\t\t{\n\t\t\tswitch (pMatch)\n\t\t\t{\n\t\t\t\tcase '\\\\\"':\n\t\t\t\t\treturn '\"';\n\t\t\t\tcase '\\\\\\'':\n\t\t\t\t\treturn '\\'';\n\t\t\t\tcase '\\\\\\\\':\n\t\t\t\t\treturn '\\\\';\n\t\t\t\tcase '\\\\n':\n\t\t\t\t\treturn '\\n';\n\t\t\t\tcase '\\\\r':\n\t\t\t\t\treturn '\\r';\n\t\t\t\tdefault:\n\t\t\t\t\treturn pMatch; // Return the original character if no decoding is needed\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosureStartIndex = 0;\n\t\tlet tmpEnclosureEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t\t{\n\t\t\treturn tmpString;\n\t\t}\n\n\t\tlet tmpReturnString = '';\n\n\t\tif (tmpEnclosureStartIndex > 1)\n\t\t{\n\t\t\ttmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t\t}\n\n\t\tif ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t\t{\n\t\t\ttmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t\t}\n\n\t\treturn tmpReturnString;\n\t}\n}\n\nmodule.exports = DataFormat;\n\n},{\"fable-serviceproviderbase\":59}],154:[function(require,module,exports){\nmodule.exports={\n\t\"DefaultIntegerMinimum\": 0,\n\t\"DefaultIntegerMaximum\": 9999999,\n\n\t\"DefaultNumericStringLength\": 10,\n\n\t\"MonthSet\": [\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\n\n\t\"WeekDaySet\":[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],\n\n\t\"ColorSet\": \n\t\t[\n\t\t\t\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\", \"Pink\", \"Purple\", \"Turquoise\", \"Gold\",\n\t\t\t\"Lime\", \"Maroon\", \"Navy\", \"Coral\", \"Teal\", \"Brown\", \"White\", \"Black\", \"Sky\", \"Berry\",\n\t\t\t\"Grey\", \"Straw\", \"Silver\", \"Sapphire\"\n\t\t],\n\n\t\"SurNameSet\":\n\t\t[\n\t\t\t\"Smith\", \"Johnson\", \"Williams\", \"Brown\", \"Jones\", \"Miller\", \"Davis\", \"Garcia\", \"Rodriguez\", \"Wilson\",\n\t\t\t\"Martinez\", \"Anderson\", \"Taylor\", \"Thomas\", \"Hernandez\", \"Moore\", \"Martin\", \"Jackson\", \"Thompson\", \"White\",\n\t\t\t\"Lopez\", \"Lee\", \"Gonzalez\", \"Harris\", \"Clark\", \"Lewis\", \"Robinson\", \"Walker\", \"Perez\", \"Hall\",\n\t\t\t\"Young\", \"Allen\", \"Sanchez\", \"Wright\", \"King\", \"Scott\", \"Green\", \"Baker\", \"Adams\", \"Nelson\",\n\t\t\t\"Hill\", \"Ramirez\", \"Campbell\", \"Mitchell\", \"Roberts\", \"Carter\", \"Phillips\", \"Evans\", \"Turner\", \"Torres\",\n\t\t\t\"Parker\", \"Collins\", \"Edwards\", \"Stewart\", \"Flores\", \"Morris\", \"Nguyen\", \"Murphy\", \"Rivera\", \"Cook\",\n\t\t\t\"Rogers\", \"Morgan\", \"Peterson\", \"Cooper\", \"Reed\", \"Bailey\", \"Bell\", \"Gomez\", \"Kelly\", \"Howard\",\n\t\t\t\"Ward\", \"Cox\", \"Diaz\", \"Richardson\", \"Wood\", \"Watson\", \"Brooks\", \"Bennett\", \"Gray\", \"James\",\n\t\t\t\"Reyes\", \"Cruz\", \"Hughes\", \"Price\", \"Myers\", \"Long\", \"Foster\", \"Sanders\", \"Ross\", \"Morales\",\n\t\t\t\"Powell\", \"Sullivan\", \"Russell\", \"Ortiz\", \"Jenkins\", \"Gutierrez\", \"Perry\", \"Butler\", \"Barnes\", \"Fisher\"\n\t\t],\n\n\t\"NameSet\":\n\t\t[\n\t\t\t\"Mary\", \"Patricia\", \"Jennifer\", \"Linda\", \"Elizabeth\", \"Barbara\", \"Susan\", \"Jessica\", \"Sarah\", \"Karen\",\n\t\t\t\"Lisa\", \"Nancy\", \"Betty\", \"Sandra\", \"Margaret\", \"Ashley\", \"Kimberly\", \"Emily\", \"Donna\", \"Michelle\",\n\t\t\t\"Carol\", \"Amanda\", \"Melissa\", \"Deborah\", \"Stephanie\", \"Dorothy\", \"Rebecca\", \"Sharon\", \"Laura\", \"Cynthia\",\n\t\t\t\"Amy\", \"Kathleen\", \"Angela\", \"Shirley\", \"Brenda\", \"Emma\", \"Anna\", \"Pamela\", \"Nicole\", \"Samantha\",\n\t\t\t\"Katherine\", \"Christine\", \"Helen\", \"Debra\", \"Rachel\", \"Carolyn\", \"Janet\", \"Maria\", \"Catherine\", \"Heather\",\n\t\t\t\"Diane\", \"Olivia\", \"Julie\", \"Joyce\", \"Victoria\", \"Ruth\", \"Virginia\", \"Lauren\", \"Kelly\", \"Christina\",\n\t\t\t\"Joan\", \"Evelyn\", \"Judith\", \"Andrea\", \"Hannah\", \"Megan\", \"Cheryl\", \"Jacqueline\", \"Martha\", \"Madison\",\n\t\t\t\"Teresa\", \"Gloria\", \"Sara\", \"Janice\", \"Ann\", \"Kathryn\", \"Abigail\", \"Sophia\", \"Frances\", \"Jean\",\n\t\t\t\"Alice\", \"Judy\", \"Isabella\", \"Julia\", \"Grace\", \"Amber\", \"Denise\", \"Danielle\", \"Marilyn\", \"Beverly\",\n\t\t\t\"Charlotte\", \"Natalie\", \"Theresa\", \"Diana\", \"Brittany\", \"Doris\", \"Kayla\", \"Alexis\", \"Lori\", \"Marie\",\n\t\t\t\"James\", \"Robert\", \"John\", \"Michael\", \"David\", \"William\", \"Richard\", \"Joseph\", \"Thomas\", \"Christopher\",\n\t\t\t\"Charles\", \"Daniel\", \"Matthew\", \"Anthony\", \"Mark\", \"Donald\", \"Steven\", \"Andrew\", \"Paul\", \"Joshua\",\n\t\t\t\"Kenneth\", \"Kevin\", \"Brian\", \"George\", \"Timothy\", \"Ronald\", \"Jason\", \"Edward\", \"Jeffrey\", \"Ryan\",\n\t\t\t\"Jacob\", \"Gary\", \"Nicholas\", \"Eric\", \"Jonathan\", \"Stephen\", \"Larry\", \"Justin\", \"Scott\", \"Brandon\",\n\t\t\t\"Benjamin\", \"Samuel\", \"Gregory\", \"Alexander\", \"Patrick\", \"Frank\", \"Raymond\", \"Jack\", \"Dennis\", \"Jerry\",\n\t\t\t\"Tyler\", \"Aaron\", \"Jose\", \"Adam\", \"Nathan\", \"Henry\", \"Zachary\", \"Douglas\", \"Peter\", \"Kyle\",\n\t\t\t\"Noah\", \"Ethan\", \"Jeremy\", \"Walter\", \"Christian\", \"Keith\", \"Roger\", \"Terry\", \"Austin\", \"Sean\",\n\t\t\t\"Gerald\", \"Carl\", \"Harold\", \"Dylan\", \"Arthur\", \"Lawrence\", \"Jordan\", \"Jesse\", \"Bryan\", \"Billy\",\n\t\t\t\"Bruce\", \"Gabriel\", \"Joe\", \"Logan\", \"Alan\", \"Juan\", \"Albert\", \"Willie\", \"Elijah\", \"Wayne\",\n\t\t\t\"Randy\", \"Vincent\", \"Mason\", \"Roy\", \"Ralph\", \"Bobby\", \"Russell\", \"Bradley\", \"Philip\", \"Eugene\"\n\t\t]\n}\n},{}],155:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\n/**\n * FableServiceDataGeneration class provides various methods for generating random data.\n *\n * @extends libFableServiceBase\n */\nclass FableServiceDataGeneration extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'DataGeneration';\n\n\t\tthis.defaultData = require('./Fable-Service-DataGeneration-DefaultValues.json');\n\t}\n\n\t/**\n\t * Generates a random integer between the specified minimum and maximum values.\n\t *\n\t * @param {number} pMinimum - The minimum value (inclusive).\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random integer between pMinimum and pMaximum.\n\t */\n\trandomIntegerBetween(pMinimum, pMaximum)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpMinimum = parseInt(pMinimum, 10);\n\t\t\tlet tmpMaximum = parseInt(pMaximum, 10);\n\t\t\treturn Math.floor(Math.random() * (tmpMaximum - tmpMinimum)) + tmpMinimum;\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\tthis.fable.log.error('Error in randomIntegerBetween', pError, { 'Minimum': pMinimum, 'Maximum': pMaximum });\n\t\t\treturn NaN;\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random integer between 0 (inclusive) and the specified maximum value (exclusive).\n\t *\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random integer between 0 and pMaximum.\n\t */\n\trandomIntegerUpTo(pMaximum)\n\t{\n\t\treturn this.randomIntegerBetween(0, pMaximum);\n\t}\n\n\t/**\n\t * Generates a random integer between 0 (inclusive) and the default maximum value.\n\t *\n\t * @returns {number} A random integer between 0 and the default maximum value.\n\t */\n\trandomInteger()\n\t{\n\t\treturn Math.floor(Math.random() * this.defaultData.DefaultIntegerMaximum);\n\t}\n\n\t/**\n\t * Generates a random float between the specified minimum and maximum values.\n\t *\n\t * @param {number} pMinimum - The minimum value (inclusive).\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random float between pMinimum and pMaximum.\n\t */\n\trandomFloatBetween(pMinimum, pMaximum)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpMinimum = parseFloat(pMinimum);\n\t\t\tlet tmpMaximum = parseFloat(pMaximum);\n\t\t\treturn this.fable.Math.addPrecise(this.fable.Math.multiplyPrecise(Math.random(), this.fable.Math.subtractPrecise(tmpMaximum, tmpMinimum)), tmpMinimum);\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\tthis.fable.log.error('Error in randomFloatBetween', pError, { 'Minimum': pMinimum, 'Maximum': pMaximum });\n\t\t\treturn NaN;\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random float between 0 (inclusive) and the specified maximum value (exclusive).\n\t *\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random float between 0 and pMaximum.\n\t */\n\trandomFloatUpTo(pMaximum)\n\t{\n\t\treturn this.randomFloatBetween(0, pMaximum);\n\t}\n\n\t/**\n\t * Generates a random float between 0 (inclusive) and 1 (exclusive).\n\t *\n\t * @returns {number} A random float between 0 and 1.\n\t */\n\trandomFloat()\n\t{\n\t\treturn Math.random();\n\t}\n\n\t/**\n\t * Generates a random numeric string of the specified length.\n\t *\n\t * @param {number} pLength - The length of the numeric string.\n\t * @param {number} pMaxNumber - The maximum number to generate.\n\t * @returns {string} A random numeric string of the specified length.\n\t */\n\trandomNumericString(pLength, pMaxNumber)\n\t{\n\t\tlet tmpLength = (typeof(pLength) === 'undefined') ? 10 : pLength;\n\t\tlet tmpMaxNumber = (typeof(pMaxNumber) === 'undefined') ? 9999999999 : pMaxNumber;\n\n\t\treturn this.services.DataFormat.stringPadStart(this.randomIntegerUpTo(tmpMaxNumber), pLength, '0');\n\t}\n\n\t/**\n\t * Generates a random month from the default month set.\n\t *\n\t * @returns {string} A random month.\n\t */\n\trandomMonth()\n\t{\n\t\treturn this.defaultData.MonthSet[this.randomIntegerUpTo(this.defaultData.MonthSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random day of the week from the default week day set.\n\t *\n\t * @returns {string} A random day of the week.\n\t */\n\trandomDayOfWeek()\n\t{\n\t\treturn this.defaultData.WeekDaySet[this.randomIntegerUpTo(this.defaultData.WeekDaySet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random color from the default color set.\n\t *\n\t * @returns {string} A random color.\n\t */\n\trandomColor()\n\t{\n\t\treturn this.defaultData.ColorSet[this.randomIntegerUpTo(this.defaultData.ColorSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random name from the default name set.\n\t *\n\t * @returns {string} A random name.\n\t */\n\trandomName()\n\t{\n\t\treturn this.defaultData.NameSet[this.randomIntegerUpTo(this.defaultData.NameSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random surname from the default surname set.\n\t *\n\t * @returns {string} A random surname.\n\t */\n\trandomSurname()\n\t{\n\t\treturn this.defaultData.SurNameSet[this.randomIntegerUpTo(this.defaultData.SurNameSet.length - 1)];\n\t}\n}\n\nmodule.exports = FableServiceDataGeneration;\n\n},{\"./Fable-Service-DataGeneration-DefaultValues.json\":154,\"fable-serviceproviderbase\":59}],156:[function(require,module,exports){\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Date management a la Moment using days.js\n*\n* @class DateManipulation\n*/\nclass DateManipulation extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash)\n\n\t\tthis.serviceType = 'Dates';\n\n\t\tthis.dayJS = require('dayjs');\n\n\t\t// Include the `weekOfYear` plugin\n\t\tthis.plugin_weekOfYear = require('dayjs/plugin/weekOfYear');\n\t\tthis.dayJS.extend(this.plugin_weekOfYear);\n\t\t// Include the `weekday` plugin\n\t\tthis.plugin_weekday = require('dayjs/plugin/weekday');\n\t\tthis.dayJS.extend(this.plugin_weekday);\n\t\t// Include the `isoWeek` plugin\n\t\tthis.plugin_isoWeek = require('dayjs/plugin/isoWeek');\n\t\tthis.dayJS.extend(this.plugin_isoWeek);\n\t\t// Include the `timezone` plugin\n\t\tthis.plugin_timezone = require('dayjs/plugin/timezone');\n\t\tthis.dayJS.extend(this.plugin_timezone);\n\t\t// Include the `relativetime` plugin\n\t\tthis.plugin_relativetime = require('dayjs/plugin/relativeTime');\n\t\tthis.dayJS.extend(this.plugin_relativetime);\n\t\t// Include the `utc` plugin\n\t\tthis.plugin_utc = require('dayjs/plugin/utc');\n\t\tthis.dayJS.extend(this.plugin_utc);\n\t\t// Include the `advancedFormat` plugin\n\t\tthis.plugin_advancedFormat = require('dayjs/plugin/advancedFormat');\n\t\tthis.dayJS.extend(this.plugin_advancedFormat);\n\n\t\t// A developer can include locales if they want\n\t\t// You would do the following:\n\t\t// const localeDE = require('dayjs/locale/de');\n\t\t// _Fable.Dates.dayJS.locale('de');\n\t}\n\n\t/**\n\t * Calculates the difference in milliseconds between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in milliseconds between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMillisecondDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'millisecond');\n\t}\n\n\t/**\n\t * Calculates the difference in seconds between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in seconds between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateSecondDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'second');\n\t}\n\n\t/**\n\t * Calculates the difference in minutes between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in minutes between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMinuteDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'minute');\n\t}\n\n\t/**\n\t * Calculates the difference in hours between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in hours between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateHourDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'hour');\n\t}\n\n\t/**\n\t * Calculates the difference in days between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in days between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateDayDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'day');\n\t}\n\n\t/**\n\t * Calculates the difference in weeks between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in weeks between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateWeekDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'week');\n\t}\n\n\t/**\n\t * Calculates the difference in months between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in months between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMonthDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'month');\n\t}\n\n\t/**\n\t * Calculates the difference in years between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in years between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateYearDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'year');\n\t}\n\n\tdateAddMilliseconds(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'millisecond', 'add');\n\t}\n\n\tdateAddSeconds(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'second', 'add');\n\t}\n\n\tdateAddMinutes(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'minute', 'add');\n\t}\n\n\tdateAddHours(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'hour', 'add');\n\t}\n\n\tdateAddDays(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'day', 'add');\n\t}\n\n\tdateAddWeeks(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'week', 'add');\n\t}\n\n\tdateAddMonths(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'month', 'add');\n\t}\n\n\tdateAddYears(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'year', 'add');\n\t}\n\n\tdateMath(pDate, pAmount, pUnit, pOperation)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpDate = this.dayJS.utc(pDate);\n\n\t\t\tif (pOperation === 'add')\n\t\t\t{\n\t\t\t\ttmpDate = tmpDate.add(pAmount, pUnit);\n\t\t\t}\n\t\t\telse if (pOperation === 'subtract')\n\t\t\t{\n\t\t\t\ttmpDate = tmpDate.subtract(pAmount, pUnit);\n\t\t\t}\n\t\t\treturn this.dayJS.utc(tmpDate).toISOString();\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tdateFromParts(pYear, pMonth, pDay, pHour = 0, pMinute = 0, pSecond = 0, pMillisecond = 0)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpDate = this.dayJS.utc().year(pYear).month(pMonth - 1).date(pDay).hour(pHour).minute(pMinute).second(pSecond).millisecond(pMillisecond);\n\t\t\treturn tmpDate.toISOString();\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = DateManipulation;\n\n},{\"dayjs\":32,\"dayjs/plugin/advancedFormat\":33,\"dayjs/plugin/isoWeek\":34,\"dayjs/plugin/relativeTime\":35,\"dayjs/plugin/timezone\":36,\"dayjs/plugin/utc\":37,\"dayjs/plugin/weekOfYear\":38,\"dayjs/plugin/weekday\":39,\"fable-serviceproviderbase\":59}],157:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceEnvironmentData extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'EnvironmentData';\n\n\t\tthis.Environment = `node.js`;\n\t}\n}\n\nmodule.exports = FableServiceEnvironmentData;\n\n},{\"fable-serviceproviderbase\":59}],158:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\n/* Trying a different pattern for this service ...\n *\n * This service is a simple expression parser that can handle math expressions, with magic(tm) lookup of addresses with a manifest.\n *\n * Each method works multiple ways.\n *\n * 1. You can pass in a results object, and, it will put the state for that step outcome into the results object.\n * 2. It always returns the state, and works without the results object.\n *\n *\n * Learned a lot from this npm package: https://www.npmjs.com/package/math-expression-evaluator\n * And its related code at github: https://github.com/bugwheels94/math-expression-evaluator\n *\n * There were two problems with the codebase above...\n *\n * First, the code was very unreadable and determining it was correct or extending it\n * was out of the question.\n *\n * Second, and this is a larger issue, is that we need the expressions to be parsed as\n * arbitrary precision.  When I determined that extending the library to use string-based\n * numbers and an arbitrary precision library as the back-end would have taken a significantly\n * longer amount of time than just writing the parser from scratch... et voila.\n */\n\nclass FableServiceExpressionParser extends libFableServiceBase\n{\n\t/**\n\t * Constructs a new instance of the ExpressionParser service.\n\t * @param {Object} pFable - The Fable object.\n\t * @param {Object} pOptions - The options for the service.\n\t * @param {string} pServiceHash - The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t/** @type {import('../Fable.js') & { Math: import('./Fable-Service-Math.js') }} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.log;\n\n\t\t// The configuration for tokens that the solver recognizes, with precedence and friendly names.\n\t\tthis.tokenMap = require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json');\n\n\t\t// Keep track of maximum token precedence\n\t\tthis.tokenMaxPrecedence = 4;\n\t\t// This isn't exactly a radix tree but close enough.  It's a map of the first character of the token to the token.\n\t\tthis.tokenRadix = {};\n\t\tlet tmpTokenKeys = Object.keys(this.tokenMap);\n\t\tfor (let i = 0; i < tmpTokenKeys.length; i++)\n\t\t{\n\t\t\tlet tmpTokenKey = tmpTokenKeys[i];\n\t\t\tlet tmpToken = this.tokenMap[tmpTokenKey];\n\n\t\t\ttmpToken.Token = tmpTokenKey;\n\t\t\ttmpToken.Length = tmpTokenKey.length;\n\n\t\t\tlet tmpTokenStartCharacter = tmpToken.Token[0];\n\t\t\tif (!(tmpTokenStartCharacter in this.tokenRadix))\n\t\t\t{\n\t\t\t\t// With a token count of 1 and a literal of true, we can assume it being in the radix is the token.\n\t\t\t\tthis.tokenRadix[tmpTokenStartCharacter] = (\n\t\t\t\t\t{\n\t\t\t\t\t\tTokenCount: 0,\n\t\t\t\t\t\tLiteral: false,\n\t\t\t\t\t\tTokenKeys: [],\n\t\t\t\t\t\tTokenMap: {}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenCount++;\n\t\t\tif (tmpTokenKey == tmpTokenStartCharacter)\n\t\t\t{\n\t\t\t\tthis.tokenRadix[tmpTokenStartCharacter].Literal = true;\n\t\t\t}\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenMap[tmpToken.Token] = tmpToken;\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenKeys.push(tmpTokenKey);\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenKeys.sort((pLeft, pRight) => pRight.length - pLeft.length);\n\n\t\t\tif (this.tokenMaxPrecedence < tmpToken.Precedence)\n\t\t\t{\n\t\t\t\tthis.tokenMaxPrecedence = tmpToken.Precedence;\n\t\t\t}\n\t\t}\n\n\t\t// The configuration for which functions are available to the solver.\n\t\tthis.functionMap = require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json');\n\n\t\tthis.serviceType = 'ExpressionParser';\n\n\t\t// These are sub-services for the tokenizer, linter, compiler, marshaler and solver.\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Tokenizer', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-TokenizerDirectiveMutation', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer-DirectiveMutation.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Linter', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Postfix', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-ValueMarshal', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Solver', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js'));\n\t\t// And the sub-service for the friendly user messaging\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Messaging', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js'));\n\n\n\t\t// This code instantitates these fable services to child objects of this service, but does not pollute the main fable with them.\n\t\tthis.Tokenizer = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Tokenizer');\n\t\tthis.Tokenizer.TokenizerDirectiveMutation = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-TokenizerDirectiveMutation');\n\t\tthis.Linter = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Linter');\n\t\tthis.Postfix = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Postfix');\n\t\tthis.ValueMarshal = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-ValueMarshal');\n\t\tthis.Solver = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Solver');\n\t\tthis.Messaging = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Messaging');\n\n\t\t// Wire each sub service into this instance of the solver.\n\t\tthis.Tokenizer.connectExpressionParser(this);\n\t\tthis.Linter.connectExpressionParser(this);\n\t\tthis.Postfix.connectExpressionParser(this);\n\t\tthis.ValueMarshal.connectExpressionParser(this);\n\t\tthis.Solver.connectExpressionParser(this);\n\t\tthis.Messaging.connectExpressionParser(this);\n\n\t\tthis.GenericManifest = this.fable.newManyfest();\n\n\t\t// This will look for a LogNoisiness on fable (or one that falls in from pict) and if it doesn't exist, set one for this service.\n\t\tthis.LogNoisiness = ('LogNoisiness' in this.fable) ? this.fable.LogNoisiness : 0;\n\t}\n\n\t/**\n\t * Tokenizes the given mathematical expression string.\n\t *\n\t * @param {string} pExpression - The expression to tokenize.\n\t * @param {object} pResultObject - The result object to store the tokenized expression.\n\t * @returns {object} - The tokenized expression.\n\t */\n\ttokenize(pExpression, pResultObject)\n\t{\n\t\treturn this.Tokenizer.tokenize(pExpression, pResultObject);\n\t}\n\n\t/**\n\t * Lints a tokenized expression.\n\t *\n\t * @param {Array} pTokenizedExpression - The tokenized expression to lint.\n\t * @param {Object} pResultObject - The result object where we store the linting result.\n\t * @returns {Object} - The linting result object.\n\t */\n\tlintTokenizedExpression(pTokenizedExpression, pResultObject)\n\t{\n\t\treturn this.Linter.lintTokenizedExpression(pTokenizedExpression, pResultObject);\n\t}\n\n\t/**\n\t * Builds a postfix solve list for the given tokenized expression and result object.\n\t *\n\t * @param {Array} pTokenizedExpression - The tokenized expression.\n\t * @param {Object} pResultObject - The result object where the algorithm \"shows its work\".\n\t * @returns {Array} The postfix solve list.\n\t */\n\tbuildPostfixedSolveList(pTokenizedExpression, pResultObject)\n\t{\n\t\treturn this.Postfix.buildPostfixedSolveList(pTokenizedExpression, pResultObject);\n\t}\n\n\t/**\n\t * Substitutes values in tokenized objects.\n\t *\n\t * This means marshaling data from pDataSource into the array of objects with the passed in Manifest (or a generic manifest) to prepare for solving.\n\t *\n\t * @param {Array} pTokenizedObjects - The array of tokenized objects.\n\t * @param {Object} pDataSource - The data source object.\n\t * @param {Object} pResultObject - The result object.\n\t * @param {Object} pManifest - The manifest object.\n\t * @returns {Object} - The updated result object.\n\t */\n\tsubstituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest)\n\t{\n\t\treturn this.ValueMarshal.substituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest);\n\t}\n\n\t/**\n\t * Solves a postfixed expression Array.\n\t *\n\t * @param {Array} pPostfixedExpression - The postfixed expression to solve.\n\t * @param {object} pDataDestinationObject - The data destination object where data gets marshaled to after solving.\n\t * @param {object} pResultObject - The result object where the algorithm \"shows its work\".\n\t * @param {object} pManifest - The manifest object.\n\t * @returns {any} The result of the solved expression.\n\t */\n\tsolvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest)\n\t{\n\t\treturn this.Solver.solvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest);\n\t}\n\n\t/**\n\t * Add a function to the solver.\n\t *\n\t * @param {string} pFunctionName \n\t * @param {string} pFunctionAddress \n\t * @param {string} pFunctionComment \n\t */\n\taddSolverFunction(pFunctionName, pFunctionAddress, pFunctionComment)\n\t{\n\t\tlet tmpFunctionName = (pFunctionName || '').trim().toLowerCase();\n\t\tif (this.functionMap.hasOwnProperty(tmpFunctionName))\n\t\t{\n\t\t\tthis.log.warn(`PictDynamicFormsInformary: Function ${tmpFunctionName} already exists in the solver, overwriting with address [${pFunctionAddress}].`);\n\t\t\t//return false;\n\t\t}\n\t\tthis.functionMap[tmpFunctionName] = (\n\t\t{\n\t\t\tName: pFunctionComment || `Autogenerated function ${tmpFunctionName}`,\n\t\t\tAddress: pFunctionAddress,\n\t\t});\n\t}\n\n\t/**\n\t * Prepares the parameters for a SERIES directive by substituting values and applying defaults.\n\t *\n\t * @param {Array} pParameters\n\t * @param {Array} pDefaults\n\t * @param {Object} pResultObject\n\t * @param {Object} pDataSourceObject\n\t * @param {import('manyfest')} [pManifest]\n\t */\n\t_prepareDirectiveParameters(pParameters, pDefaults, pResultObject, pDataSourceObject, pManifest)\n\t{\n\t\tconst tmpResults = [];\n\t\tfor (let i = 0; i < pParameters.length; i++)\n\t\t{\n\t\t\tconst tmpParameter = pParameters[i];\n\t\t\tlet tmpValue = this.fable.Math.parsePrecise(tmpParameter, NaN);\n\t\t\tif (isNaN(tmpValue) && typeof tmpParameter === 'string' && tmpParameter.length > 0)\n\t\t\t{\n\t\t\t\tconst tmpToken = this.fable.ExpressionParser.Postfix.getTokenContainerObject(tmpParameter, 'Token.Symbol');\n\t\t\t\tthis.substituteValuesInTokenizedObjects([tmpToken], pDataSourceObject, pResultObject, pManifest);\n\t\t\t\tif (tmpToken.Resolved)\n\t\t\t\t{\n\t\t\t\t\ttmpValue = tmpToken.Value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isNaN(tmpValue) && pDefaults.length > i)\n\t\t\t{\n\t\t\t\ttmpValue = pDefaults[i];\n\t\t\t}\n\t\t\ttmpResults.push(tmpValue);\n\t\t}\n\t\treturn tmpResults;\n\t}\n\n\t/**\n\t * Solves the given expression using the provided data and manifest.\n\t *\n\t * @param {string} pExpression - The expression to solve.\n\t * @param {Record<string, any>} [pDataSourceObject] - (optional) The data source object (e.g. AppData).\n\t * @param {Record<string, any>} [pResultObject] - (optional) The result object containing the full postfix expression list, internal variables and solver history.\n\t * @param {import('manyfest')} [pManifest] - (optional) The manifest object for dereferencing variables.\n\t * @param {Record<string, any>} [pDataDestinationObject] - (optional) The data destination object for where to marshal the result into.\n\t * @returns {any} - The result of solving the expression.\n\t */\n\tsolve(pExpression, pDataSourceObject, pResultObject, pManifest, pDataDestinationObject)\n\t{\n\t\tlet tmpResultsObject = (typeof(pResultObject) === 'object') ? pResultObject : {};\n\t\tlet tmpDataSourceObject = (typeof(pDataSourceObject) === 'object') ? pDataSourceObject : {};\n\t\tlet tmpDataDestinationObject = (typeof(pDataDestinationObject) === 'object') ? pDataDestinationObject : {};\n\n\t\t// This is technically a \"pre-compile\" and we can keep this Results Object around to reuse for better performance.  Not required.\n\t\tthis.tokenize(pExpression, tmpResultsObject);\n\n\t\t// Lint the tokenized expression to make sure it's valid\n\t\tthis.lintTokenizedExpression(tmpResultsObject.RawTokens, tmpResultsObject);\n\t\tthis.buildPostfixedSolveList(tmpResultsObject.RawTokens, tmpResultsObject);\n\n\t\tconst tmpManifest = (typeof(pManifest) === 'object') ? pManifest : this.fable.newManyfest();\n\t\tif (tmpResultsObject.SolverDirectives.Code == 'SERIES')\n\t\t{\n\t\t\tconst [ tmpStep , tmpFrom, tmpTo] = this._prepareDirectiveParameters([\n\t\t\t\ttmpResultsObject.SolverDirectives.Step,\n\t\t\t\ttmpResultsObject.SolverDirectives.From,\n\t\t\t\ttmpResultsObject.SolverDirectives.To,\n\t\t\t], [ '1' ], tmpResultsObject, tmpDataSourceObject, tmpManifest);\n\n\t\t\tif (isNaN(tmpFrom) || isNaN(tmpTo))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  FROM, TO must be numeric.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Make sure from/to are not equal\n\t\t\tif (this.fable.Math.comparePrecise(tmpFrom, tmpTo) == 0)\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  FROM and TO cannot be equal.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Make sure that Step is the correct positive/negative based on From and To\n\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') == 0)\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP cannot be zero.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (this.fable.Math.comparePrecise(tmpFrom, tmpTo) < 0)\n\t\t\t{\n\t\t\t\t// From < To so Step must be positive\n\t\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP must be positive when FROM < TO.`);\n\t\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// From >= To so Step must be negative\n\t\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP must be negative when FROM >= TO.`);\n\t\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get the number of iterations we need to perform\n\t\t\tlet tmpIterations = parseInt(this.fable.Math.floorPrecise(this.fable.Math.dividePrecise(this.fable.Math.subtractPrecise(tmpTo, tmpFrom), tmpStep)));\n\n\t\t\tlet tmpValueArray = [];\n\n\t\t\tfor (let i = 0; i <= tmpIterations; i++)\n\t\t\t{\n\t\t\t\tconst tmpCurrentValueOfN = this.fable.Math.addPrecise(tmpFrom, this.fable.Math.multiplyPrecise(tmpStep, i.toString()));\n\t\t\t\tconst tmpPreviousValueOfN = (i == 0) ? 'false' : this.fable.Math.addPrecise(tmpFrom, this.fable.Math.multiplyPrecise(tmpStep, (i - 1).toString()));\n\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.n = tmpCurrentValueOfN;\n\t\t\t\ttmpSeriesStepDataSourceObject.prev_n = tmpPreviousValueOfN;\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\n\t\t\t\ttmpValueArray.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpValueArray);\n\n\t\t\treturn tmpValueArray;\n\t\t}\n\t\telse if (tmpResultsObject.SolverDirectives.Code == 'MAP')\n\t\t{\n\t\t\t// The values to pull in -- this could be a map but affords better flexibility broken out like this.\n\t\t\tconst tmpDirectiveValues = tmpResultsObject.SolverDirectives.Values;\n\t\t\tconst tmpDirectiveValueKeys = tmpResultsObject.SolverDirectives.ValueKeys;\n\t\t\tlet tmpValueArray = [];\n\n\t\t\tfor (let i = 0; i < tmpDirectiveValueKeys.length; i++)\n\t\t\t{\n\t\t\t\tconst tmpVariableKey = tmpDirectiveValueKeys[i];\n\t\t\t\tconst tmpVariableDescription = tmpDirectiveValues[tmpVariableKey];\n\n\t\t\t\t// Get the actual value for this variable's address\n\t\t\t\ttmpVariableDescription.Value = tmpManifest.getValueByHash(tmpDataSourceObject, tmpVariableDescription.Address);\n\t\t\t}\n\n\t\t\t// If the first value doesn't have keys, don't do the map.\n\t\t\tif ((tmpDirectiveValueKeys.length < 1) || (tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value == null) || (!Array.isArray(tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value)))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid MAP directive parameters.  The first variable's address must resolve to an array.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tlet tmpControllingSet = tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value;\n\n\t\t\tfor (let i = 0; i < tmpControllingSet.length; i++)\n\t\t\t{\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\tfor (let j = 0; j < tmpDirectiveValueKeys.length; j++)\n\t\t\t\t{\n\t\t\t\t\tconst tmpVariableKey = tmpDirectiveValueKeys[j];\n\t\t\t\t\tif (!Array.isArray(tmpDirectiveValues[tmpVariableKey].Value) || (tmpDirectiveValues[tmpVariableKey].Value.length <= i))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKey] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKey] = tmpDirectiveValues[tmpVariableKey].Value[i];\n\t\t\t\t\t}\n\t\t\t\t\tconst tmpPreviousValueKey = `prev_${tmpVariableKey}`;\n\t\t\t\t\tif (!Array.isArray(tmpDirectiveValues[tmpVariableKey].Value) || (tmpDirectiveValues[tmpVariableKey].Value.length <= i))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = 'false';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = tmpDirectiveValues[tmpVariableKey].Value[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\n\t\t\t\ttmpValueArray.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpValueArray);\n\n\t\t\treturn tmpValueArray;\n\t\t}\n\t\telse if (tmpResultsObject.SolverDirectives.Code == 'MONTECARLO')\n\t\t{\n\t\t\tconst [ tmpSampleCount ] = this._prepareDirectiveParameters([\n\t\t\t\ttmpResultsObject.SolverDirectives.SampleCount\n\t\t\t], [ '1' ], tmpResultsObject, tmpDataSourceObject, tmpManifest);\n\n\t\t\tif (isNaN(tmpSampleCount))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid MONTECARLO directive parameters.  SAMPLECOUNT must be numeric.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet tmpMonteCarloOutput = JSON.parse(JSON.stringify(tmpResultsObject.SolverDirectives));\n\t\t\ttmpMonteCarloOutput.Samples = [];\n\n\t\t\t// Now go through each variable and prepare its object of values\n\t\t\tlet tmpVariableKeys = Object.keys(tmpMonteCarloOutput.Values);\n\t\t\tfor (let i = 0; i < tmpVariableKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpVariableKey = tmpVariableKeys[i];\n\t\t\t\tlet tmpVariableDescription = tmpMonteCarloOutput.Values[tmpVariableKey];\n\n\t\t\t\t// For each variable, generate its array of sampled values\n\t\t\t\ttmpVariableDescription.Distribution = {};\n\t\t\t\ttmpVariableDescription.ValueSequence = [];\n\n\t\t\t\t// Resolve the points if they are tokenized expressions\n\t\t\t\tconst tmpResolvedPoints = [];\n\t\t\t\tfor (let j = 0; j < tmpVariableDescription.Points.length; j++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPointToken = tmpVariableDescription.Points[j];\n\t\t\t\t\tlet tmpPointValue = this.fable.Math.parsePrecise(tmpPointToken, NaN);\n\t\t\t\t\tif (isNaN(tmpPointValue) && typeof tmpPointToken === 'string' && tmpPointToken.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPointValue = tmpManifest.getValueByHash(tmpDataSourceObject, tmpPointToken);\n\t\t\t\t\t\tif (!tmpPointValue || (tmpPointValue == null))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//TODO: Warn?\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResolvedPoints.push(tmpPointValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResolvedPoints.push(tmpPointToken);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now sort the resolved points\n\t\t\t\ttmpResolvedPoints.sort((a, b) => this.fable.Math.comparePrecise(a, b));\n\t\t\t\ttmpVariableDescription.ResolvedPoints = tmpResolvedPoints;\n\n\t\t\t\t// Just simple linear until we add more easing types in a separate library (refactoring the below out)\n\t\t\t\ttmpVariableDescription.FirstPoint = tmpVariableDescription.ResolvedPoints[0];\n\t\t\t\ttmpVariableDescription.DomainRangeStart = tmpVariableDescription.FirstPoint;\n\t\t\t\tif (tmpVariableDescription.ResolvedPoints.length < 2)\n\t\t\t\t{\n\t\t\t\t\ttmpVariableDescription.LastPoint = tmpVariableDescription.FirstPoint;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpVariableDescription.LastPoint = this.fable.Math.parsePrecise(tmpVariableDescription.ResolvedPoints[tmpVariableDescription.ResolvedPoints.length - 1], NaN);\n\t\t\t\t\tif (isNaN(tmpVariableDescription.LastPoint))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpVariableDescription.LastPoint = tmpVariableDescription.FirstPoint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpVariableDescription.DomainLength = this.fable.Math.subtractPrecise(tmpVariableDescription.LastPoint, tmpVariableDescription.FirstPoint);\n\t\t\t\t//this.fable.log.trace(`Monte Carlo variable ${tmpVariableKey} has first point ${tmpVariableDescription.FirstPoint}, last point ${tmpVariableDescription.LastPoint}, domain length ${tmpVariableDescription.DomainLength}`);\n\n\t\t\t\t// // This generation of data based on the resolved points (and easing type) should be abstracted.  Most require the same rules.\n\t\t\t\t// tmpVariableDescription.ResolvedPointDomainStarts = [];\n\t\t\t\t// tmpVariableDescription.DomainTranslationAmount = [];\n\n\t\t\t\t// // Get the length of each domain segment and the multiplier for them\n\t\t\t\t// tmpVariableDescription.DomainLength = this.fable.Math.subtractPrecise(tmpVariableDescription.ResolvedPoints[tmpVariableDescription.ResolvedPoints.length - 1], tmpVariableDescription.ResolvedPoints[0]);\n\t\t\t\t// tmpVariableDescription.DomainChunkCount = tmpVariableDescription.ResolvedPoints.length;\n\t\t\t\t// tmpVariableDescription.DomainStart = tmpVariableDescription.ResolvedPoints[0];\n\n\t\t\t\t// let tmpCurrentDomainPosition = tmpVariableDescription.DomainStart;\n\t\t\t\t// let tmpPreviousDomainTranslationAmount = '0';\n\t\t\t\t// for (let j = 0; j < tmpVariableDescription.ResolvedPoints.length; j++)\n\t\t\t\t// {\n\t\t\t\t// \tlet tmpResolvedPointValue = tmpVariableDescription.ResolvedPoints[j];\n\t\t\t\t// \t// Set the resolved point domain start\n\t\t\t\t// \ttmpVariableDescription.DomainTranslationAmount.push(this.fable.Math.dividePrecise(tmpResolvedPointValue, tmpVariableDescription.DomainLength));\n\t\t\t\t// \t// Push the previous translation amount as the start of this domain\n\t\t\t\t// \ttmpVariableDescription.ResolvedPointDomainStarts.push(tmpPreviousDomainTranslationAmount);\n\t\t\t\t// \t// Calculate the translation amount, for the start of the next domain\n\t\t\t\t// \ttmpPreviousDomainTranslationAmount = this.fable.Math.addPrecise(tmpPreviousDomainTranslationAmount, tmpVariableDescription.DomainLength);\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tfor (let i = 0; i <= Number(tmpSampleCount) - 1; i++)\n\t\t\t{\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\t// Generate each value from the array of values\n\t\t\t\tfor (let j = 0; j < tmpVariableKeys.length; j++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPointManifestHash = tmpVariableKeys[j];\n\t\t\t\t\tlet tmpPointManifest = tmpMonteCarloOutput.Values[tmpPointManifestHash];\n\n\t\t\t\t\t// Generate the value for this sample variable\n\t\t\t\t\tlet tmpPointValue = this.fable.Math.generateValueFromEasingDescription(tmpPointManifest);\n\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKeys[j]] = tmpPointValue;\n\t\t\t\t\ttmpPointManifest.ValueSequence.push(tmpPointValue);\n\n\t\t\t\t\t// We keep track of a distribution of generated values here for analysis later\n\t\t\t\t\tlet tmpDistributionRoundPrecision = tmpPointManifest.DistributionRoundPrecision || 0;\n\t\t\t\t\t// Log the value out\n\t\t\t\t\t//this.fable.log.info(`Monte Carlo variable ${tmpPointManifestHash} generated value ${tmpPointValue}`);\n\t\t\t\t\tlet tmpDistributionPointValue = this.fable.Math.roundPrecise(tmpPointValue, tmpDistributionRoundPrecision);\n\t\t\t\t\tif (!(tmpDistributionPointValue in tmpPointManifest.Distribution))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPointManifest.Distribution[tmpDistributionPointValue] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttmpPointManifest.Distribution[tmpDistributionPointValue] = tmpPointManifest.Distribution[tmpDistributionPointValue] + 1;\n\t\t\t\t}\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\t\t\t\ttmpMonteCarloOutput.Samples.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest ) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpMonteCarloOutput);\n\n\t\t\treturn tmpMonteCarloOutput;\n\t\t}\n\t\telse // For 'SOLVE' or anything else that didn't work\n\t\t{\n\t\t\t// This is where the data from variables gets marshaled into their symbols (from AppData or the like)\n\t\t\tthis.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpDataSourceObject, tmpResultsObject, pManifest);\n\t\t\t// Finally this is the expr solving method, which returns a string and also marshals it into tmpDataDestinationObject\n\t\t\treturn this.solvePostfixedExpression(tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, pManifest);\n\t\t}\n\t}\n}\n\nmodule.exports = FableServiceExpressionParser;\n\n},{\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer-DirectiveMutation.js\":160,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js\":161,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json\":162,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js\":163,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js\":164,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js\":165,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js\":166,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json\":167,\"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js\":168,\"fable-serviceproviderbase\":59}],159:[function(require,module,exports){\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nclass ExpressionParserOperationBase extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ExpressionParserOperationBase';\n\n\t\tthis.numberTest = /^-{0,1}\\d*\\.{0,1}\\d+$/;\n\n\t\tthis.ExpressionParser = false;\n\t}\n\n\tconnectExpressionParser(pExpressionParser)\n\t{\n\t\tthis.ExpressionParser = pExpressionParser;\n\t}\n\n\tgetTokenType(pToken)\n\t{\n\t\tif (pToken in this.ExpressionParser.tokenMap)\n\t\t{\n\t\t\treturn `Token.${this.ExpressionParser.tokenMap[pToken].Type}`;\n\t\t}\n\t\telse if ((pToken.length > 2) && (pToken[0] === '{') && (pToken[pToken.length-1] === '}'))\n\t\t{\n\t\t\treturn 'Token.StateAddress';\n\t\t}\n\t\telse if ((pToken.length > 1) && (pToken[0] === '\"') && (pToken[pToken.length-1] === '\"'))\n\t\t{\n\t\t\treturn 'Token.String';\n\t\t}\n\t\telse if (this.numberTest.test(pToken))\n\t\t{\n\t\t\treturn 'Token.Constant';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'Token.Symbol';\n\t\t}\n\t\t// Just for documentation sake:\n\t\t// There is a fifth token type, VirtualSymbol\n\t\t// This is a value that's added during solve and looked up by address in the VirtualSymbol object.\n\t}\n\n\tgetTokenContainerObject(pToken, pTokenType)\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tToken: pToken,\n\t\t\t\tType: (typeof(pTokenType) === 'undefined') ? this.getTokenType(pToken) : pTokenType,\n\t\t\t\tDescriptor: (pToken in this.ExpressionParser.tokenMap) ? this.ExpressionParser.tokenMap[pToken] : false\n\t\t\t});\n\t}\n}\n\nmodule.exports = ExpressionParserOperationBase;\n},{\"fable-serviceproviderbase\":59}],160:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionTokenizerDirectiveMutation extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-TokenizerDirectiveMutation';\n\n\t\tthis.directiveTypes = (\n\t\t\t{\n\t\t\t\t'SOLVE': { Name: 'Solve Expression', Code: 'SOLVE' },\n\t\t\t\t'SERIES': { Name: 'Series', Code: 'SERIES', From: null, To: null, Step: null },\n\t\t\t\t'MONTECARLO': { Name: 'Monte Carlo Simulation', SampleCount: '1', Code: 'MONTECARLO', Values: {} },\n\t\t\t\t'MAP': { Name: 'Map', Code: 'MAP', Values: {}, ValueKeys: [] },\n\t\t\t});\n\n\t\tthis.defaultDirective = this.directiveTypes.SOLVE;\n\t}\n\n\tparseSeriesDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewSeriesDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.SERIES));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'FROM':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.From = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TO':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.To = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'STEP':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.Step = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewSeriesDirectiveDescription;\n\t}\n\n\tparseMonteCarloDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewMonteCarloDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.MONTECARLO));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'SAMPLECOUNT':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.SampleCount = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VARIABLE':\n\t\t\t\tcase 'VAR':\n\t\t\t\tcase 'V':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\t\tif (typeof(tmpVariableToken) === 'string' && (tmpVariableToken.length > 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken] = \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tToken: tmpVariableToken,\n\t\t\t\t\t\t\t\tEasing: 'Linear', // could be parametric, logarithmic, bezier, uniform, normal, etc.\n\t\t\t\t\t\t\t\tPoints: [] // array of values for points to generate between.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'POINT':\n\t\t\t\tcase 'PT':\n\t\t\t\tcase 'P':\n\t\t\t\t\tif (pTokens.length < i + 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpTokenIndexSkip = 2;\n\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\tif (tmpVariableToken in tmpNewMonteCarloDirectiveDescription.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableValueString = pTokens[i + 2];\n\t\t\t\t\t\tif ((tmpVariableValueString == '-') || (tmpVariableValueString == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pTokens.length < i + 3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpVariableValueString = tmpVariableValueString + pTokens[i + 3];\n\t\t\t\t\t\t\ttmpTokenIndexSkip = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet tmpVariableValue = this.fable.Math.parsePrecise(tmpVariableValueString, NaN);\n\t\t\t\t\t\tif (!isNaN(tmpVariableValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken].Points.push(tmpVariableValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = i + tmpTokenIndexSkip;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EASING':\n\t\t\t\t\tif (pTokens.length < i + 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpVariableToken = pTokens[i + 1];\n\t\t\t\t\tlet tmpEasingType = pTokens[i + 2].toUpperCase();\n\t\t\t\t\tif (tmpVariableToken in tmpNewMonteCarloDirectiveDescription.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken].Easing = tmpEasingType;\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewMonteCarloDirectiveDescription;\n\t}\n\n\tparseMapDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewMapDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.MAP));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'VARIABLE':\n\t\t\t\tcase 'VAR':\n\t\t\t\tcase 'V':\n\t\t\t\t\tif (((i + 3) < pTokens.length) && (pTokens[i+2].toUpperCase() == 'FROM'))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\t\tif (typeof(tmpVariableToken) === 'string' && (tmpVariableToken.length > 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMapDirectiveDescription.ValueKeys.push(tmpVariableToken);\n\t\t\t\t\t\t\ttmpNewMapDirectiveDescription.Values[tmpVariableToken] = \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tToken: tmpVariableToken,\n\t\t\t\t\t\t\t\tAddress: pTokens[i + 3],\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti = i + 3;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewMapDirectiveDescription;\n\t}\n\n\tparseDirectives(pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.SolverDirectives = this.defaultDirective;\n\t\ttmpResults.SolverDirectiveTokens = [];\n\n\t\tif (tmpResults.RawTokens.length < 2)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation postprocessor received insufficient tokens to process directives.`);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn tmpResults.SolverDirectives;\n\t\t}\n\n\t\t// Enumerate each of the tmpResults.RawTokens to see if one of the values in the directiveTypeMap exists and is either at the beginning or after the assignment (= or ?=) operator\n\t\tfor (let i = 0; i < tmpResults.RawTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = tmpResults.RawTokens[i].toUpperCase();\n\t\t\tif (tmpToken in this.directiveTypes)\n\t\t\t{\n\t\t\t\t// Check if it's at the beginning or after an assignment operator\n\t\t\t\t// FIXME: This is hard coded assignment operators which is bad juju\n\t\t\t\tif ((i === 0) || (tmpResults.RawTokens[i-1] === '=') || (tmpResults.RawTokens[i-1] === '?='))\n\t\t\t\t{\n\t\t\t\t\t// We have a directive!\n\t\t\t\t\ttmpResults.SolverDirectives.Type = this.directiveTypes[tmpToken];\n\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation identified solver directive: ${tmpToken}`);\n\t\t\t\t\t//this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\n\t\t\t\t\t// Extract the Directive name and everything else from it up until the : token\n\t\t\t\t\tlet tmpDirectiveTokenStartIndex = i;\n\t\t\t\t\tlet tmpDirectiveTokenEndIndex = -1;\n\t\t\t\t\tfor (let j = tmpDirectiveTokenStartIndex + 1; j < tmpResults.RawTokens.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpResults.RawTokens[j] === ':')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDirectiveTokenEndIndex = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the directive token end is not in the expression we don't know what to do\n\t\t\t\t\tif (tmpDirectiveTokenEndIndex === -1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation could not find the end of the directive token set for directive: ${tmpToken}`);\n\t\t\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the tmpResults.SolverDirectiveTokens to the slice of tokens that represent the directive\n\t\t\t\t\ttmpResults.SolverDirectiveTokens = tmpResults.RawTokens.slice(tmpDirectiveTokenStartIndex, tmpDirectiveTokenEndIndex);\n\n\t\t\t\t\t// Remove the directive tokens and the assignment to the left of it from the array of raw tokens\n\t\t\t\t\t// the colonoscopy if you will\n\t\t\t\t\ttmpResults.RawTokens.splice(0, tmpDirectiveTokenEndIndex + 1);\n\n\t\t\t\t\t// Further parsing based on directive type could go here\n\t\t\t\t\t// e.g. parseSeriesDirective for SERIES, etc.\n\t\t\t\t\tswitch(tmpToken)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'SERIES':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseSeriesDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MONTECARLO':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseMonteCarloDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MAP':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseMapDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// No further parsing needed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResults.SolverDirectives;\n\t}\n}\n\nmodule.exports = ExpressionTokenizerDirectiveMutation;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159}],161:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionTokenizer extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Tokenizer';\n\t}\n\n\ttokenize(pExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.RawExpression = pExpression;\n\t\ttmpResults.SolverDirectives = {};\n\t\ttmpResults.RawTokens = [];\n\t\ttmpResults.ExpressionParserLog = [];\n\n\t\tif (typeof(pExpression) !== 'string')\n\t\t{\n\t\t\tthis.log.warn('ExpressionParser.tokenize was passed a non-string expression.');\n\t\t\treturn tmpResults.RawTokens;\n\t\t}\n\n\t\t/* Tokenize the expression\n\t\t *\n\t\t * Current token types:\n\t\t * \t- Value\n\t\t *    : could be a symbol representation e.g. \"x\", \"depth\", \"Cost\", etc. --- symbol representations are looked up first as manifest hashes\n\t\t *    : could be a number e.g. \"5\", \"3.14159\", etc.\n\t\t *    : could be a function name e.g. sin(x), sqrt(3+5) where sin or sqrt are known function names\n\t\t *  - StateAddress\n\t\t *    : these are always wrapped in squiggly brackets\n\t\t *    : e.g. {Moisture.Percentage}, {Ending.Temperature.Fahrenheit}, {AppData.Download.Size}, etc.\n\t\t *  - Token\n\t\t *    : could be an operator e.g. \"+\", \"-\", \"*\", \"/\"\n\t\t *    : could be a parenthesis e.g. \"(\", \")\"\n\t\t *  - String\n\t\t *    : Wrapped in double quotes e.g. \"Hello World\", \"This is a test\", etc.\n\t\t */\n\t\t/** @type {any} */\n\t\tlet tmpCurrentTokenType = false;\n\t\tlet tmpCurrentToken = '';\n\t\tfor (let i = 0; i < pExpression.length; i++)\n\t\t{\n\t\t\tlet tmpCharacter = pExpression[i];\n\n\t\t\t// [ WHITESPACE ]\n\t\t\t// 1. Space breaks tokens except when we're in an address that's been scoped by a {} or \"\"\n\t\t\tif ((tmpCharacter === ' ' || tmpCharacter === '\\t') && ((tmpCurrentTokenType !== 'StateAddress') && (tmpCurrentTokenType !== 'String')))\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// [ STATE ADDRESS AND STRING BLOCKS ]\n\t\t\t// 2. If we're in an address, we keep going until we hit the closing brace\n\t\t\tif ((tmpCurrentTokenType === 'StateAddress') && (tmpCharacter !== '}'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType === 'String') && (tmpCharacter !== '\"'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 3. If we're in an address and we hit the closing brace, we close the token, push it and reset\n\t\t\tif ((tmpCurrentTokenType === 'StateAddress') && (tmpCharacter === '}'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType === 'String') && (tmpCharacter === '\"'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 4. If we're not in an address and we hit a closing brace it's a problem\n\t\t\t//    TODO: Should we just ignore it?  We do at the moment.\n\t\t\tif (tmpCharacter == '}')\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenize found a closing brace without an opening brace in the expression: ${pExpression} at character index ${i}`);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 5. If we're not in an address and we hit an opening brace, we start an address\n\t\t\tif (tmpCharacter == '{')\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = 'StateAddress';\n\t\t\t\ttmpCurrentToken = tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType !== 'String') && (tmpCharacter == '\"'))\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = 'String';\n\t\t\t\ttmpCurrentToken = tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// [ TOKENS ]\n\t\t\tif (tmpCharacter in this.ExpressionParser.tokenRadix)\n\t\t\t{\n\t\t\t\tlet tmpTokenRadix = this.ExpressionParser.tokenRadix[tmpCharacter];\n\t\t\t\t// If the token is a literal and has only one entry, it is a single character token and we can just safely add it.\n\t\t\t\tif (tmpTokenRadix.TokenCount == 1 && tmpTokenRadix.Literal)\n\t\t\t\t{\n\t\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t\t}\n\t\t\t\t\ttmpCurrentToken = '';\n\t\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCharacter);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// This one has multiple options, so literals don't matter.  We need to check the token map.\n\t\t\t\t\t// The token radix TokenKeys array is sorted longest to shortest\n\t\t\t\t\tfor (let j = 0; j < tmpTokenRadix.TokenKeys.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpTokenKey = tmpTokenRadix.TokenKeys[j];\n\t\t\t\t\t\tif (pExpression.substr(i, tmpTokenKey.length) == tmpTokenKey)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpResults.RawTokens.push(tmpTokenKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpCurrentToken = '';\n\t\t\t\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\t\t\t\ttmpResults.RawTokens.push(tmpTokenKey);\n\t\t\t\t\t\t\ti += tmpTokenKey.length - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If it's not an operator, it's a number or address.\n\t\t\t// At the moment we aren't going to gate it on whether it's a valid address or not\n\t\t\t// Just treat anything not a known token on its own as a value identifier\n\n\t\t\t/* Per this stack overflow article: https://stackoverflow.com/questions/4434076/best-way-to-alphanumeric-check-in-javascript\n\t\t\t * We could use a regex but it is slower than the charCodeAt method.\n\t\t\t * This also doesn't solve the problem of unicode characters, but we won't support those for now.\n\t\t\t */\n\t\t\t// if (pExpression.charAt(i) == '.')\n\t\t\t// {\n\t\t\t// \tconsole.log('Found a period')\n\t\t\t// }\n\t\t\t// let tmpCharCode = pExpression.charCodeAt(i);\n\t\t\t// // Match that the character code is any of...\n\t\t\t// if (\n\t\t\t// \t// Number [0-9]\n\t\t\t// \t(tmpCharCode > 47 && tmpCharCode < 58)\n\t\t\t// \t// Upper Case\n\t\t\t// \t|| (tmpCharCode > 64 && tmpCharCode < 91)\n\t\t\t// \t// LOWER CASE\n\t\t\t// \t|| (tmpCharCode > 96 && tmpCharCode < 123)\n\t\t\t// \t)\n\t\t\t// {\n\n\t\t\t\t// NOTE: Not having this guard makes a lot of interesting things possible.\n\t\t\ttmpCurrentTokenType = 'Value';\n\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t// \tcontinue;\n\t\t\t// }\n\n\t\t\t// tmpResults.ExpressionParserLog.push(`ExpressionParser.tokenize found an unknown character code ${tmpCharCode} character ${tmpCharacter} in the expression: ${pExpression} at index ${i}`);\n\t\t\t// this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\tif ((tmpCurrentTokenType) && (tmpCurrentToken.length > 0))\n\t\t{\n\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t}\n\n\t\ttmpResults.OriginalRawTokens = Array.from(tmpResults.RawTokens);\n\n\t\t// Potentially mutate the tokens based on directives in the tokenized expression\n\t\tthis.TokenizerDirectiveMutation.parseDirectives(tmpResults);\n\n\t\treturn tmpResults.RawTokens;\n\t}\n}\n\nmodule.exports = ExpressionTokenizer;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159}],162:[function(require,module,exports){\nmodule.exports={\n\t\"sqrt\": {\n\t\t\"Name\": \"Square Root\",\n\t\t\"Address\": \"fable.Math.sqrtPrecise\"\n\t},\n\n\t\"percent\": {\n\t\t\"Name\": \"Compute Percent (in IS over OF format)\",\n\t\t\"Address\": \"fable.Math.percentagePrecise\"\n\t},\n\n\t\"compare\": {\n\t\t\"Name\": \"Compare\",\n\t\t\"Address\": \"fable.Math.comparePrecise\"\n\t},\n\n\t\"abs\": {\n\t\t\"Name\": \"Absolute Value\",\n\t\t\"Address\": \"fable.Math.absPrecise\"\n\t},\n\t\"floor\": {\n\t\t\"Name\": \"Floor Value\",\n\t\t\"Address\": \"fable.Math.floorPrecise\"\n\t},\n\t\"ceil\": {\n\t\t\"Name\": \"Ceiling Value\",\n\t\t\"Address\": \"fable.Math.ceilPrecise\"\n\t},\n\n\t\"rad\": {\n\t\t\"Name\": \"Degrees to Radians\",\n\t\t\"Address\": \"fable.Math.radPrecise\"\n\t},\n\n\t\"pi\": {\n\t\t\"Name\": \"Pi\",\n\t\t\"Address\": \"fable.Math.piPrecise\"\n\t},\n\t\"euler\": {\n\t\t\"Name\": \"Euler\",\n\t\t\"Address\": \"fable.Math.eulerPrecise\"\n\t},\n\n\t\"log\": {\n\t\t\"Name\": \"Logarithm\",\n\t\t\"Address\": \"fable.Math.logPrecise\"\n\t},\n\t\"exp\": {\n\t\t\"Name\": \"Eulers Number to the Power Of N\",\n\t\t\"Address\": \"fable.Math.expPrecise\"\n\t},\n\n\n\t\"sin\": {\n\t\t\"Name\": \"Sine\",\n\t\t\"Address\": \"fable.Math.sin\"\n\t},\n\t\"cos\": {\n\t\t\"Name\": \"Cosine\",\n\t\t\"Address\": \"fable.Math.cos\"\n\t},\n\t\"tan\": {\n\t\t\"Name\": \"Tangent\",\n\t\t\"Address\": \"fable.Math.tan\"\n\t},\n\n\t\"count\": {\n\t\t\"Name\": \"Count Set Elements\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\t\"countset\": {\n\t\t\"Name\": \"Count Set Elements\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\t\"sortset\": {\n\t\t\"Name\": \"Sort Set\",\n\t\t\"Address\": \"fable.Math.sortSetPrecise\"\n\t},\n\t\"bucketset\": {\n\t\t\"Name\": \"Bucket Set\",\n\t\t\"Address\": \"fable.Math.bucketSetPrecise\"\n\t},\n\t\"sorthistogram\": {\n\t\t\"Name\": \"Sort Histogram\",\n\t\t\"Address\": \"fable.Math.sortHistogramPrecise\"\n\t},\n\t\"sorthistogrambykeys\": {\n\t\t\"Name\": \"Sort Histogram by Keys\",\n\t\t\"Address\": \"fable.Math.sortHistogramByKeys\"\n\t},\n\n\t\"max\": {\n\t\t\"Name\": \"Maximum\",\n\t\t\"Address\": \"fable.Math.maxPrecise\"\n\t},\n\t\"min\": {\n\t\t\"Name\": \"Minimum\",\n\t\t\"Address\": \"fable.Math.minPrecise\"\n\t},\n\n\t\"sum\": {\n\t\t\"Name\": \"Sum\",\n\t\t\"Address\": \"fable.Math.sumPrecise\"\n\t},\n\n\t\"avg\": {\n\t\t\"Name\": \"Average\",\n\t\t\"Address\": \"fable.Math.averagePrecise\"\n\t},\n\t\"mean\": {\n\t\t\"Name\": \"Mean\",\n\t\t\"Address\": \"fable.Math.meanPrecise\"\n\t},\n\t\"median\": {\n\t\t\"Name\": \"Median\",\n\t\t\"Address\": \"fable.Math.medianPrecise\"\n\t},\n\t\"mode\": {\n\t\t\"Name\": \"Mode\",\n\t\t\"Address\": \"fable.Math.modePrecise\"\n\t},\n\t\"var\": {\n\t\t\"Name\": \"Variance (Sample)\",\n\t\t\"Address\": \"fable.Math.variancePrecise\"\n\t},\n\t\"vara\": {\n\t\t\"Name\": \"Variance (Sample)\",\n\t\t\"Address\": \"fable.Math.variancePrecise\"\n\t},\n\t\"varp\": {\n\t\t\"Name\": \"Variance (Population)\",\n\t\t\"Address\": \"fable.Math.populationVariancePrecise\"\n\t},\n\t\"stdev\": {\n\t\t\"Name\": \"Standard Deviation (Sample)\",\n\t\t\"Address\": \"fable.Math.standardDeviationPrecise\"\n\t},\n\t\"stdeva\": {\n\t\t\"Name\": \"Standard Deviation (Sample)\",\n\t\t\"Address\": \"fable.Math.standardDeviationPrecise\"\n\t},\n\t\"stdevp\": {\n\t\t\"Name\": \"Standard Deviation (Population)\",\n\t\t\"Address\": \"fable.Math.populationStandardDeviationPrecise\"\n\t},\n\t\"round\": {\n\t\t\"Name\": \"Round\",\n\t\t\"Address\": \"fable.Math.roundPrecise\"\n\t},\n\t\"tofixed\": {\n\t\t\"Name\": \"To Fixed\",\n\t\t\"Address\": \"fable.Math.toFixedPrecise\"\n\t},\n\n\t\"cumulativesummation\": {\n\t\t\"Name\": \"Sum each value in a Histogram or Value Map cumulatively, creating or setting a property with the result on each row\",\n\t\t\"Address\": \"fable.Math.cumulativeSummation\"\n\t},\n\n\t\"subtractingsummation\": {\n\t\t\"Name\": \"Subtract each subsequent value in a Histogram or Value Map cumulatively (by default from the first row), creating or setting a property with the result on each row.\",\n\t\t\"Address\": \"fable.Math.subtractingSummation\"\n\t},\n\n\t\"iterativeseries\": {\n\t\t\"Name\": \"Perform an Iterative Series of Mathematical Operations on Set Elements\",\n\t\t\"Address\": \"fable.Math.iterativeSeries\"\n\t},\n\n\t\"countsetelements\": {\n\t\t\"Name\": \"Count Set Elements in a Histogram or Value Map\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\n\t\"getvalue\": {\n\t\t\"Name\": \"Get Value from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.getInternalValueByHash\"\n\t},\n\n\t\"setvalue\": {\n\t\t\"Name\": \"Set Value to Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.setInternalValueByHash\"\n\t},\n\n\t\"objectkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"objectvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\t\"generatearrayofobjectsfromsets\": {\n\t\t\"Name\": \"Generate Array of Objects from Sets\",\n\t\t\"Address\": \"fable.Utility.generateArrayOfObjectsFromSets\"\n\t},\n\t\"objectvaluessortbyexternalobjectarray\": {\n\t\t\"Name\": \"Get Array of an Object's values sorted by an external array\",\n\t\t\"Address\": \"fable.Utility.objectValuesSortByExternalArray\"\n\t},\n\t\"setkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"setvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\t\"histogramkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"histogramvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\n\t\"createarrayfromabsolutevalues\": {\n\t\t\"Name\": \"Create Array from Absolute Values\",\n\t\t\"Address\": \"fable.Utility.createArrayFromAbsoluteValues\"\n\t},\n\n\t\"flatten\": {\n\t\t\"Name\": \"flatten an array of values\",\n\t\t\"Address\": \"fable.Utility.flattenArrayOfSolverInputs\"\n\t},\n\n\t\"findfirstvaluebyexactmatch\": {\n\t\t\"Name\": \"find + map on array of objects\",\n\t\t\"Address\": \"fable.Utility.findFirstValueByExactMatchInternal\"\n\t},\n\n\t\"findfirstvaluebystringincludes\": {\n\t\t\"Name\": \"find + map on array of objects\",\n\t\t\"Address\": \"fable.Utility.findFirstValueByStringIncludesInternal\"\n\t},\n\n\t\"match\": {\n\t\t\"Name\": \"Implementation of sheets MATCH() function\",\n\t\t\"Address\": \"fable.Utility.findIndexInternal\"\n\t},\n\n\t\"resolvehtmlentities\": {\n\t\t\"Name\": \"resolve HTML entities\",\n\t\t\"Address\": \"fable.DataFormat.resolveHtmlEntities\"\n\t},\n\n\t\"concat\": {\n\t\t\"Name\": \"concatenate an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.concatenateStringsInternal\"\n\t},\n\n\t\"concatraw\": {\n\t\t\"Name\": \"concatenate an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.concatenateStringsRawInternal\"\n\t},\n\n\t\"arrayconcat\": {\n\t\t\"Name\": \"concatenate two or more arrays generating a single output array\",\n\t\t\"Address\": \"fable.Utility.concatenateArrays\"\n\t},\n\n\t\"join\": {\n\t\t\"Name\": \"join an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.joinStringsInternal\"\n\t},\n\n\t\"joinraw\": {\n\t\t\"Name\": \"join an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.joinStringsRawInternal\"\n\t},\n\n\t\"if\": {\n\t\t\"Name\": \"perform a conditional operator on two values, and choose one of two outcomes based on the result\",\n\t\t\"Address\": \"fable.Logic.checkIf\"\n\t},\n\n\t\"when\": {\n\t\t\"Name\": \"perform a 'truthy' check on one value, and return one of two outcomes based on the result\",\n\t\t\"Address\": \"fable.Logic.when\"\n\t},\n\n\t\"entryinset\": {\n\t\t\"Name\": \"Entry in Set\",\n\t\t\"Address\": \"fable.Math.entryInSet\"\n\t},\n\t\"smallestinset\": {\n\t\t\"Name\": \"Smallest in Set\",\n\t\t\"Address\": \"fable.Math.smallestInSet\"\n\t},\n\t\"largestinset\": {\n\t\t\"Name\": \"Largest in Set\",\n\t\t\"Address\": \"fable.Math.largestInSet\"\n\t},\n\n\t\"aggregationhistogram\": {\n\t\t\"Name\": \"Generate a Histogram by Exact Value Aggregation\",\n\t\t\"Address\": \"fable.Math.histogramAggregationByExactValueFromInternalState\"\n\t},\n\t\"aggregationhistogrambyobject\": {\n\t\t\"Name\": \"Generate a Histogram by Exact Value Aggregation from Object Property\",\n\t\t\"Address\": \"fable.Math.histogramAggregationByExactValue\"\n\t},\n\t\"distributionhistogram\": {\n\t\t\"Name\": \"Generate a Histogram Based on Value Distribution\",\n\t\t\"Address\": \"fable.Math.histogramDistributionByExactValueFromInternalState\"\n\t},\n\t\"distributionhistogrambyobject\": {\n\t\t\"Name\": \"Generate a Histogram Based on Value Distribution from Object Property\",\n\t\t\"Address\": \"fable.Math.histogramDistributionByExactValue\"\n\t},\n\n\t\"setconcatenate\": {\n\t\t\"Name\": \"Set Concatenate\",\n\t\t\"Address\": \"fable.Math.setConcatenate\"\n\t},\n\n\t\"getvaluearray\": {\n\t\t\"Name\": \"Get Value Array from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.createValueArrayByHashParametersFromInternal\"\n\t},\n\t\"getvalueobject\": {\n\t\t\"Name\": \"Get Value Object from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.createValueObjectByHashParametersFromInternal\"\n\t},\n\n\t\"cleanvaluearray\": {\n\t\t\"Name\": \"Clean Value Array\",\n\t\t\"Address\": \"fable.Math.cleanValueArray\"\n\t},\n\t\"cleanvalueobject\": {\n\t\t\"Name\": \"Clean Value Object\",\n\t\t\"Address\": \"fable.Math.cleanValueObject\"\n\t},\n\n\t\"polynomialregression\": {\n\t\t\"Name\": \"Perform an nth degree Polynomial Regression on a Set of X and Y Values\",\n\t\t\"Address\": \"fable.Math.polynomialRegression\"\n\t},\n\n\t\"randominteger\": {\n\t\t\"Name\": \"Random Integer\",\n\t\t\"Address\": \"fable.DataGeneration.randomInteger\"\n\t},\n\t\"randomintegerbetween\": {\n\t\t\"Name\": \"Random Integer Between Two Numbers\",\n\t\t\"Address\": \"fable.DataGeneration.randomIntegerBetween\"\n\t},\n\t\"randomintegerupto\": {\n\t\t\"Name\": \"Random Integer\",\n\t\t\"Address\": \"fable.DataGeneration.randomIntegerUpTo\"\n\t},\n\t\"randomfloat\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloat\"\n\t},\n\t\"randomfloatbetween\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloatBetween\"\n\t},\n\t\"randomfloatupto\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloatUpTo\"\n\t},\n\n\t\"datemilliseconddifference\": {\n\t\t\"Name\": \"Date Difference in Milliseconds\",\n\t\t\"Address\": \"fable.Dates.dateMillisecondDifference\"\n\t},\n\t\"dateseconddifference\": {\n\t\t\"Name\": \"Date Difference in Seconds\",\n\t\t\"Address\": \"fable.Dates.dateSecondDifference\"\n\t},\n\t\"dateminutedifference\": {\n\t\t\"Name\": \"Date Difference in Minutes\",\n\t\t\"Address\": \"fable.Dates.dateMinuteDifference\"\n\t},\n\t\"datehourdifference\": {\n\t\t\"Name\": \"Date Difference in Hours\",\n\t\t\"Address\": \"fable.Dates.dateHourDifference\"\n\t},\n\t\"datedaydifference\": {\n\t\t\"Name\": \"Date Difference in Days\",\n\t\t\"Address\": \"fable.Dates.dateDayDifference\"\n\t},\n\t\"dateweekdifference\": {\n\t\t\"Name\": \"Date Difference in Weeks\",\n\t\t\"Address\": \"fable.Dates.dateWeekDifference\"\n\t},\n\t\"datemonthdifference\": {\n\t\t\"Name\": \"Date Difference in Months\",\n\t\t\"Address\": \"fable.Dates.dateMonthDifference\"\n\t},\n\t\"dateyeardifference\": {\n\t\t\"Name\": \"Date Difference in Years\",\n\t\t\"Address\": \"fable.Dates.dateYearDifference\"\n\t},\n\n\t\"datemathadd\": {\n\t\t\"Name\": \"Date Math Add\",\n\t\t\"Address\": \"fable.Dates.dateMath\"\n\t},\n\t\"dateaddmilliseconds\": {\n\t\t\"Name\": \"Date Add Milliseconds\",\n\t\t\"Address\": \"fable.Dates.dateAddMilliseconds\"\n\t},\n\t\"dateaddseconds\": {\n\t\t\"Name\": \"Date Add Seconds\",\n\t\t\"Address\": \"fable.Dates.dateAddSeconds\"\n\t},\n\t\"dateaddminutes\": {\n\t\t\"Name\": \"Date Add Minutes\",\n\t\t\"Address\": \"fable.Dates.dateAddMinutes\"\n\t},\n\t\"dateaddhours\": {\n\t\t\"Name\": \"Date Add Hours\",\n\t\t\"Address\": \"fable.Dates.dateAddHours\"\n\t},\n\t\"dateadddays\": {\n\t\t\"Name\": \"Date Add Days\",\n\t\t\"Address\": \"fable.Dates.dateAddDays\"\n\t},\n\t\"dateaddweeks\": {\n\t\t\"Name\": \"Date Add Weeks\",\n\t\t\"Address\": \"fable.Dates.dateAddWeeks\"\n\t},\n\t\"dateaddmonths\": {\n\t\t\"Name\": \"Date Add Months\",\n\t\t\"Address\": \"fable.Dates.dateAddMonths\"\n\t},\n\t\"dateaddyears\": {\n\t\t\"Name\": \"Date Add Years\",\n\t\t\"Address\": \"fable.Dates.dateAddYears\"\n\t},\n\n\t\"datefromparts\": {\n\t\t\"Name\": \"Date From Parts\",\n\t\t\"Address\": \"fable.Dates.dateFromParts\"\n\t},\n\n\t\"slice\": {\n\t\t\"Name\": \"Slice Array\",\n\t\t\"Address\": \"fable.Utility.slice\"\n\t},\n\n\t\"createvalueobjectbyhashes\": {\n\t\t\"Name\": \"Create Value Object by Hashes\",\n\t\t\"Address\": \"fable.Utility.createValueObjectByHashes\"\n\t},\n\n\t\"polynomialregression\": {\n\t\t\"Name\": \"Perform an nth degree Polynomial Regression on a Set of X and Y Values\",\n\t\t\"Address\": \"fable.Math.polynomialRegression\"\n\t},\n\t\"leastsquares\": {\n\t\t\"Name\": \"Perform a Least Squares Regression on a Set of Independent Variable Vectors and a Dependent Variable Vector\",\n\t\t\"Address\": \"fable.Math.leastSquares\"\n\t},\n\t\"linest\": {\n\t\t\"Name\": \"Perform a Least Squares Regression on a Set of Independent Variable Vectors and a Dependent Variable Vector\",\n\t\t\"Address\": \"fable.Math.leastSquares\"\n\t},\n\n\t\"matrixtranspose\": {\n\t\t\"Name\": \"Transpose a Matrix\",\n\t\t\"Address\": \"fable.Math.matrixTranspose\"\n\t},\n\t\"matrixmultiply\": {\n\t\t\"Name\": \"Multiply Two Matrices\",\n\t\t\"Address\": \"fable.Math.matrixMultiply\"\n\t},\n\t\"matrixvectormultiply\": {\n\t\t\"Name\": \"Multiply a Matrix by a Vector\",\n\t\t\"Address\": \"fable.Math.matrixVectorMultiply\"\n\t},\n\t\"matrixinverse\": {\n\t\t\"Name\": \"Inverse a Matrix\",\n\t\t\"Address\": \"fable.Math.matrixInverse\"\n\t},\n\t\"gaussianelimination\": {\n\t\t\"Name\": \"Solve a System of Linear Equations using Gaussian Elimination\",\n\t\t\"Address\": \"fable.Math.gaussianElimination\"\n\t},\n\t\"predict\": {\n\t\t\"Name\": \"Predict Y Values from X Values using a Regression Model\",\n\t\t\"Address\": \"fable.Math.predictFromRegressionModel\"\n\t},\n\n\t\"stringcountsegments\": {\n\t\t\"Name\": \"Count Segments in a String\",\n\t\t\"Address\": \"fable.DataFormat.stringCountSegments\"\n\t},\n\t\"stringgetsegments\": {\n\t\t\"Name\": \"Get Segments from a String\",\n\t\t\"Address\": \"fable.DataFormat.stringGetSegments\"\n\t},\n\n\t\"bezierpoint\": {\n\t\t\"Name\": \"Evaluate a Point on a Cubic Bezier Curve at Parameter t\",\n\t\t\"Address\": \"fable.Math.bezierPoint\"\n\t},\n\t\"beziercurvefit\": {\n\t\t\"Name\": \"Fit a Cubic Bezier Curve to a Set of Data Points\",\n\t\t\"Address\": \"fable.Math.bezierCurveFit\"\n\t}\n}\n\n},{}],163:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserLinter extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Linter';\n\t}\n\n\tlintTokenizedExpression(pTokenizedExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.LinterResults = [];\n\n\t\t// Guard against bad data being passed in\n\t\tif (!Array.isArray(pTokenizedExpression))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression was passed a non-array tokenized expression.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedExpression;\n\t\t}\n\t\tif (pTokenizedExpression.length < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression was passed an empty tokenized expression.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedExpression;\n\t\t}\n\n\t\t// 1. Check for balanced parenthesis\n\t\tlet tmpParenthesisDepth = 0;\n\t\t// If it is in a state address, we don't care about the parenthesis\n\t\t// State addresses are between squiggly brackets\n\t\tlet tmpInStateAddress = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((pTokenizedExpression[i] === '(') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpParenthesisDepth++;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === ')') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpParenthesisDepth--;\n\t\t\t}\n\n\t\t\tif (pTokenizedExpression[i] === '{')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = true;\n\t\t\t}\n\t\t\tif (pTokenizedExpression[i] === '}')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = false;\n\t\t\t}\n\n\t\t\tif (tmpParenthesisDepth < 0)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression at token index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\t\t}\n\t\tif (tmpParenthesisDepth > 0)\n\t\t{\n\t\t\t// TODO: Should we add the closing parenthesis?\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression (ended without closing last set of parenthesis) -- appropriate closing parenthesis will be added.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\t// 2. Check for balanced squiggly braces\n\t\ttmpInStateAddress = false;\n\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif (pTokenizedExpression[i] === '{')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = true;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === '}') && (tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpInStateAddress = false;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === '}') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced closing squiggly brace \"}\" in the tokenized expression at token index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\n\t\t\tif (tmpInStateAddress)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found an open squiggly brace in the tokenized expression at index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\t\t}\n\n\t\t// 3. Check for an equality assignment\n\t\tlet tmpEqualityAssignmentCount = 0;\n\t\tlet tmpEqualityAssignmentIndex = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((this.ExpressionParser.tokenMap[pTokenizedExpression[i]]) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type === 'Assignment'))\n\t\t\t{\n\t\t\t\ttmpEqualityAssignmentCount++;\n\t\t\t\ttmpEqualityAssignmentIndex = i;\n\n\t\t\t\tif (tmpEqualityAssignmentCount > 1)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found multiple equality assignments in the tokenized expression; equality assignment #${tmpEqualityAssignmentCount} operator '${pTokenizedExpression[i]}' at token index ${i}.`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tmpEqualityAssignmentCount < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found no equality assignment in the tokenized expression.  One called Result will be added automatically.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\t// 4. Make sure the equality assignment only has a single value on the other side of it\n\t\t//    (no, this is not a magical algebraic solver, do your own simplification)\n\t\t//    IF there is only one equality assignment (otherwise we don't even lint this because it's syntax errors all the way down)\n\t\tif (tmpEqualityAssignmentCount === 1)\n\t\t{\n\t\t\t// If there are exactly three tokens, make sure at least one is an assignable-ish address\n\t\t\t// This can still fail, but we aren't linting all the way into the manifest here; just the expression\n\t\t\tif (pTokenizedExpression.length === 3)\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\t// The first token in our expression is a potentially assignable symbol\n\t\t\t\t\t(this.getTokenType(pTokenizedExpression[0]) === 'Token.StateAddress') || (this.getTokenType(pTokenizedExpression[2]) === 'Token.Symbol')\n\t\t\t\t\t// NOTE: For now we are only going to support assignment to the first symbol in the expression, which seems okay.\n\t\t\t\t\t// OR the last token in our expression is a potentially assignable symbol\n\t\t\t\t\t//|| (this.getTokenType(pTokenizedExpression[2]) === 'Token.StateAddress') || (this.getTokenType(pTokenizedExpression[0]) === 'Token.Symbol')\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found a single equality assignment in the tokenized expression with no assignable address on the left side of the assignment.`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5. Check that there are no operators adjacent to each other\n\t\t//    This is a simple lint check, not a full-blown syntax check\n\t\tlet tmpTokenPrevious = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length - 1; i++)\n\t\t{\n\t\t\tif ((pTokenizedExpression[i] in this.ExpressionParser.tokenMap) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type != 'Parenthesis') && !tmpTokenPrevious)\n\t\t\t{\n\t\t\t\ttmpTokenPrevious = true;\n\t\t\t}\n\t\t\telse if ((pTokenizedExpression[i] in this.ExpressionParser.tokenMap) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type != 'Parenthesis'))\n\t\t\t{\n\t\t\t\t// If this isn't a + or - positivity/negativity multiplier, it's an error.\n\t\t\t\tif ((pTokenizedExpression[i] !== '+') && (pTokenizedExpression[i] !== '-'))\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an ${pTokenizedExpression[i]} operator adjacent to another operator in the tokenized expression at token index ${i}`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpTokenPrevious = false;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResults.LinterResults;\n\t}\n}\n\nmodule.exports = ExpressionParserLinter;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159}],164:[function(require,module,exports){\nconst { PE } = require('big.js');\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\n/**\n * Represents a user-friendly messaging service for the ExpressionParser compiler output.\n * @class ExpressionParserMessaging\n * @extends libExpressionParserOperationBase\n */\nclass ExpressionParserMessaging extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Messaging';\n\t}\n\n\tgetOperationVirtualSymbolName(pOperationToken)\n\t{\n\t\treturn (pOperationToken && ('VirtualSymbolName' in pOperationToken)) ? pOperationToken.VirtualSymbolName \n\t\t\t: (pOperationToken.Type === 'Token.VirtualSymbol') ? pOperationToken.Token\n\t\t\t: 'NO_VIRTUAL_SYMBOL_NAME_FOUND';\n\t}\n\n\tgetVirtualTokenValue(pToken, pOperationResults)\n\t{\n\t\tlet tmpVirtualSymbol = this.getOperationVirtualSymbolName(pToken);\n\n\t\tif ((pToken.Type == 'Token.Symbol' || pToken.Type == 'Token.Constant') && (pToken.Value))\n\t\t{\n\t\t\treturn pToken.Value.toString();\n\t\t}\n\n\t\tlet tmpVirtualSymbolData = ('VirtualSymbols' in pOperationResults) ? pOperationResults.VirtualSymbols : {};\n\n\t\tif (this.ExpressionParser.GenericManifest.checkAddressExists(tmpVirtualSymbolData, tmpVirtualSymbol))\n\t\t{\n\t\t\tlet tmpValue = this.ExpressionParser.GenericManifest.getValueAtAddress(tmpVirtualSymbolData, tmpVirtualSymbol);\n\n\t\t\tif (typeof(tmpValue) === 'object')\n\t\t\t{\n\t\t\t\treturn `{${Object.keys(tmpValue).length} values}`;\n\t\t\t}\n\t\t\tif (Array.isArray(tmpValue))\n\t\t\t{\n\t\t\t\treturn `[${Object.keys(tmpValue).length} values]`;\n\t\t\t}\n\t\t\treturn tmpValue;\n\t\t}\n\n\t\treturn 'NO_VALUE_FOUND';\n\t}\n\n\tgetTokenAddressString(pToken)\n\t{\n\t\treturn pExpression.Token;\n\t}\n\n\tgetTokenSymbolString(pExpressionToken)\n\t{\n\t\treturn pExpressionToken.Token;\n\t}\n\n\tgetOperationSymbolMessage(pOperation)\n\t{\n\t\tif (!pOperation)\n\t\t{\n\t\t\treturn 'INVALID_OPERATION';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pOperation);\n\t\tlet tmpOperationLeftValue = this.getTokenSymbolString(pOperation.LeftValue);\n\t\tlet tmpOperationSymbol = this.getTokenSymbolString(pOperation.Operation);\n\t\tlet tmpOperationRightValue = this.getTokenSymbolString(pOperation.RightValue);\n\n\t\tlet tmpVirtualSymbolPrefix = tmpOperationVirtualSymbol.substring(0, 3);\n\n\t\tif (tmpOperationSymbol === '=')\n\t\t{\n\t\t\t// Assignment operators are special\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue}`;\n\t\t}\n\n\t\tif (tmpVirtualSymbolPrefix === 'VFE')\n\t\t{\n\t\t\t// Virtual Function Expression\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationSymbol}(${tmpOperationLeftValue})`;\n\t\t}\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue} ${tmpOperationSymbol} ${tmpOperationRightValue}`;\n\t}\n\n\tgetOperationValueMessage(pOperation, pResultObject)\n\t{\n\t\tif (!pOperation)\n\t\t{\n\t\t\treturn 'INVALID_OPERATION';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pOperation);\n\t\tlet tmpOperationLeftValue = this.getVirtualTokenValue(pOperation.LeftValue, pResultObject);\n\t\tlet tmpOperationSymbol = this.getTokenSymbolString(pOperation.Operation);\n\t\tlet tmpOperationRightValue = this.getVirtualTokenValue(pOperation.RightValue, pResultObject);\n\n\t\tlet tmpVirtualSymbolPrefix = tmpOperationVirtualSymbol.substring(0, 3);\n\n\t\tif (tmpOperationSymbol === '=')\n\t\t{\n\t\t\t// Assignment operators are special\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue}`;\n\t\t}\n\n\t\tif (tmpVirtualSymbolPrefix === 'VFE')\n\t\t{\n\t\t\t// Virtual Function Expression\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationSymbol}(${tmpOperationLeftValue})`;\n\t\t}\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue} ${tmpOperationSymbol} ${tmpOperationRightValue}`;\n\t}\n\n\tgetOperationOutcomeMessage(pToken, pOperationResults)\n\t{\n\t\tif (!pToken)\n\t\t{\n\t\t\treturn 'INVALID_TOKEN';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pToken);\n\t\tlet tmpOperationOutcomeValue = this.getVirtualTokenValue(pToken, pOperationResults);\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationOutcomeValue}`;\n\t}\n\n\tlogFunctionOutcome(pResultObject)\n\t{\n\t\tif (typeof(pResultObject) !== 'object')\n\t\t{\n\t\t\tthis.log.error(`Solver results object was not an object.  Cannot log outcome.`);\n\t\t\treturn;\n\t\t}\n\t\tlet tmpAssignmentAddress = ('PostfixedAssignmentAddress' in pResultObject) ? pResultObject.PostfixedAssignmentAddress : 'NO_ASSIGNMENT_ADDRESS_FOUND';\n\t\tlet tmpRawExpression = ('RawExpression' in pResultObject) ? pResultObject.RawExpression : 'NO_EXPRESSION_FOUND';\n\t\tlet tmpRawResult = ('RawResult' in pResultObject) ? pResultObject.RawResult : 'NO_RESULT_FOUND';\n\n\t\tthis.log.info(`Solved f(${tmpAssignmentAddress}) = {${tmpRawExpression}}`);\n\t\tfor (let i = 0; i < pResultObject.PostfixSolveList.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pResultObject.PostfixSolveList[i];\n\t\t\tlet tmpTokenSymbolMessage = this.getOperationSymbolMessage(tmpToken);\n\t\t\tthis.log.info(`${i} Symbols: ${tmpTokenSymbolMessage}`);\n\t\t\tlet tmpTokenValueMessage = this.getOperationValueMessage(tmpToken, pResultObject);\n\t\t\tthis.log.info(`${i}  Values: ${tmpTokenValueMessage}`);\n\t\t\tlet tmpTokenOutcome = this.getOperationOutcomeMessage(tmpToken, pResultObject);\n\t\t\tthis.log.info(`${i} Outcome: ${tmpTokenOutcome}`);\n\t\t}\n\t\tthis.log.info(`{${tmpRawExpression}} = ${tmpRawResult}`);\n\t}\n\n\tlogFunctionSolve(pResultObject)\n\t{\n\t\tif (typeof(pResultObject) !== 'object')\n\t\t{\n\t\t\tthis.log.error(`Solver results object was not an object.  Cannot log the solve.`);\n\t\t\treturn;\n\t\t}\n\t\tif (!('PostfixSolveList' in pResultObject) || !Array.isArray(pResultObject.PostfixSolveList))\n\t\t{\n\t\t\tthis.log.error(`Solver results object did not contain a PostfixSolveList array.  Cannot log the solve.`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < pResultObject.PostfixSolveList.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pResultObject.PostfixSolveList[i];\n\t\t\tconsole.log(`${i}: ${tmpToken.VirtualSymbolName} = (${tmpToken.LeftValue.Token}::${tmpToken.LeftValue.Value})  ${tmpToken.Operation.Token}  (${tmpToken.RightValue.Token}::${tmpToken.RightValue.Value}) `)\n\t\t}\n\n\t\tthis.logFunctionOutcome(pResultObject);\n\t}\n}\n\nmodule.exports = ExpressionParserMessaging;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159,\"big.js\":17}],165:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserPostfix extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Postfix';\n\t}\n\n\tgetPosfixSolveListOperation(pOperation, pLeftValue, pRightValue, pDepthSolveList, pDepthSolveIndex)\n\t{\n\t\tlet tmpOperation = ({\n\t\t\tVirtualSymbolName: pOperation.VirtualSymbolName,\n\t\t\tOperation: pOperation,\n\t\t\tLeftValue: pLeftValue,\n\t\t\tRightValue: pRightValue\n\t\t});\n\n\t\tlet tmpDepthSolveList = Array.isArray(pDepthSolveList) ? pDepthSolveList : false;\n\n\t\t/* These two if blocks are very complex -- they basically provide a\n\t\t * way to deal with recursion that can be expressed to the user in\n\t\t * a meaningful way.\n\t\t * \n\t\t * The reason we are doing it as such is to show exactly how the\n\t\t * solver resolves the passed-in tokens into a solvable expression.\n\t\t */\n\t\tif (!tmpOperation.LeftValue.VirtualSymbolName)\n\t\t{\n\t\t\ttmpOperation.LeftValue.VirtualSymbolName = tmpOperation.VirtualSymbolName;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We need to set the left value to a virtual symbol instead of the looked up value if it's already used in another operation\n\t\t\tif ('LeftVirtualSymbolName' in tmpOperation.Operation)\n\t\t\t{\n\t\t\t\ttmpOperation.LeftValue = this.getTokenContainerObject(tmpOperation.Operation.LeftVirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpOperation.LeftValue = this.getTokenContainerObject(tmpOperation.LeftValue.VirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t}\n\t\tif (!tmpOperation.RightValue.VirtualSymbolName)\n\t\t{\n\t\t\ttmpOperation.RightValue.VirtualSymbolName = tmpOperation.VirtualSymbolName;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We need to set the right value to a virtual symbol instead of the looked up value if it's already used in another operation\n\t\t\t//if ('LeftVirtualSymbolName' in tmpOperation.RightValue)\n\t\t\tif ('RightVirtualSymbolName' in tmpOperation.Operation)\n\t\t\t{\n\t\t\t\ttmpOperation.RightValue = this.getTokenContainerObject(tmpOperation.Operation.RightVirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpOperation.RightValue = this.getTokenContainerObject(tmpOperation.RightValue.VirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t}\n\n\t\ttmpOperation.Operation.Parsed = true;\n\n\t\treturn tmpOperation;\n\t}\n\n\tbuildPostfixedSolveList(pTokenizedExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.PostfixedAssignmentAddress = 'Result'\n\t\ttmpResults.PostfixedAssignmentOperator = this.ExpressionParser.tokenMap['=']; // This is the default assignment operator\n\t\ttmpResults.PostfixTokenObjects = [];\n\t\ttmpResults.PostfixSolveList = [];\n\n\t\tif (pTokenizedExpression.length < 3)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList was passed a tokenized expression with less than three tokens.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn tmpResults.PostfixTokenObjects;\n\t\t}\n\n\t\t// 1. Figure out the Equality Assignment\n\t\tlet tmpEqualsIndex = -1;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((this.ExpressionParser.tokenMap[pTokenizedExpression[i]]) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type === 'Assignment'))\n\t\t\t{\n\t\t\t\tif (tmpEqualsIndex < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEqualsIndex = i;\n\t\t\t\t\ttmpResults.PostfixedAssignmentOperator = this.ExpressionParser.tokenMap[pTokenizedExpression[i]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found multiple assignment operators in the tokenized expression; assignment operator '${pTokenizedExpression[i]}' #${tmpEqualsIndex} at token index ${i}.`);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn tmpResults.PostfixTokenObjects;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEqualsIndex == -1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.buildPostfixedSolveList found no equality assignment in the tokenized expression; defaulting to Result`);\n\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\t\telse if (tmpEqualsIndex > 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.buildPostfixedSolveList found an equality assignment in the tokenized expression at an unexpected location (token index ${tmpEqualsIndex}); the expression cannot be parsed.`);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\t\telse if (tmpEqualsIndex === 0)\n\t\t{\n\t\t\t// This is an implicit function -- just go to result and return the value.\n\t\t\t// That is... the user entered something like \"= 5 + 3\" so we should just return 8, and use the default Result quietly.\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpResults.PostfixedAssignmentAddress = pTokenizedExpression[0];\n\t\t}\n\n\t\t// 2. Categorize tokens in the expression, put them in the \"expression list\" as a token object\n\t\tfor (let i = tmpEqualsIndex + 1; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\ttmpResults.PostfixTokenObjects.push(this.getTokenContainerObject(pTokenizedExpression[i]));\n\t\t}\n\n\t\t// 3. Decorate mathematical parsing depth and detect functions at the same time\n\t\t//    Having written this a few times now, it's easier to detect functions *while* parsing depth.\n\t\t//    Especially if we want our system to be able to communicate with the user when there is an issue.\n\t\tlet tmpDepth = 0;\n\t\t// The virtual symbol index is used for the abstract interim values that are generated at each step of the solve\n\t\tlet tmpVirtualParenthesisIndex = 0;\n\t\tlet tmpSolveLayerStack = [];\n\t\t// Kick off the solve layer stack with the first solve set identifier\n\t\ttmpSolveLayerStack.push(`SolveSet_${tmpVirtualParenthesisIndex}_D_${tmpDepth}`);\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\t// 1. If it's an open parenthesis, set the parenthesis at the current depth and increment the depth\n\t\t\tif (tmpResults.PostfixTokenObjects[i].Token === '(')\n\t\t\t{\n\t\t\t\t// Set the depth of the open parenthesis to the current solution depth\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\t\t\t\t// Generate the virtual symbol name for user output\n\t\t\t\ttmpResults.PostfixTokenObjects[i].VirtualSymbolName = `Pr_${tmpVirtualParenthesisIndex}_D_${tmpDepth}`;\n\n\t\t\t\t// 1a. Detect if this parenthesis is signaling a function\n\t\t\t\t//     If the previous token is a Symbol (e.g. it say sin(x) or sqrt(3+5) or something) then the parser will interpret it as a function\n\t\t\t\tif (i > 0)\n\t\t\t\t{\n\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i-1].Type === 'Token.Symbol')\n\t\t\t\t\t{\n\t\t\t\t\t\t// Set the type of this to be a function\n\t\t\t\t\t\ttmpResults.PostfixTokenObjects[i-1].Type = 'Token.Function';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Parenthesis manage the solve layer stack\n\t\t\t\t// For adding a new parenthesis solve layer, we put the parenthesis in the stack we are in and then make all the contained tokens be within the stack of the parenthesis\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t\ttmpSolveLayerStack.push(tmpResults.PostfixTokenObjects[i].VirtualSymbolName);\n\n\t\t\t\ttmpVirtualParenthesisIndex++;\n\t\t\t\ttmpDepth++;\n\t\t\t}\n\n\t\t\t// 2. If it's a closed parenthesis, decrease the depth\n\t\t\telse if (tmpResults.PostfixTokenObjects[i].Token === ')')\n\t\t\t{\n\t\t\t\ttmpDepth--;\n\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\n\t\t\t\t// Check to see that the depth of the closed parenthesis is greater than 0\n\t\t\t\tif (tmpDepth < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\n\t\t\t\t// Parenthesis manage the solve layer stack\n\t\t\t\t// For closing parenthesis solve layer with a close paren, we put it in the same stack as the opening parenthesis.\n\t\t\t\t// Give the closing parenthesis the same virtual symbol name as the opening parenthesis\n\t\t\t\t// (do the both above at the same time)\n\t\t\t\ttmpResults.PostfixTokenObjects[i].VirtualSymbolName = tmpSolveLayerStack.pop();\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t}\n\t\t}\n\n\t\t// 4. Walk through the decorated symbols and generate the postfix solve list\n\t\t//    We are going to start by creating a map of the solve layers:\n\t\tlet tmpSolveLayerMap = {};\n\t\tlet tmpSolveLayerMaxDepth = 0;\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\tif (!(tmpResults.PostfixTokenObjects[i].SolveLayerStack in tmpSolveLayerMap))\n\t\t\t{\n\t\t\t\ttmpSolveLayerMap[tmpResults.PostfixTokenObjects[i].SolveLayerStack] = [];\n\t\t\t}\n\t\t\ttmpSolveLayerMap[tmpResults.PostfixTokenObjects[i].SolveLayerStack].push(tmpResults.PostfixTokenObjects[i]);\n\n\t\t\t// See what our max depth is.  This is super important to the postfix operation\n\t\t\t// The programmer in me thinks it would be funny to not track this and just use the map key length as the max size, which would work (logically impossible to have a depth > key length) but it would be quite a bit more confusing to grok the algorithm.\n\t\t\tif (tmpResults.PostfixTokenObjects[i].Depth > tmpSolveLayerMaxDepth)\n\t\t\t{\n\t\t\t\ttmpSolveLayerMaxDepth = tmpResults.PostfixTokenObjects[i].Depth;\n\t\t\t}\n\t\t}\n\n\t\tlet tmpSolveLayerKeys = Object.keys(tmpSolveLayerMap);\n\t\t// Reset the virtual symbol index -- it was used above for uniquenes when creating abstract symbols for parenthesis and layer stacks.\n\t\tlet tmpVirtualSymbolIndex = 0;\n\t\ttmpSolveLayerKeys.sort(\n\t\t\t// Sort the solve layers by depth.\n\t\t\t(pLeftLayer, pRightLayer)=>\n\t\t\t{\n\t\t\t\t// It is impossible to have a layer with no entries in it.  \n\t\t\t\t// If that ever happens, the bug is actually above and we actively want this to blow up.\n\t\t\t\tif (tmpSolveLayerMap[pLeftLayer][0].Depth < tmpSolveLayerMap[pRightLayer][0].Depth)\n\t\t\t\t{\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (tmpSolveLayerMap[pLeftLayer][0].Depth > tmpSolveLayerMap[pRightLayer][0].Depth)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t// 5. Generate the postfix solve list\n\t\t//    The most important thing is going backwards in the depth order (a la reverse polish).\n\t\t//    Specifically not using shunting yard to provide in-depth \"show your work\" notes\n\t\t//    Yes it is possible to do a somewhat similar thing with shunting yard but the code is almost unreadable\n\n\t\t// 5.1 Build the Virtual Symbol Names\n\t\t// This maps layer stack addresses (which match parenthesis virtual symbol names) to the resultant value for that layer stack.\n\t\t// These values change as it solves but the last assignment is the proper assignment because math only reads forward in a line\n\t\ttmpResults.PostfixLayerstackMap = {};\n\t\t//FIXME: vet these - do we need a suffix version?\n\t\tconst unaryEligibleOperationTokens = [ '+', '-' ];\n\t\tconst unaryOperationPrefixTriggerTypes = [ 'Token.Operator', 'Token.Assignment' ];\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\t\t\t// For each precedence (this isn't strictly required here but makes the outcome for the user more readable)\n\t\t\tfor (let tmpPrecedence = 0; tmpPrecedence <= this.ExpressionParser.tokenMaxPrecedence; tmpPrecedence++)\n\t\t\t{\n\t\t\t\t// Enumerate all tokens in a layer's expression.\n\t\t\t\t// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.\n\t\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t\t{\n\t\t\t\t\tconst tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\tif (unaryEligibleOperationTokens.includes(tmpToken.Token) &&\n\t\t\t\t\t// promote to unary if:\n\t\t\t\t\t// 1. we are the first token in our group\n\t\t\t\t\t// 2. we are prefixed by a token type that is incompatible with us being binary\n\t\t\t\t\t\t(i == 0 || unaryOperationPrefixTriggerTypes.includes(tmpSolveLayerTokens[i - 1].Type)))\n\t\t\t\t\t{\n\t\t\t\t\t\t//FIXME: slow, but don't break the static data\n\t\t\t\t\t\ttmpToken.Descriptor = JSON.parse(JSON.stringify(tmpToken.Descriptor));\n\t\t\t\t\t\ttmpToken.Descriptor.Precedence = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//FIXME: handle operators with dynamic precedence (ex. unary vs. bunary + and -)\n\t\t\t\t\t// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.\n\t\t\t\t\tif ((tmpSolveLayerTokens[i].Type === 'Token.Operator') &&\n\t\t\t\t\t\t(tmpToken.Descriptor.Precedence === tmpPrecedence))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there is a token and nothing else in this layer, then it's an error.\n\t\t\t\t\t\tif (tmpSolveLayerTokens.length === 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a single operator in a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The - at the beginning of an expression is a number line orientation modifier\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '-' || tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VNLO_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If the token is at the beginning of the expression and not a number line orientation modifier, it's an error.\n\t\t\t\t\t\telse if ((i == 0) && ((tmpToken.Token != '+') || (tmpToken.Token != '-')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the beginning of a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If the token is at the end of the expression, it is an error.\n\t\t\t\t\t\telse if (i == tmpSolveLayerTokens.length - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the end of a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The - after an operator or an open parenthesis is also a number line orientation modifier\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '-') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VNLO_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '+') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the token is next to another operator it's a parsing error\n\t\t\t\t\t\telse if (((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i+1].Type === 'Token.Operator')) &&\n\t\t\t\t\t\t\t\t(tmpSolveLayerTokens[i+1].Token != '-' && tmpSolveLayerTokens[i+1].Token != '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at token index ${i} that is not surrounded by two values.`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Finally add a virtual symbol name to the dang thing.\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `V_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tmpSolveLayerTokens[i].Type === 'Token.Function') && (tmpPrecedence === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VFE_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.15 Generate Virtual Symbol Clusters for Functions and Parenthesis\n\t\t//      ... this gets funny because of precedence of operations surrounding them, parenthesis and functions.\n\t\tlet tmpFunctionCacheLIFOStack = [];\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\tlet tmpPostfixTokenObject = tmpResults.PostfixTokenObjects[i];\n\n\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\t// This is just to track the parenthesis stack level for User feedback\n\t\t\t\ttmpPostfixTokenObject.ParenthesisStack = tmpPostfixTokenObject.VirtualSymbolName;\n\n\t\t\t\t// At the beginning of the  expression, this must be an open parenthesis to be legal.\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ... this parenthesis group has no operators in it; make a virtual symbol name.\n\t\t\t\t\t\ttmpVirtualSymbolName = `VP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\ttmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\t// If it's an open parenthesis\n\t\t\t\telse if (tmpPostfixTokenObject.Token === '(')\n\t\t\t\t{\n\t\t\t\t\t// ... supporting a function\n\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i-1].Type === 'Token.Function')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = true;\n\t\t\t\t\t\ttmpPostfixTokenObject.Function = tmpResults.PostfixTokenObjects[i-1];\n\t\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ... this parenthesis group has no operators in it; make a virtual symbol name.\n\t\t\t\t\t\t\ttmpVirtualSymbolName = `VFP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a parenthesis group with no operators in it; make a virtual symbol name.\n\t\t\t\t\t\t\ttmpVirtualSymbolName = `VP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\ttmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\telse if (tmpPostfixTokenObject.Token === ')')\n\t\t\t\t{\n\t\t\t\t\tlet tmpOpenParenthesis = tmpFunctionCacheLIFOStack.pop();\n\t\t\t\t\tif (!tmpOpenParenthesis)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpOpenParenthesis.IsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = true;\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpOpenParenthesis.Function.VirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpOpenParenthesis.VirtualSymbolName\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// X. Postprocess the parenthesis groups to ensure they respect the order of operations for their boundaries\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpParenthesisStack = [];\n\t\t\tlet tmpLastOperator = false;\n\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpPostfixTokenObject = tmpSolveLayerTokens[i];\n\n\t\t\t\t// Keep track of the last operator\n\t\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\ttmpLastOperator = tmpPostfixTokenObject;\n\t\t\t\t}\n\n\t\t\t\t// This is only important to do at the close parenthesis.\n\t\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Function')\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpLastOperator;\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === '(') && tmpPostfixTokenObject.IsFunction)\n\t\t\t\t{\n\t\t\t\t\ttmpParenthesisStack.push(tmpPostfixTokenObject);\n\t\t\t\t\tif (tmpPostfixTokenObject.Function.PreviousOperator)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpPostfixTokenObject.Function.PreviousOperator;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === '('))\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpLastOperator;\n\t\t\t\t\ttmpParenthesisStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === ')'))\n\t\t\t\t{\n\t\t\t\t\t// This is ultra complex, and binds the order of operations logic to the open parenthesis for the group\n\t\t\t\t\tlet tmpOpenParenthesis = tmpParenthesisStack.pop();\n\t\t\t\t\tif (i < tmpSolveLayerTokens.length - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (let j = i + 1; j < tmpSolveLayerTokens.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpSolveLayerTokens[j].Type === 'Token.Operator')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOpenParenthesis.NextOperator = tmpSolveLayerTokens[j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpOpenParenthesis)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpOpenParenthesis.PreviousOperator && tmpOpenParenthesis.NextOperator)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpOpenParenthesis.PreviousOperator.Descriptor.Precedence <= tmpOpenParenthesis.NextOperator.Descriptor.Precedence)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpOpenParenthesis.NextOperator.LeftVirtualSymbolName = tmpOpenParenthesis.PreviousOperator.VirtualSymbolName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpOpenParenthesis.PreviousOperator.RightVirtualSymbolName = tmpOpenParenthesis.NextOperator.VirtualSymbolName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!('SolveLayerStack' in tmpPostfixTokenObject))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Decorate the solve layer stack for the token\n\t\t\t\t\t\tif (tmpParenthesisStack.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpPostfixTokenObject.SolveLayerStack = tmpParenthesisStack[tmpParenthesisStack.length-1].SolveLayerStack;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpPostfixTokenObject.SolveLayerStack = 'Expression_Root';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.2.9: Make sure the affinity of operators is respecting order of operations.\n\t\t//        Walk backwards and forwards, hoisting same value precedence backwards/forwards\n\t\t//        across each layer... the precedence change needs to be decreasing to matter\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpLastPrecedence = false;\n\t\t\tlet tmpFinalChainToken = false;\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\n\t\t\tfor (let i = tmpSolveLayerTokens.length-1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\n\t\t\t\tif (tmpToken.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\tif (!tmpFinalChainToken)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence > tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is less imporant than the last precedence, so hoist back the virtual value\n\t\t\t\t\t\ttmpToken.RightVirtualSymbolName = tmpFinalChainToken.VirtualSymbolName;\n\t\t\t\t\t\t//console.log(`Hoisting ${tmpToken.Token} back to ${tmpFinalChainToken.Token}`);\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence < tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\ttmpLastPrecedence = tmpToken.Descriptor.Precedence;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet tmpDecreasingPrecedenceStack = [];\n\t\t\tlet tmpLastToken = false;\n\t\t\tfor (let i = tmpSolveLayerTokens.length-1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\n\t\t\t\tif (tmpToken.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\tif (!tmpLastToken)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence > tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Check and see if this needs to be resolved in the stack\n\t\t\t\t\t\tif (tmpDecreasingPrecedenceStack.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (let j = tmpDecreasingPrecedenceStack.length-1; j >= 0; j--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (tmpDecreasingPrecedenceStack[j].Descriptor.Precedence >= tmpToken.Descriptor.Precedence)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//console.log(`Hoisting ${tmpDecreasingPrecedenceStack[j].Token} up to ${tmpToken.Token}`);\n\t\t\t\t\t\t\t\t\ttmpDecreasingPrecedenceStack[j].LeftVirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\t\t\ttmpDecreasingPrecedenceStack.slice(j, 1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence < tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpDecreasingPrecedenceStack.push(tmpLastToken);\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\ttmpLastPrecedence = tmpToken.Descriptor.Precedence;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.3: Generate the Postfix Solve List\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\n\t\t\t// If this is a layer with one value, presume it's an assignment.\n\t\t\tif (tmpSolveLayerTokens.length === 1)\n\t\t\t{\n\t\t\t\t// TODO: I think this is correct but with the addition of multiple assignment operators it's less clear.\n\t\t\t\tlet tmpAbstractAssignToken = this.getTokenContainerObject('=');\n\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpSolveLayerTokens[0].SolveLayerStack];\n\t\t\t\t// If this doesn't have a matching solvelayerstack, get the virtual symbol name from the parenthesis group it's in\n\t\t\t\tif (!tmpAbstractAssignToken.VirtualSymbolName)\n\t\t\t\t{\n\t\t\t\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i].ParenthesisStack === tmpSolveLayerTokens[0].SolveLayerStack)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixTokenObjects[i].VirtualSymbolName;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!tmpAbstractAssignToken.VirtualSymbolName)\n\t\t\t\t{\n\t\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = `V_SingleValue_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t}\n\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractAssignToken, tmpSolveLayerTokens[0], this.getTokenContainerObject('0.0')));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// For each precedence level in the layer\n\t\t\tfor (let tmpPrecedence = 0; tmpPrecedence <= this.ExpressionParser.tokenMaxPrecedence; tmpPrecedence++)\n\t\t\t{\n\t\t\t\t// Enumerate all tokens in a layer's expression.\n\t\t\t\t// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.\n\t\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.\n\t\t\t\t\tif ((tmpSolveLayerTokens[i].Type === 'Token.Operator') &&\n\t\t\t\t\t\t(tmpSolveLayerTokens[i].Descriptor.Precedence === tmpPrecedence))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\t// The - at the beginning of an expression is a number line orientation modifier\n\t\t\t\t\t\tif ((i == 0) && (tmpToken.Token == '-'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\t// This is an abstract operation that isn't in the expression.\n\t\t\t\t\t\t\tlet tmpAbstractMultiplyToken = this.getTokenContainerObject('*');\n\t\t\t\t\t\t\ttmpAbstractMultiplyToken.VirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractMultiplyToken, this.getTokenContainerObject('-1.0'), tmpSolveLayerTokens[i+1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The - after an operator or an open parenthesis is also a number line orientation modifier\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '-') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\tlet tmpAbstractMultiplyToken = this.getTokenContainerObject('*');\n\t\t\t\t\t\t\ttmpAbstractMultiplyToken.VirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractMultiplyToken, this.getTokenContainerObject('-1.0'), tmpSolveLayerTokens[i+1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '+') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Finally add the dang thing.\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpToken, tmpSolveLayerTokens[i-1], tmpSolveLayerTokens[i+1], tmpSolveLayerTokens, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tmpSolveLayerTokens[i].Type === 'Token.Function') && (tmpPrecedence === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpToken, tmpSolveLayerTokens[i+1], this.getTokenContainerObject('0.0')));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 7. Lastly set the assignment address.\n\t\tlet tmpAbstractAssignToken = ('PostfixedAssignmentOperator' in tmpResults) ? this.getTokenContainerObject(tmpResults.PostfixedAssignmentOperator.Token) : this.getTokenContainerObject('=');\n\t\t// The address we are assigning to\n\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixedAssignmentAddress;\n\t\t// The address it's coming from\n\t\tlet tmpSolveResultToken = this.getTokenContainerObject('Result', 'Token.LastResult');\n\t\tlet tmpFinalAssignmentInstruction = this.getPosfixSolveListOperation(tmpAbstractAssignToken, tmpSolveResultToken, this.getTokenContainerObject('SolverMarshal', 'Token.SolverMarshal'));\n\t\ttmpResults.PostfixSolveList.push(tmpFinalAssignmentInstruction);\n\n\t\treturn tmpResults.PostfixSolveList;\n\t}\n}\n\nmodule.exports = ExpressionParserPostfix;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159}],166:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\nconst libSetConcatArray = require('../Fable-SetConcatArray.js');\n\nclass ExpressionParserSolver extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Solver';\n\t}\n\n\tsolvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\tlet tmpManifest = (typeof(pManifest) === 'object') ? pManifest : this.fable.newManyfest();\n\n\t\tlet tmpDataDestinationObject = (typeof(pDataDestinationObject) === 'object') ? pDataDestinationObject : {};\n\n\t\t// If there was a fable passed in (e.g. the results object was a service or such), we won't decorate\n\t\tlet tmpPassedInFable = ('fable' in tmpResults);\n\t\tif (!tmpPassedInFable)\n\t\t{\n\t\t\ttmpResults.fable = this.fable;\n\t\t}\n\n\t\tif (!Array.isArray(pPostfixedExpression))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression was passed a non-array postfixed expression.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn false;\n\t\t}\n\t\tif (pPostfixedExpression.length < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression was passed an empty postfixed expression.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn false;\n\t\t}\n\n\t\t// This is how the user communication magic happens.\n\t\ttmpResults.VirtualSymbols = {};\n\n\t\tfor (let i = 0; i < pPostfixedExpression.length; i++)\n\t\t{\n\t\t\t// X = SUM(15, SUM(SIN(25), 10), (5 + 2), 3)\n\t\t\tif (pPostfixedExpression[i].Operation.Type === 'Token.SolverInstruction')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpStepResultObject = { ExpressionStep: pPostfixedExpression[i], ExpressionStepIndex: i, ResultsObject: tmpResults, Manifest: tmpManifest};\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.LastResult')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpResults.LastResult;\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.LastResult')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpResults.LastResult;\n\t\t\t}\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.VirtualSymbol')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.LeftValue.Token);\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.VirtualSymbol')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.RightValue.Token);\n\t\t\t}\n\n\t\t\t// Resolve the parenthesis to their actual values\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.LeftValue.VirtualSymbolName);\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.RightValue.VirtualSymbolName);\n\t\t\t}\n\n\t\t\t// Virtual Constants\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.Constant' && !('Value' in tmpStepResultObject.ExpressionStep.LeftValue))\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpStepResultObject.ExpressionStep.LeftValue.Token;\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.Constant' && !('Value' in tmpStepResultObject.ExpressionStep.RightValue))\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpStepResultObject.ExpressionStep.RightValue.Token;\n\t\t\t}\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.Operation.Type = 'Operator')\n\t\t\t{\n\t\t\t\t// TODO: This can be optimized.   A lot.  If necessary.  Seems pretty fast honestly for even thousands of operations.  Slowest part is arbitrary precision.\n\t\t\t\t// An operator always has a left and right value.\n\t\t\t\tlet tmpFunctionAddress;\n\t\t\t\t// Note: There are easier, passive ways of managing this state.  But this is complex.\n\t\t\t\tlet tmpIsFunction = false;\n\t\t\t\tif (tmpStepResultObject.ExpressionStep.Operation.Token in this.ExpressionParser.tokenMap)\n\t\t\t\t{\n\t\t\t\t\ttmpFunctionAddress = `ResultsObject.${tmpStepResultObject.ExpressionStep.Operation.Descriptor.Function}`;\n\t\t\t\t}\n\t\t\t\telse if (tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase() in this.ExpressionParser.functionMap)\n\t\t\t\t{\n\t\t\t\t\ttmpIsFunction = true;\n\t\t\t\t\ttmpFunctionAddress = `ResultsObject.${this.ExpressionParser.functionMap[tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase()].Address}`;\n\t\t\t\t}\n\n\t\t\t\tif (tmpIsFunction)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpResult;\n\t\t\t\t\t\tconst tmpFunction = tmpManifest.getValueAtAddress(tmpStepResultObject, tmpFunctionAddress);\n\t\t\t\t\t\tif (typeof tmpFunction === 'function')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpFunctionBinding = null;\n\t\t\t\t\t\t\tif (tmpFunctionAddress.includes('.'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpFunctionBinding = tmpManifest.getValueAtAddress(tmpStepResultObject, tmpFunctionAddress.split('.').slice(0, -1).join('.'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet tmpArguments = tmpStepResultObject.ExpressionStep.LeftValue.Value;\n\t\t\t\t\t\t\tif (!(tmpArguments instanceof libSetConcatArray))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpArguments = [ tmpArguments ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpArguments = tmpArguments.values;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpResult = tmpFunction.apply(tmpFunctionBinding, tmpArguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName, tmpResult);\n\t\t\t\t\t\ttmpResults.LastResult = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName);\n\t\t\t\t\t\t//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ${i} with function ${tmpStepResultObject.ExpressionStep.Operation.Token}: ${pError}`);\n\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1], { Stack: pError.stack });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t//this.log.trace(`Solving Step ${i} [${tmpStepResultObject.ExpressionStep.VirtualSymbolName}] --> [${tmpStepResultObject.ExpressionStep.Operation.Token}]: ( ${tmpStepResultObject.ExpressionStep.LeftValue.Value} , ${tmpStepResultObject.ExpressionStep.RightValue.Value} )`);\n\t\t\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName, tmpManifest.getValueAtAddress(tmpStepResultObject, `${tmpFunctionAddress}(ExpressionStep.LeftValue.Value,ExpressionStep.RightValue.Value)`));\n\t\t\t\t\t\ttmpResults.LastResult = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName);\n\t\t\t\t\t\t//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ${i} with function ${tmpStepResultObject.ExpressionStep.Operation.Token}: ${pError}`);\n\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1], { Stack: pError.stack });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Equations don't always solve in virtual symbol order.\n\t\t\t\ttmpResults.SolverFinalVirtualSymbol = tmpStepResultObject.ExpressionStep.VirtualSymbolName;\n\t\t\t}\n\t\t}\n\n\t\tlet tmpSolverResultValue = tmpManifest.getValueAtAddress(tmpResults, `VirtualSymbols.${tmpResults.SolverFinalVirtualSymbol}`);\n\n\t\t// Now deal with final assignment(s)\n\t\tfor (let i = 0; i < pPostfixedExpression.length; i++)\n\t\t{\n\t\t\tif (pPostfixedExpression[i].RightValue.Type === 'Token.SolverMarshal')\n\t\t\t{\n\t\t\t\t// Set the result in the virtual symbols\n\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t// Set the value in the destination object\n\t\t\t\tif (pPostfixedExpression[i].Operation.Descriptor.OnlyEmpty)\n\t\t\t\t{\n\t\t\t\t\t// If it is only on \"empty\" values, check if the value is empty before assigning\n\t\t\t\t\tif (this.fable.Utility.addressIsNullOrEmpty(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Otherwise, just assign it.\n\t\t\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmpResults.RawResult = tmpSolverResultValue;\n\n\t\t// Clean up the fable reference if we added it to the object.\n\t\tif (!tmpPassedInFable)\n\t\t{\n\t\t\tdelete tmpResults.fable;\n\t\t}\n\n\t\tif (typeof(tmpSolverResultValue) === 'object')\n\t\t{\n\t\t\treturn tmpSolverResultValue;\n\t\t}\n\t\telse if (typeof(tmpSolverResultValue) !== 'undefined')\n\t\t{\n\t\t\treturn tmpSolverResultValue.toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpSolverResultValue;\n\t\t}\n\t}\n}\n\nmodule.exports = ExpressionParserSolver;\n\n},{\"../Fable-SetConcatArray.js\":183,\"./Fable-Service-ExpressionParser-Base.js\":159}],167:[function(require,module,exports){\nmodule.exports={\n\t\"=\":\n\t\t{\n\t\t\t\"Name\": \"Assign Value\",\n\t\t\t\"Token\": \"=\",\n\t\t\t\"Function\": \"fable.Math.assignValue\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\":\":\n\t\t{\n\t\t\t\"Name\": \"Expression Begin\",\n\t\t\t\"Token\": \":\",\n\t\t\t\"Function\": \"fable.Math.expressionBegin\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\"?=\":\n\t\t{\n\t\t\t\"Name\": \"Null or Empty Coalescing Assign Value\",\n\t\t\t\"Token\": \"?=\",\n\t\t\t\"Function\": \"fable.Math.assignValue\",\n\t\t\t\"OnlyEmpty\": true,\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\"(\":\n\t\t{\n\t\t\t\"Name\": \"Left Parenthesis\",\n\t\t\t\"Token\": \"(\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Parenthesis\"\n\t\t},\n\t\")\":\n\t\t{\n\t\t\t\"Name\": \"Right Parenthesis\",\n\t\t\t\"Token\": \")\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Parenthesis\"\n\t\t},\n\t\",\":\n\t\t{\n\t\t\t\"Name\": \"Set Concatenate\",\n\t\t\t\"Token\": \",\",\n\t\t\t\"Function\": \"fable.Math.setConcatenate\",\n\t\t\t\"Precedence\": 5,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"*\":\n\t\t{\n\t\t\t\"Name\": \"Multiply\",\n\t\t\t\"Token\": \"*\",\n\t\t\t\"Function\": \"fable.Math.multiplyPrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"/\":\n\t\t{\n\t\t\t\"Name\": \"Divide\",\n\t\t\t\"Token\": \"/\",\n\t\t\t\"Function\": \"fable.Math.dividePrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"^\":\n\t\t{\n\t\t\t\"Name\": \"Exponent\",\n\t\t\t\"Token\": \"^\",\n\t\t\t\"Function\": \"fable.Math.powerPrecise\",\n\t\t\t\"Precedence\": 2,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"%\":\n\t\t{\n\t\t\t\"Name\": \"Modulus\",\n\t\t\t\"Token\": \"%\",\n\t\t\t\"Function\": \"fable.Math.modPrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"+\":\n\t\t{\n\t\t\t\"Name\": \"Add\",\n\t\t\t\"Token\": \"+\",\n\t\t\t\"Function\": \"fable.Math.addPrecise\",\n\t\t\t\"Precedence\": 4,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"-\":\n\t\t{\n\t\t\t\"Name\": \"Subtract\",\n\t\t\t\"Token\": \"-\",\n\t\t\t\"Function\": \"fable.Math.subtractPrecise\",\n\t\t\t\"Precedence\": 4,\n\t\t\t\"Type\": \"Operator\"\n\t\t}\n}\n\n},{}],168:[function(require,module,exports){\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserValueMarshal extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-ValueMarshal';\n\t}\n\n\t/**\n\t * Substitutes values in tokenized objects based on the provided data source and manifest.\n\t *\n\t * TODO: Move this to its own file in the \"Fable-Service-ExpressionParser\" directory.\n\t *\n\t * @param {Array} pTokenizedObjects - The array of tokenized objects.\n\t * @param {Object} pDataSource - The data source object where we pull values from.\n\t * @param {Object} pResultObject - The result object where the algorithm shows its work.\n\t * @param {Object} pManifest - The manifest object to use for hash resolution.\n\t * @returns {Array} - The modified tokenized objects array.\n\t */\n\tsubstituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\tif (!Array.isArray(pTokenizedObjects))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects was passed a non-array tokenized object list.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedObjects;\n\t\t}\n\t\tif (typeof(pDataSource) !== 'object')\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects either was passed no data source, or was passed a non-object data source.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedObjects;\n\t\t}\n\n\t\tlet tmpDataSource = pDataSource;\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : this.fable.newManyfest(pManifest);\n\n\t\tfor (let i = 0; i < pTokenizedObjects.length; i++)\n\t\t{\n\t\t\tif (typeof(pTokenizedObjects[i]) !== 'object')\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found a non-object tokenized object at index ${i}`);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpToken = pTokenizedObjects[i];\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.Symbol') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\t// Symbols always look up values by hash first\n\t\t\t\tlet tmpValue = tmpManifest.getValueByHash(tmpDataSource, tmpToken.Token);\n\t\t\t\t// if (!tmpValue)\n\t\t\t\t// {\n\t\t\t\t// \t// If no hash resolves, try by address.\n\t\t\t\t// \ttmpValue = tmpManifest.getValueAtAddress(tmpToken.Token, tmpDataSource);\n\t\t\t\t// }\n\t\t\t\tif (tmpValue == null)\n\t\t\t\t{\n\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\ttmpToken.Resolve = true;\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the symbol hash or address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\tif (this.LogNoisiness > 1) this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpValue}] for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tif (typeof tmpValue === 'object') // this encapsulates POJOs and arrays\n\t\t\t\t\t{\n\t\t\t\t\t\t// this must be checked first, which works around an edge case where bigNumber turns single-element arrays into numbers, which we never want\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst tmpValueParsed = new this.fable.Utility.bigNumber(tmpValue);\n\t\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO: Should we allow this to be a function?  Good god the complexity and beauty of that...\n\t\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}; using raw value.`);\n\t\t\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.StateAddress') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\t// Symbols are always hashes.  This gracefully works for simple shallow objects because hashes default to the address in Manyfest.\n\t\t\t\t// Sometimes the token is wrapped in {} to indicate it's a direct address reference... we need to strip those off.\n\t\t\t\t// e.g., {0x1234abcd...}\n\t\t\t\t// So we need to strip off the {} if they exist.\n\t\t\t\tlet tmpAddress = tmpToken.Token;\n\t\t\t\tif ((tmpAddress.startsWith('{')) && (tmpAddress.endsWith('}')))\n\t\t\t\t{\n\t\t\t\t\ttmpAddress = tmpAddress.substring(1, tmpAddress.length-1);\n\t\t\t\t}\n\t\t\t\tlet tmpValue = tmpManifest.getValueAtAddress(tmpDataSource, tmpAddress);\n\t\t\t\tif (tmpValue == null)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//tmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpValue}] for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpValueParsed = new this.fable.Utility.bigNumber(tmpValue);\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t\t}\n\t\t\t\t\tcatch(pError)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: Should we allow this to be a function?  Good god the complexity and beauty of that...\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}; using raw value.`);\n\t\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.String') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpToken.Token}] for the string ${tmpToken.Token} at index ${i}`);\n\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t// Take the quotes off the string\n\t\t\t\ttmpToken.Value = tmpToken.Token.substring(1, tmpToken.Token.length-1);\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.Constant') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpToken.Token}] for the constant ${tmpToken.Token} at index ${i}`);\n\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlet tmpValueParsed = new this.fable.Utility.bigNumber(tmpToken.Token);\n\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t}\n\t\t\t\tcatch(pError)\n\t\t\t\t{\n\t\t\t\t\t// This constant has the right symbols but apparently isn't a parsable number.\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\ttmpToken.Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pTokenizedObjects;\n\t}\n}\n\nmodule.exports = ExpressionParserValueMarshal;\n\n},{\"./Fable-Service-ExpressionParser-Base.js\":159}],169:[function(require,module,exports){\n(function (process){(function (){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libFS = require('fs');\nconst libPath = require('path');\nconst libReadline = require('readline');\n\n\nclass FableServiceFilePersistence extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'FilePersistence';\n\n\t\tif (!('Mode' in this.options))\n\t\t{\n\t\t\tthis.options.Mode = parseInt('0777', 8) & ~process.umask();\n\t\t}\n\n\t\tthis.libFS = libFS;\n\t\tthis.libPath = libPath;\n\t\tthis.libReadline = libReadline;\n\t}\n\n\tjoinPath(...pPathArray)\n\t{\n\t\t// TODO: Fix anything that's using this before changing this to the new true node join\n\t\t// return libPath.join(...pPathArray);\n\t\treturn libPath.resolve(...pPathArray);\n\t}\n\n\tresolvePath(...pPathArray)\n\t{\n\t\treturn libPath.resolve(...pPathArray);\n\t}\n\n\texistsSync(pPath)\n\t{\n\t\treturn libFS.existsSync(pPath);\n\t}\n\n\texists(pPath, fCallback)\n\t{\n\t\tlet tmpFileExists = this.existsSync(pPath);\n\t\treturn fCallback(null, tmpFileExists);\n\t}\n\n\tdeleteFileSync(pFileName)\n\t{\n\t\treturn libFS.unlinkSync(pFileName);\n\t}\n\n\tdeleteFolderSync(pFileName)\n\t{\n\t\treturn libFS.rmdirSync(pFileName);\n\t}\n\n\treadFileSync(pFilePath, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.readFileSync(pFilePath, tmpOptions);\n\t}\n\n\treadFile(pFilePath, pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.readFile(pFilePath, tmpOptions, fCallback);\n\t}\n\n\treadFileCSV(pFilePath, pOptions, fRecordFunction, fCompleteFunction, fErrorFunction)\n\t{\n\t\tlet tmpCSVParser = this.fable.instantiateServiceProviderWithoutRegistration('CSVParser', pOptions);\n\t\tlet tmpRecordFunction = (typeof(fRecordFunction) === 'function') ? fRecordFunction :\n\t\t\t(pRecord) =>\n\t\t\t{\n\t\t\t\tthis.fable.log.trace(`CSV Reader received line ${pRecord}`);\n\t\t\t};\n\t\tlet tmpCompleteFunction = (typeof(fCompleteFunction) === 'function') ? fCompleteFunction :\n\t\t\t() =>\n\t\t\t{\n\t\t\t\tthis.fable.log.info(`CSV Read of ${pFilePath} complete.`);\n\t\t\t};\n\t\tlet tmpErrorFunction = (typeof(fErrorFunction) === 'function') ? fErrorFunction :\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.fable.log.error(`CSV Read of ${pFilePath} Error: ${pError}`, pError);\n\t\t\t};\n\n\t\treturn this.lineReaderFactory(pFilePath,\n\t\t\t(pLine) =>\n\t\t\t{\n\t\t\t\tlet tmpRecord = tmpCSVParser.parseCSVLine(pLine);\n\t\t\t\tif (tmpRecord)\n\t\t\t\t{\n\t\t\t\t\ttmpRecordFunction(tmpRecord, pLine);\n\t\t\t\t}\n\t\t\t}, tmpCompleteFunction, tmpErrorFunction);\n\t}\n\n\tappendFileSync(pFileName, pAppendContent, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.appendFileSync(pFileName, pAppendContent, tmpOptions);\n\t}\n\n\twriteFileSync(pFileName, pFileContent, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.writeFileSync(pFileName, pFileContent, tmpOptions);\n\t}\n\n\twriteFileSyncFromObject(pFileName, pObject)\n\t{\n\t\treturn this.writeFileSync(pFileName, JSON.stringify(pObject, null, 4));\n\t}\n\n\twriteFileSyncFromArray(pFileName, pFileArray)\n\t{\n\t\tif (!Array.isArray(pFileArray))\n\t\t{\n\t\t\tthis.log.error(`File Persistence Service attempted to write ${pFileName} from array but the expected array was not an array (it was a ${typeof(pFileArray)}).`);\n\t\t\treturn Error('Attempted to write ${pFileName} from array but the expected array was not an array (it was a ${typeof(pFileArray)}).');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (let i = 0; i < pFileArray.length; i++)\n\t\t\t{\n\t\t\t\treturn this.appendFileSync(pFileName, `${pFileArray[i]}\\n`);\n\t\t\t}\n\t\t}\n\t}\n\n\twriteFile(pFileName, pFileContent, pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.writeFile(pFileName, pFileContent, tmpOptions, fCallback);\n\t}\n\n\tlineReaderFactory(pFilePath, fOnLine, fOnComplete, fOnError)\n\t{\n\t\tlet tmpLineReader = {};\n\n\t\tif (typeof(pFilePath) != 'string')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\ttmpLineReader.filePath = pFilePath;\n\n\t\ttmpLineReader.fileStream = libFS.createReadStream(tmpLineReader.filePath);\n\n\t\ttmpLineReader.reader = libReadline.createInterface({ input: tmpLineReader.fileStream, crlfDelay: Infinity });\n\n\t\tif (typeof(fOnError) === 'function')\n\t\t{\n\t\t\ttmpLineReader.reader.on('error', fOnError);\n\t\t}\n\n\t\ttmpLineReader.reader.on('line', (typeof(fOnLine) === 'function') ? fOnLine : () => {});\n\n\t\tif (typeof(fOnComplete) === 'function')\n\t\t{\n\t\t\ttmpLineReader.reader.on('close', fOnComplete);\n\t\t}\n\n\t\treturn tmpLineReader;\n\t}\n\n\t// Folder management\n\tmakeFolderRecursive(pParameters, fCallback)\n\t{\n\t\tlet tmpParameters = pParameters;\n\n\t\tif (typeof(pParameters) == 'string')\n\t\t{\n\t\t\ttmpParameters = { Path: pParameters };\n\t\t}\n\t\telse if (typeof(pParameters) !== 'object')\n\t\t{\n\t\t\tfCallback(new Error('Parameters object or string not properly passed to recursive folder create.'));\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(tmpParameters.Path) !== 'string'))\n\t\t{\n\t\t\tfCallback(new Error('Parameters object needs a path to run the folder create operation.'));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!('Mode' in tmpParameters))\n\t\t{\n\t\t\ttmpParameters.Mode = this.options.Mode;\n\t\t}\n\n\t\t// Check if we are just starting .. if so, build the initial state for our recursive function\n\t\tif (typeof(tmpParameters.CurrentPathIndex) === 'undefined')\n\t\t{\n\t\t\t// Build the tools to start recursing\n\t\t\ttmpParameters.ActualPath = libPath.normalize(tmpParameters.Path);\n\t\t\ttmpParameters.ActualPathParts = tmpParameters.ActualPath.split(libPath.sep);\n\t\t\ttmpParameters.CurrentPathIndex = 0;\n\t\t\ttmpParameters.CurrentPath = '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is not our first run, so we will continue the recursion.\n\t\t\t// Build the new base path\n\t\t\tif (tmpParameters.CurrentPath == libPath.sep)\n\t\t\t{\n\t\t\t\ttmpParameters.CurrentPath = tmpParameters.CurrentPath + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpParameters.CurrentPath = tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];\n\t\t\t}\n\n\t\t\t// Increment the path index\n\t\t\ttmpParameters.CurrentPathIndex++;\n\t\t}\n\n\t\t// Check if the path is fully complete\n\t\tif (tmpParameters.CurrentPathIndex >= tmpParameters.ActualPathParts.length)\n\t\t{\n\t\t\treturn fCallback(null);\n\t\t}\n\n\t\t// Check if the path exists (and is a folder)\n\t\tlibFS.open(tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex], 'r',\n\t\t\t(pError, pFileDescriptor)=>\n\t\t\t{\n\t\t\t\tif (pFileDescriptor)\n\t\t\t\t{\n\t\t\t\t\tlibFS.closeSync(pFileDescriptor);\n\t\t\t\t}\n\n\t\t\t\tif (pError && pError.code=='ENOENT')\n\t\t\t\t{\n\t\t\t\t\t/* Path doesn't exist, create it */\n\t\t\t\t\tlibFS.mkdir(tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex], tmpParameters.Mode,\n\t\t\t\t\t\t(pCreateError) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!pCreateError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// We have now created our folder and there was no error -- continue.\n\t\t\t\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (pCreateError.code =='EEXIST')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The folder exists -- our dev might be running this in parallel/async/whatnot.\n\t\t\t\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconsole.log(pCreateError.code);\n\t\t\t\t\t\t\t\treturn fCallback(pCreateError);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n\nmodule.exports = FableServiceFilePersistence;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":107,\"fable-serviceproviderbase\":59,\"fs\":19,\"path\":103,\"readline\":19}],170:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceLogic extends libFableServiceBase\n{\n\t/**\n\t * @param {import('../Fable.js')} pFable - The fable object\n\t * @param {Record<string, any>} [pOptions] - The options object\n\t * @param {string} [pServiceHash] - The hash of the service\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t *\n\t * @param {string|number} pLeft - The left value to check\n\t * @param {string} pComparisonOperator - The comparison operator to use\n\t * @param {string|number} pRight - The right value to check\n\t * @param {any} pOnTrue - The value to return if the comparison is true\n\t * @param {any} [pOnFalse = ''] - The value to return if the comparison is false\n\t * @return {any} - The selected value\n\t */\n\tcheckIf(pLeft, pComparisonOperator, pRight, pOnTrue, pOnFalse)\n\t{\n\t\t// precise numeric\n\t\t// string (non-numeric)\n\t\tlet tmpMathLeft = this.fable.Math.parsePrecise(pLeft, null);\n\t\tlet tmpMathRight = this.fable.Math.parsePrecise(pRight, null);\n\t\tlet tmpCheckResult = false;\n\t\tif (tmpMathLeft === null || tmpMathRight === null)\n\t\t{\n\t\t\tif (typeof pOnFalse === 'undefined')\n\t\t\t{\n\t\t\t\tpOnFalse = '';\n\t\t\t}\n\t\t\tswitch (pComparisonOperator)\n\t\t\t{\n\t\t\t\tcase '<':\n\t\t\t\tcase 'LT':\n\t\t\t\t\ttmpCheckResult = pLeft < pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<=':\n\t\t\t\tcase 'LTE':\n\t\t\t\t\ttmpCheckResult = pLeft <= pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase 'GT':\n\t\t\t\t\ttmpCheckResult = pLeft > pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>=':\n\t\t\t\tcase 'GTE':\n\t\t\t\t\ttmpCheckResult = pLeft >= pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '==':\n\t\t\t\t\ttmpCheckResult = pLeft == pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '===':\n\t\t\t\t\ttmpCheckResult = pLeft === pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.fable.log.warn(`[FableServiceLogic.checkIf] Invalid comparison operator: ${pComparisonOperator}`);\n\t\t\t\t\ttmpCheckResult = pLeft == pRight;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (typeof pOnFalse === 'undefined')\n\t\t\t{\n\t\t\t\tpOnFalse = '0';\n\t\t\t}\n\t\t\tswitch (pComparisonOperator)\n\t\t\t{\n\t\t\t\tcase '<':\n\t\t\t\tcase 'LT':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.ltPrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<=':\n\t\t\t\tcase 'LTE':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.ltePrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase 'GT':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.gtPrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>=':\n\t\t\t\tcase 'GTE':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.gtePrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '==':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.comparePreciseWithin(tmpMathLeft, tmpMathRight, '0.000001') == 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '===':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.comparePrecise(tmpMathLeft, tmpMathRight) == 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.fable.log.warn(`[FableServiceLogic.checkIf] Invalid comparison operator: ${pComparisonOperator}`);\n\t\t\t\t\ttmpCheckResult = pLeft == pRight ? pOnTrue : pOnFalse;\n\t\t\t}\n\t\t}\n\t\treturn tmpCheckResult ? pOnTrue : pOnFalse;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t *\n\t * @param {any} pCheckForTruthy - The object to check\n\t * @param {any} pOnTrue - The value to return if the object is truthy\n\t * @param {any} [pOnFalse = ''] - The value to return if the object is falsy\n\t * @return {any} - The value from the object\n\t */\n\twhen(pCheckForTruthy, pOnTrue, pOnFalse = '')\n\t{\n\t\tif (!pCheckForTruthy)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\tif (Array.isArray(pCheckForTruthy) && pCheckForTruthy.length < 1)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\tif (typeof pCheckForTruthy === 'object' && Object.keys(pCheckForTruthy).length < 1)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\treturn pOnTrue;\n\t}\n}\n\nmodule.exports = FableServiceLogic;\n\n},{\"fable-serviceproviderbase\":59}],171:[function(require,module,exports){\n/**\n * @file Fable-Service-Math.js\n * @description This file contains the implementation of the FableServiceMath class, which provides simple functions for performing arbitrary precision math operations.\n * @module FableServiceMath\n * @extends libFableServiceBase\n */\nconst libFableServiceBase = require('fable-serviceproviderbase');\nconst libSetConcatArray = require('./Fable-SetConcatArray.js');\n\n/**\n * Arbitrary Precision Math Operations\n * @author      Steven Velozo <steven@velozo.com>\n * @description Simple functions that perform arbitrary precision math operations and return string resultant values.  Wraps big.js\n * @class FableServiceMath\n * @extends libFableServiceBase\n */\nclass FableServiceMath extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'Math';\n\n\t\tthis.pi = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679';\n\t\t// From NASA: https://apod.nasa.gov/htmltest/gifcity/e.2mil\n\t\tthis.euler = '2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664';\n\t\tthis.errorReturnValue = NaN;\n\n\t\t//\t\tthis.manifest = this.fable.newManyfest();\n\t\tthis.bigNumber = this.fable.Utility.bigNumber;\n\n\t\tthis.ln2Cache = new Map();\n\t}\n\n\t/*\n\t\tPass-through Rounding Method Constants\n\n\t\tProperty\t   Value   BigDecimal Equiv   Description\n\t\t----------     -----   ----------------   -----------\n\t\troundDown      0       ROUND_DOWN         Rounds towards zero. (_I.e. truncate, no rounding._)\n\t\troundHalfUp    1       ROUND_HALF_UP      Rounds towards nearest neighbour. (_If equidistant, rounds away from zero._)\n\t\troundHalfEven  2       ROUND_HALF_EVEN    Rounds towards nearest neighbour. (_If equidistant, rounds towards even neighbour._)\n\t\troundUp        3       ROUND_UP           Rounds positively away from zero. (_Always round up._)\n\t*/\n\tget roundDown() { return this.bigNumber.roundDown; }\n\tget roundHalfUp() { return this.bigNumber.roundHalfUp; }\n\tget roundHalfEven() { return this.bigNumber.roundHalfEven; }\n\tget roundUp() { return this.bigNumber.roundUp; }\n\n\t/**\n\t * Parses a precise number value.\n\t *\n\t * @param {number} pValue - The value to parse.\n\t * @param {any} pNonNumberValue - The value to use if parsing fails.\n\t * @returns {string} - The parsed number as a string.\n\t */\n\tparsePrecise(pValue, pNonNumberValue)\n\t{\n\t\tlet tmpNumber;\n\n\t\ttry\n\t\t{\n\t\t\ttmpNumber = new this.bigNumber(pValue);\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\t// TODO: This seems more correct -- we can add a silent or noisy parameter if we want this to export.\n\t\t\t//       Reason: Currently this is absolutely obliterating logs in the data integrations from bad data sources.\n\t\t\t//this.log.warn(`Error parsing number (type ${typeof (pValue)}): ${pError}`);\n\t\t\ttmpNumber = (typeof (pNonNumberValue) === 'undefined') ? \"0.0\" : pNonNumberValue;\n\t\t}\n\n\t\treturn tmpNumber ? tmpNumber.toString() : tmpNumber;\n\t}\n\n\t/**\n\t * Assigns the given value.  For equals operations in the solver.\n\t * @param {*} pValue - The value to be assigned.\n\t * @returns {*} The assigned value.\n\t */\n\tassignValue(pValue)\n\t{\n\t\treturn pValue;\n\t}\n\n\t/**\n\t * Begins an expression with the given value. For performing colon operations in the solver.\n\t * @param {*} pValue - The value to begin the expression with.\n\t * @returns {*} The begun expression value.\n\t */\n\texpressionBegin(pValue)\n\t{\n\t\treturn pValue;\n\t}\n\n\t/**\n\t * Calculates the precise percentage of a given value compared to another value.\n\t *\n\t * @param {number} pIs - The value to calculate the percentage of.\n\t * @param {number} pOf - The value to calculate the percentage against.\n\t * @returns {string} The precise percentage as a string.\n\t */\n\tpercentagePrecise(pIs, pOf)\n\t{\n\t\tlet tmpLeftValue = isNaN(pIs) ? 0 : pIs;\n\t\tlet tmpRightValue = isNaN(pOf) ? 0 : pOf;\n\n\t\tif (tmpRightValue == 0)\n\t\t{\n\t\t\treturn '0';\n\t\t}\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.div(tmpRightValue);\n\t\ttmpResult = tmpResult.times(100);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Concatenates two value sets and returns the result as a string.\n\t *\n\t * Value sets are comma separated.\n\t *\n\t * Used for arbitrary precision set generation.\n\t *\n\t * @param {any} pLeftValue - The left value to append.\n\t * @param {any} pRightValue - The right value to append.\n\t * @returns {InstanceType<libSetConcatArray>} The concatenated string of the left and right values.\n\t */\n\tsetConcatenate(pLeftValue, pRightValue)\n\t{\n\t\treturn new libSetConcatArray(pLeftValue, pRightValue);\n\t}\n\n\t/**\n\t * Rounds a value to a specified number of decimal places using a specified rounding method.\n\t *\n\t * @param {number} pValue - The value to be rounded.\n\t * @param {number} pDecimals - The number of decimal places to round to.\n\t * @param {function} [pRoundingMethod] - The rounding method to use. Defaults to `this.roundHalfUp`.\n\t * @returns {string} - The rounded value as a string.\n\t */\n\troundPrecise(pValue, pDecimals, pRoundingMethod)\n\t{\n\t\tlet tmpValue = pValue === false || isNaN(pValue) ? 0 : pValue;\n\t\tlet tmpDecimals = isNaN(pDecimals) ? 0 : parseInt(pDecimals, 10);\n\t\tlet tmpRoundingMethod = (typeof (pRoundingMethod) === 'undefined') ? this.roundHalfUp : parseInt(pRoundingMethod, 10);\n\n\t\ttry\n\t\t{\n\t\t\tlet tmpArbitraryValue = new this.bigNumber(tmpValue);\n\t\t\tlet tmpResult = tmpArbitraryValue.round(tmpDecimals, tmpRoundingMethod);\n\t\t\treturn tmpResult.toString();\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\treturn this.errorReturnValue;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a string representation of a number with a specified number of decimals.\n\t *\n\t * @param {number} pValue - The number to be formatted.\n\t * @param {number} pDecimals - The number of decimals to include in the formatted string.\n\t * @param {string} [pRoundingMethod] - The rounding method to use. Defaults to 'roundHalfUp'.\n\t * @returns {string} - The formatted number as a string.\n\t */\n\ttoFixedPrecise(pValue, pDecimals, pRoundingMethod)\n\t{\n\t\tlet tmpValue = pValue === false || isNaN(pValue) ? 0 : pValue;\n\t\tlet tmpDecimals = isNaN(pDecimals) ? 0 : parseInt(pDecimals, 10);\n\t\tlet tmpRoundingMethod = (typeof (pRoundingMethod) === 'undefined') ? this.roundHalfUp : pRoundingMethod;\n\n\t\ttry\n\t\t{\n\t\t\tlet tmpArbitraryValue = new this.bigNumber(tmpValue);\n\t\t\tlet tmpResult = tmpArbitraryValue.toFixed(tmpDecimals, tmpRoundingMethod);\n\t\t\treturn tmpResult.toString();\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\treturn this.errorReturnValue;\n\t\t}\n\t}\n\n\t/**\n\t * Adds two values precisely.\n\t * @param {number|string} pLeftValue - The left value to be added.\n\t * @param {number|string} pRightValue - The right value to be added.\n\t * @returns {string} - The result of adding the two values as a string.\n\t */\n\taddPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.plus(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Subtracts two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to subtract.\n\t * @param {number|string} pRightValue - The right value to subtract.\n\t * @returns {string} The result of the subtraction as a string.\n\t */\n\tsubtractPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.minus(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the precise power of two numbers.\n\t *\n\t * @param {number} pLeftValue - The base value.\n\t * @param {number} pRightValue - The exponent value.\n\t * @returns {string} The result of raising the base value to the exponent value.\n\t */\n\tpowerPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : parseInt(pRightValue);\n\t\tlet tmpResult;\n\t\tif (tmpRightValue == Number(pRightValue))\n\t\t{\n\t\t\tconst tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\t\ttmpResult = tmpLeftArbitraryValue.pow(tmpRightValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//FIXME: big.js shits itself on non-integer exponents........................\n\t\t\ttmpResult = Math.pow(tmpLeftValue, Number(pRightValue));\n\t\t}\n\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Multiplies two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to multiply.\n\t * @param {number|string} pRightValue - The right value to multiply.\n\t * @returns {string} The result of the multiplication as a string.\n\t */\n\tmultiplyPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.times(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Divides two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to be divided.\n\t * @param {number|string} pRightValue - The right value to divide by.\n\t * @returns {string} The result of the division as a string.\n\t */\n\tdividePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.div(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the modulus of two values with precision.\n\t *\n\t * @param {number|string} pLeftValue - The left value.\n\t * @param {number|string} pRightValue - The right value.\n\t * @returns {string} The result of the modulus operation as a string.\n\t */\n\tmodPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.mod(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the square root of a number with precise decimal places.\n\t *\n\t * @param {number|string} pValue - The number to calculate the square root of.\n\t * @returns {string} The square root of the input number as a string.\n\t */\n\tsqrtPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.sqrt();\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the absolute value of a number precisely.\n\t *\n\t * @param {number|string} pValue - The number to calculate the absolute value of.\n\t * @returns {string} The absolute value of the input number as a string.\n\t */\n\tabsPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.abs();\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the floor of a number precisely.\n\t *\n\t * @param {string|number} pValue - The number to calculate the floor value of.\n\t * @returns {string} The floor value of the input number as a string.\n\t */\n\tfloorPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpResult = Math.floor(tmpValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the ceiling of a number precisely.\n\t *\n\t * @param {number|string} pValue - The number to calculate the ceiling value of.\n\t * @returns {string} The ceiling value of the input number as a string.\n\t */\n\tceilPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpResult = Math.ceil(tmpValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Compares two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {number} - Returns the result of the comparison.\n\t */\n\tcomparePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.cmp(tmpRightValue);\n\t}\n\n\t/**\n\t * Compares two values precisely within a tolerance.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @param {number|string} pEpsilon - The epsilon value for comparison.\n\t * @returns {number} - Returns the result of the comparison.\n\t */\n\tcomparePreciseWithin(pLeftValue, pRightValue, pEpsilon)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tconst diff = tmpLeftArbitraryValue.minus(tmpRightValue).abs();\n\t\tif (diff.lte(pEpsilon))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (tmpLeftArbitraryValue.lt(tmpRightValue))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Determines if the left value is greater than the right value precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is greater than the right value, otherwise returns false.\n\t */\n\tgtPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.gt(tmpRightValue);\n\t}\n\n\t/**\n\t * Checks if the left value is greater than or equal to the right value.\n\t * If either value is not a number, it is treated as 0.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - True if the left value is greater than or equal to the right value, false otherwise.\n\t */\n\tgtePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.gte(tmpRightValue);\n\t}\n\n\t/**\n\t * Determines if the left value is less than the right value precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is less than the right value, otherwise returns false.\n\t */\n\tltPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.lt(tmpRightValue);\n\t}\n\n\t/**\n\t * Determines if the left value is less than or equal to the right value.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is less than or equal to the right value, otherwise returns false.\n\t */\n\tltePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.lte(tmpRightValue);\n\t}\n\n\t/**\n\t * Converts degrees to radians with arbitrary precision.\n\t *\n\t * @param {number|string} pDegrees - The degrees to convert to radians.\n\t * @returns {string} - The converted radians as a string.\n\t */\n\tradPrecise(pDegrees)\n\t{\n\t\tlet tmpDegrees = isNaN(pDegrees) ? 0 : pDegrees;\n\n\t\tlet tmpDegreesArbitraryValue = new this.bigNumber(tmpDegrees);\n\t\t// TODO: Const for pi in arbitrary precision?\n\t\tlet tmpResult = tmpDegreesArbitraryValue.times(Math.PI).div(180);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the value of pi with the specified precision.\n\t * If no precision is provided, returns 100 digits after the decimal.\n\t *\n\t * @param {number|string} [pPrecision] - The precision to use for calculating pi.\n\t * @returns {number} - The calculated value of pi.\n\t */\n\tpiPrecise(pPrecision)\n\t{\n\t\tif (typeof (pPrecision) === 'undefined')\n\t\t{\n\t\t\treturn this.pi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.roundPrecise(this.pi, pPrecision);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the value of euler with the specified precision.\n\t *\n\t * @param {number|string} [pPrecision] - The precision to use for calculating E.\n\t * @returns {string} - The calculated value of E.\n\t */\n\teulerPrecise(pPrecision)\n\t{\n\t\tif (typeof (pPrecision) === 'undefined')\n\t\t{\n\t\t\treturn this.euler;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.roundPrecise(this.euler, pPrecision);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the sine of the given angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The sine of the angle.\n\t */\n\tsin(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.sin(tmpRadians);\n\t}\n\n\t/**\n\t * Calculates the cosine of the given angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The cosine of the angle.\n\t */\n\tcos(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.cos(tmpRadians);\n\t}\n\n\t/**\n\t * Calculates the tangent of an angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The tangent of the angle.\n\t */\n\ttan(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.tan(tmpRadians);\n\t}\n\n\t/* * * * * * * * * * * * * * * *\n\t * Set functions\n\t * These are meant to work fine with arrays and more complex set descriptions returned by Manyfest.\n\t * Manyfest sometimes returns values as arrays and sometimes as a map of addresses with values depending\n\t * on what was requested.\n\t *\n\t * The following functions will likely be broken into their own service.\n\t */\n\n\t/**\n\t * Counts the number of elements in a set.\n\t *\n\t * @param {Array|Object|any} pValueSet - The set to count the elements of.\n\t * @returns {number} The number of elements in the set.\n\t */\n\tcountSetElements(pValueSet)\n\t{\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\treturn pValueSet.length;\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\treturn Object.keys(pValueSet).length;\n\t\t}\n\t\telse if (pValueSet)\n\t\t{\n\t\t\t// This is controversial.  Discuss with colleagues!\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Sorts the elements in the given value set in ascending order using the precise parsing and comparison.\n\t *\n\t * @param {Array|Object} pValueSet - The value set to be sorted.\n\t * @returns {Array} - The sorted value set.\n\t */\n\tsortSetPrecise(pValueSet)\n\t{\n\t\tlet tmpSortedSet = [];\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\ttmpSortedSet.push(this.parsePrecise(pValueSet[i], NaN));\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\ttmpSortedSet.push(this.parsePrecise(pValueSet[tmpKeys[i]], NaN));\n\t\t\t}\n\t\t}\n\n\t\ttmpSortedSet.sort((pLeft, pRight) => { return this.comparePrecise(pLeft, pRight); });\n\n\t\treturn tmpSortedSet;\n\t}\n\n\t/**\n\t * Bucketizes a set of values based on a specified bucket size.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to be bucketized.\n\t * @param {number} [pBucketSize] - The size of each bucket. Optional - If NaN, the values will be bucketized by their value.\n\t * @returns {Object} - The bucketized set of values.\n\t */\n\tbucketSetPrecise(pValueSet, pBucketSize)\n\t{\n\t\tlet tmpBucketedSet = {};\n\t\tlet tmpBucketSize = this.parsePrecise(pBucketSize, NaN);\n\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\tlet tmpBucket = tmpValue.toString();\n\t\t\t\tif (!isNaN(tmpBucketSize))\n\t\t\t\t{\n\t\t\t\t\ttmpBucket = this.dividePrecise(pValueSet[i], tmpBucketSize);\n\t\t\t\t}\n\t\t\t\tif (!(tmpBucket in tmpBucketedSet))\n\t\t\t\t{\n\t\t\t\t\ttmpBucketedSet[tmpBucket] = 0;\n\t\t\t\t}\n\t\t\t\ttmpBucketedSet[tmpBucket] = tmpBucketedSet[tmpBucket] + 1;\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\tlet tmpBucket = tmpValue.toString();\n\t\t\t\tif (!isNaN(tmpBucketSize))\n\t\t\t\t{\n\t\t\t\t\ttmpBucket = this.dividePrecise(pValueSet[i], tmpBucketSize);\n\t\t\t\t}\n\t\t\t\tif (!(tmpBucket in tmpBucketedSet))\n\t\t\t\t{\n\t\t\t\t\ttmpBucketedSet[tmpBucket] = 0;\n\t\t\t\t}\n\t\t\t\ttmpBucketedSet[tmpBucket] = tmpBucketedSet[tmpBucket] + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpBucketedSet;\n\t}\n\n\t/**\n\t * Calculates the histogram using precise bucket set for the given pValueSet.\n\t *\n\t * @param {Array<number>} pValueSet - The array of p-values.\n\t * @returns {Array<number>} The histogram of the p-values.\n\t */\n\thistogramPrecise(pValueSet)\n\t{\n\t\treturn this.bucketSetPrecise(pValueSet);\n\t}\n\n\t/**\n\t * Sorts the histogram object in ascending order based on the frequencies of the buckets.\n\t *\n\t * @param {Object} pHistogram - The histogram object to be sorted.\n\t * @returns {Object} - The sorted histogram object.\n\t */\n\tsortHistogramPrecise(pHistogram)\n\t{\n\t\tlet tmpSortedHistogram = {};\n\t\tlet tmpKeys = Object.keys(pHistogram);\n\n\t\ttmpKeys.sort((pLeft, pRight) => { return pHistogram[pLeft] - pHistogram[pRight]; });\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpSortedHistogram[tmpKeys[i]] = pHistogram[tmpKeys[i]];\n\t\t}\n\n\t\treturn tmpSortedHistogram;\n\t}\n\n\t/**\n\t * Sorts the histogram object in ascending order based on the keys.\n\t *\n\t * @param {Object} pHistogram - The histogram object to be sorted.\n\t * @returns {Object} - The sorted histogram object.\n\t */\n\tsortHistogramByKeys(pHistogram, pDescending)\n\t{\n\t\tlet tmpSortedHistogram = {};\n\t\tlet tmpKeys = Object.keys(pHistogram);\n\t\tlet tmpDescending = (typeof (pDescending) === 'undefined') ? false : pDescending;\n\n\t\t// Sort tmpKeys by the string comparison\n\t\ttmpKeys.sort();\n\n\t\tif (tmpDescending)\n\t\t{\n\t\t\ttmpKeys = tmpKeys.reverse();\n\t\t}\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpSortedHistogram[tmpKeys[i]] = pHistogram[tmpKeys[i]];\n\t\t}\n\n\t\treturn tmpSortedHistogram;\n\t}\n\n\tcleanValueArray(pValueArray, pRemoveZeroes)\n\t{\n\t\tlet tmpRemoveZeroes = (typeof (pRemoveZeroes) === 'undefined') ? false : pRemoveZeroes;\n\n\t\tif (!Array.isArray(pValueArray))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpCleanedArray = [];\n\t\tfor (let i = 0; i < pValueArray.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(pValueArray[i], NaN);\n\t\t\tif (!isNaN(tmpValue) && (!tmpRemoveZeroes || (tmpValue != \"0\")))\n\t\t\t{\n\t\t\t\ttmpCleanedArray.push(tmpValue);\n\t\t\t}\n\t\t}\n\t\treturn tmpCleanedArray;\n\t}\n\n\t/**\n\t * Calculate the natural log of 2 to a specific precision, for use in the Taylor series.\n\t * Cache outcome so it only runs once per precision.\n\t * @param {number} pPrecision - The decimal precision to calculate ln(2) to.\n\t * @returns\n\t */\n\tarbitraryNaturalLogOfTwo(pPrecision)\n\t{\n\t\tconst tmpPrecisionKey = pPrecision | 0;\n\t\tconst tmpPrecision = new this.bigNumber(tmpPrecisionKey);\n\t\tif (this.ln2Cache.has(tmpPrecisionKey))\n\t\t{\n\t\t\treturn this.ln2Cache.get(tmpPrecisionKey);\n\t\t}\n\n\t\tconst tmpTwoConstant = new this.bigNumber(2);\n\t\tconst y = tmpTwoConstant.minus(1).div(tmpTwoConstant.plus(1)); // 1/3\n\t\tconst y2 = y.mul(y);\n\t\tlet tmpSummation = new this.bigNumber(0);\n\t\tlet tmpTermination = y;\n\t\tlet tmpDenominator = 1;\n\n\t\t// Use a slightly larger precision for this to prevent numeric drift for larger log requirements\n\t\tconst tmpEpsilon = this.powerPrecise(10, -(tmpPrecision.add(8))); // target tail < 10^-(precision+8)\n\n\t\tfor (let i = 0; i < 200000; i++)\n\t\t{\n\t\t\ttmpSummation = tmpSummation.plus(tmpTermination.div(tmpDenominator));\n\t\t\ttmpTermination = tmpTermination.mul(y2);\n\t\t\ttmpDenominator += 2;\n\t\t\tif (tmpTermination.abs().div(tmpDenominator).lt(tmpEpsilon))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst tmpNaturalLogOfTwo = tmpSummation.mul(2);\n\t\tthis.ln2Cache.set(tmpPrecisionKey, tmpNaturalLogOfTwo);\n\t\treturn tmpNaturalLogOfTwo;\n\t}\n\n\t/**\n\t * Calculate the natural log of a number to a specific precision using arbitrary precision numbers.\n\t * @param {number} pNumberToCompute\n\t * @param {number} pPrecision\n\t * @returns\n\t */\n\tarbitraryNaturalLog(pNumberToCompute, pPrecision)\n\t{\n\t\tlet tmpNumberToCompute = new this.bigNumber(pNumberToCompute);\n\t\tlet tmpPrecision = new this.bigNumber(pPrecision);\n\n\t\tif (tmpNumberToCompute.lte(0)) throw new Error('ln undefined for non-positive values.');\n\t\tif (tmpNumberToCompute.eq(1)) return new this.bigNumber(0);\n\n\t\t// Reduce x to m in ~[0.75, 1.5] by multiplying/dividing by 2\n\t\tconst TWO = new this.bigNumber(2);\n\t\tlet k = 0;\n\t\tlet m = tmpNumberToCompute;\n\n\t\tconst tmpUpperBounds = new this.bigNumber('1.5');\n\t\tconst tmpLowerBounds = new this.bigNumber('0.75');\n\n\t\twhile (m.gt(tmpUpperBounds))\n\t\t{\n\t\t\tm = m.div(TWO); k += 1;\n\t\t}\n\t\twhile (m.lt(tmpLowerBounds))\n\t\t{\n\t\t\tm = m.mul(TWO); k -= 1;\n\t\t}\n\n\t\t// ln(m) via atanh/Taylor\n\t\tconst y = m.minus(1).div(m.plus(1)); // |y| < 1\n\t\tconst y2 = y.mul(y);\n\n\t\tlet tmpSummation = new this.bigNumber(0);\n\t\tlet tmpSeriesTermination = y; // y^(2j+1)\n\t\tlet tmpDenominator = 1;\n\n\t\tconst tmpEpsilon = this.powerPrecise(10, -(tmpPrecision.add(6))); // target tail < 10^-(precision+6)\n\n\t\t// Iterate until next term contribution is below eps\n\t\tfor (let i = 0; i < 200000; i++)\n\t\t{\n\t\t\ttmpSummation = tmpSummation.plus(tmpSeriesTermination.div(tmpDenominator));\n\t\t\ttmpSeriesTermination = tmpSeriesTermination.mul(y2);\n\t\t\ttmpDenominator += 2;\n\t\t\t// Stop when |tmpSeriesTermination|/tmpDenominator < eps\n\t\t\tif (tmpSeriesTermination.abs().div(tmpDenominator).lt(tmpEpsilon))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst tmpNaturalLog = tmpSummation.mul(2);\n\n\t\t// ln(2) once per precision via same series with m=2 (y = 1/3 ==> for faster convergence)\n\t\tconst tmpPrecisionNaturalLog = this.arbitraryNaturalLogOfTwo(tmpPrecision);\n\n\t\treturn tmpNaturalLog.plus(tmpPrecisionNaturalLog.mul(k));\n\t}\n\n\t/**\n\t * High-precision natural log using:\n\t *  - Argument reduction by powers of 2: x = m * 2^k with m ~ 1\n\t *  - atanh series: ln(m) = 2 * sum_{j>=0} y^(2j+1)/(2j+1), y=(m-1)/(m+1), |y|<1\n\t *\n\t * Converges rapidly when m is close to 1 with arbitrary precision numbers.\n\t *\n\t * @param {number} pNumberToGenerateLogarithmFor - The number to generate the logarithm for.\n\t * @param {number} [pBase] - The base of the logarithm. Defaults to 10.\n\t * @param {number} [pPrecision] - The precision of the result. Defaults to 9 decimal places.\n\t * @returns {string} - The logarithm of the number to the specified base and precision.\n\t */\n\tlogPrecise(pNumberToGenerateLogarithmFor, pBase, pPrecision)\n\t{\n\t\tlet tmpBase = (typeof (pBase) === 'undefined') ? this.bigNumber(10) : this.bigNumber(pBase);\n\t\t// Default precision is 9 decimal places -- matches Excel's default for LOG function\n\t\tconst tmpPrecision = (typeof (pPrecision) === 'undefined') ? 9 : pPrecision;\n\t\t// Extra precision to avoid rounding errors since we are using a series\n\t\tconst tmpExtraPrecision = 8;\n\t\tconst tmpWorkingPrecision = tmpPrecision + tmpExtraPrecision;\n\n\t\t// Store existing precision since this function integrates on a its own precision terms\n\t\tconst tmpSavedBigDecimalPrecision = this.bigNumber.DP;\n\t\tconst tmpSavedBigRoundingMethod = this.bigNumber.RM;\n\n\t\tthis.bigNumber.DP = tmpWorkingPrecision;\n\t\tthis.bigNumber.RM = 1; // round half up for the Taylor series\n\n\t\tconst N = this.bigNumber(pNumberToGenerateLogarithmFor);\n\t\tconst B = this.bigNumber(tmpBase);\n\n\t\t// Run domain checks, which Excel also does\n\t\tif (N.lte(0))\n\t\t{\n\t\t\tthis.log.error(`Fable logPrecise Error: Number must be greater than 0; number was ${pNumberToGenerateLogarithmFor}.`);\n\t\t\treturn NaN;\n\t\t}\n\t\tif (B.lte(0) || B.eq(1))\n\t\t{\n\t\t\tthis.log.error(`Fable logPrecise Error: Base must be greater than 0 and not equal to 1 -- base ${Base} was passed in.`);\n\t\t\treturn NaN;\n\t\t}\n\n\t\tconst tmpNaturalLogOfN = this.arbitraryNaturalLog(N, tmpPrecision);\n\t\tconst tmpNaturalLogOfB = this.arbitraryNaturalLog(B, tmpPrecision);\n\n\t\tconst tmpResult = tmpNaturalLogOfN.div(tmpNaturalLogOfB);\n\n\t\t// Final rounding to requested precision\n\t\tlet finalResult = tmpResult.toFixed(tmpPrecision);\n\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\tthis.bigNumber.RM = tmpSavedBigRoundingMethod;\n\t\treturn finalResult;\n\t}\n\n\texpPrecise(pValue, pDecimalPrecision)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? this.bigNumber(1) : this.bigNumber(pValue);\n\n\t\t// Constants & thresholds (Excel / IEEE-754 double limits) -- this is required to match Excel's behavior\n\t\tconst tmpDecimalPrecision = (typeof (pDecimalPrecision) === 'undefined') ? 9 : parseInt(pDecimalPrecision, 10);\n\t\tconst tmpSavedBigDecimalPrecision = this.bigNumber.DP;\n\t\tthis.bigNumber.DP = tmpDecimalPrecision + 10; // a bit of extra precision for rounding safety (this makes it match excel)\n\n\t\t// ln(2), min/max natural logs before double overflow/underflow\n\t\tconst tmpNaturalLogOfTwo = new this.bigNumber('0.693147180559945309417232121458176568'); // This is hilarious that we can compute the value above but this is what Excel uses.\n\t\tconst tmpNaturalLogMaxDouble = new this.bigNumber('709.782712893384'); // ln(1.7976931348623157e308)\n\t\tconst tmpNaturalLogMinimumValue = new this.bigNumber('-744.4400719213812'); // ln(5e-324)\n\n\t\t// 1. Guard for Overflow / underflow behavior to match Excel\n\t\tif (tmpValue.gt(tmpNaturalLogMaxDouble))\n\t\t{\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn NaN; // Excel shows #NUM! when result overflows we will use NaN\n\t\t}\n\t\tif (tmpValue.lt(tmpNaturalLogMinimumValue))\n\t\t{\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn new this.bigNumber(0); // Excel underflows to 0\n\t\t}\n\n\t\t// 2. Perform Range reduction: x = k*ln2 + r, with r small\n\t\t// k = floor(x / ln2)\n\t\tlet k;\n\t\ttry\n\t\t{\n\t\t\tk = tmpValue.div(tmpNaturalLogOfTwo).round(0, 0 /* RoundDown toward -infinity */); // floor for positives & negatives\n\t\t}\n\t\tcatch(pErrorRounding)\n\t\t{\n\t\t\tthis.log.error(`Fable expPrecise Error: Rounding error during range reduction for value of ${pValue}.  Error: ${pErrorRounding}`);\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn NaN;\n\t\t}\n\t\tconst r = tmpValue.minus(k.times(tmpNaturalLogOfTwo));\n\n\t\t// Compute exp(r) via Taylor series with Big arithmetic\n\t\t// exp(r) = Summation of r^n / n!, n=0..infinity\n\t\t// Sum until termination is below tolerance based on decimal precision\n\t\tconst tmpTolerance = new this.bigNumber(10).pow(-(tmpDecimalPrecision + 2));\n\t\tlet tmpTermination = new this.bigNumber(1); // r^0/0! = 1\n\t\tlet tmpSummation = new this.bigNumber(1);\n\t\tlet n = 1;\n\n\t\t// 3. Multiply incrementally: term *= r / n\n\t\t// SOOOOO close to a fractal!\n\t\twhile (true)\n\t\t{\n\t\t\ttmpTermination = tmpTermination.times(r).div(n);\n\t\t\tif (tmpTermination.abs().lt(tmpTolerance)) break;\n\t\t\ttmpSummation = tmpSummation.plus(tmpTermination);\n\t\t\tn++;\n\t\t\t// Hard safety cap for pathological inputs (shouldnt be possible with step 2's range reduction):\n\t\t\tif (n > 2000)\n\t\t\t{\n\t\t\t\tthis.log.warn(`Fable expPrecise warning: Taylor series failed to converge after 2000 iterations for value of ${pValue}.`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 4. Recompose: exp(x) = 2^k * exp(r)\n\t\tconst tmpTwo = new this.bigNumber(2);\n\t\tconst tmpAbsoluteValueOfK = k.abs().toNumber(); // k is integer; big.js pow requires a JS integer\n\t\tlet tmpTwoToThePowerOfAbsoluteK = tmpAbsoluteValueOfK === 0 ? new this.bigNumber(1) : tmpTwo.pow(tmpAbsoluteValueOfK);\n\t\tconst tmpResult = k.gte(0) ? tmpSummation.times(tmpTwoToThePowerOfAbsoluteK) : tmpSummation.div(tmpTwoToThePowerOfAbsoluteK);\n\n\t\t// 5. Restore global decimal precision\n\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\treturn tmpResult.round(tmpDecimalPrecision).toString();\n\t}\n\n\tcleanValueObject(pValueObject)\n\t{\n\t\tif (typeof (pValueObject) !== 'object')\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\t//TODO: is this right?\n\t\tlet tmpCleanedObject = {};\n\t\tlet tmpKeys = Object.keys(pValueObject);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(pValueObject[tmpKeys[i]], NaN);\n\t\t\tif (!isNaN(tmpValue))\n\t\t\t{\n\t\t\t\ttmpCleanedObject[tmpKeys[i]] = tmpValue;\n\t\t\t}\n\t\t}\n\t\treturn tmpCleanedObject;\n\t}\n\n\t/**\n\t * Make a histogram of representative counts for exact values (.tostring() is the keys to count)\n\t * @param {Array} pValueSet\n\t * @param {string} pValueAddress\n\t */\n\thistogramDistributionByExactValue(pValueObjectSet, pValueAddress, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpHistogram = {};\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest).toString();\n\n\t\t\tif (!(tmpValue in tmpHistogram))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = 0;\n\t\t\t}\n\t\t\ttmpHistogram[tmpValue] = tmpHistogram[tmpValue] + 1;\n\t\t}\n\n\t\treturn tmpHistogram;\n\t}\n\n\thistogramDistributionByExactValueFromInternalState(pValueObjectSetAddress, pValueAddress)\n\t{\n\t\tif (!pValueObjectSetAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObjectSet = this.fable.Utility.getInternalValueByHash(pValueObjectSetAddress);\n\t\treturn this.histogramDistributionByExactValue(tmpValueObjectSet, pValueAddress);\n\t}\n\n\t/**\n\t * Make a histogram of representative counts for exact values (.tostring() is the keys to count)\n\t * @param {Array} pValueSet\n\t * @param {string} pValueAddress\n\t */\n\thistogramAggregationByExactValue(pValueObjectSet, pValueAddress, pValueAmountAddress, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress || !pValueAmountAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpHistogram = {};\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest);\n\t\t\tif (typeof(tmpValue) === undefined)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpAmount = this.parsePrecise(this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAmountAddress, pManifest), NaN);\n\n\t\t\tif (!(tmpValue in tmpHistogram))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = 0;\n\t\t\t}\n\n\t\t\tif (!isNaN(tmpAmount))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = this.addPrecise(tmpHistogram[tmpValue], tmpAmount);\n\t\t\t}\n\t\t}\n\n\t\treturn tmpHistogram;\n\t}\n\n\t/**\n\t * Aggregates a histogram by exact value from an internal state object.\n\t *\n\t * @param {string} pValueObjectSetAddress - The address of the internal value object set.\n\t * @param {string} pValueAddress - The address of the value to aggregate by.\n\t * @param {string} pValueAmountAddress - The address of the amount to aggregate.\n\t * @returns {Object} The aggregated histogram object. Returns an empty object if the value object set address is not provided.\n\t */\n\thistogramAggregationByExactValueFromInternalState(pValueObjectSetAddress, pValueAddress, pValueAmountAddress)\n\t{\n\t\tif (!pValueObjectSetAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObjectSet = this.fable.Utility.getInternalValueByHash(pValueObjectSetAddress);\n\t\treturn this.histogramAggregationByExactValue(tmpValueObjectSet, pValueAddress, pValueAmountAddress);\n\t}\n\n\t/**\n\t * Given a value object set (an array of objects), find a specific entry when\n\t * sorted by a specific value address.  Supports -1 syntax for last entry.\n\t * @param {Array} pValueObjectSet\n\t * @param {string} pValueAddress\n\t * @param {Object} pManifest\n\t */\n\tentryInSet(pValueObjectSet, pValueAddress, pEntryIndex)\n\t{\n\t\tconst tmpEntryIndex = typeof pEntryIndex === 'number' ? pEntryIndex : parseInt(pEntryIndex);\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isNaN(tmpEntryIndex) || tmpEntryIndex >= pValueObjectSet.length)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpValueArray = pValueObjectSet.toSorted((pLeft, pRight) => { return this.comparePrecise(pLeft[pValueAddress], pRight[pValueAddress]); });\n\t\tlet tmpIndex = (tmpEntryIndex < 0) ? tmpValueArray.length + tmpEntryIndex : tmpEntryIndex;\n\t\treturn tmpValueArray[tmpIndex];\n\t}\n\n\t/**\n\t * Finds the smallest value in a set of objects based on a specified value address.\n\t *\n\t * @param {Object[]} pValueObjectSet - An array of objects to search through.\n\t * @param {string} pValueAddress - The key or path used to access the value within each object.\n\t * @returns {*} The smallest value found in the set at the specified value address.\n\t */\n\tsmallestInSet(pValueObjectSet, pValueAddress)\n\t{\n\t\treturn this.entryInSet(pValueObjectSet, pValueAddress, 0);\n\t}\n\n\t/**\n\t * Finds the largest value in a set of objects based on a specified value address.\n\t *\n\t * @param {Object[]} pValueObjectSet - An array of objects to search through.\n\t * @param {string} pValueAddress - The address (key or path) within each object to compare values.\n\t * @returns {*} The largest value found at the specified address in the set of objects.\n\t */\n\tlargestInSet(pValueObjectSet, pValueAddress)\n\t{\n\t\treturn this.entryInSet(pValueObjectSet, pValueAddress, -1);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to sum.  Expects\n\t * an address to put the cumulative summation as well.\n\t *\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {Object} pManifest - The manifest to use for value retrieval and setting\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\tcumulativeSummation(pValueObjectSet, pValueAddress, pCumulationResultAddress, pManifest)\n\t{\n\t\treturn this.iterativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, \"1.0\", \"add\", \"0.0\", true, pManifest);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to sum.  Expects\n\t * an address to put the cumulative summation as well.\n\t *\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {string} pStartingValue - The (optional) address of the value to start with\n\t * @param {Object} pManifest - The manifest to use for value retrieval and setting\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\tsubtractingSummation(pValueObjectSet, pValueAddress, pCumulationResultAddress, pStartingValue, pManifest)\n\t{\n\t\tlet tmpProcessFirstRow = true;\n\t\t// If the starting value comes from somewhere else, we want to subtract the first row from it.\n\t\tif (typeof (pStartingValue) === 'undefined' || pStartingValue === null)\n\t\t{\n\t\t\ttmpProcessFirstRow = false;\n\t\t}\n\t\treturn this.iterativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, \"1.0\", \"subtract\", pStartingValue, tmpProcessFirstRow, pManifest);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to perform an iterative mathematical operation on.\n\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pValueMultiplier - The multiplier to apply to each value before summation\n\t * @param {string} pSummationOperation - The operation to perform for summation: +, -, *, / (and some textual equivalents)\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {string} pStartingValue - The address of the value to process from; defaults to the first row\n\t * @param {boolean} pProcessFirstRowWithAValue - Whether to process the first row's value from all subsequent rows\n\t * @param {Object} pManifest - The manifest to\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\titerativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, pValueMultiplier, pSummationOperation, pStartingValue, pProcessFirstRowWithAValue, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress || !pCumulationResultAddress)\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\t// By default don't subtract the first row from the value\n\t\tlet tmpProcessFirstRow = (typeof(pProcessFirstRowWithAValue) === 'undefined') ? false : pProcessFirstRowWithAValue;\n\n\t\tlet tmpValueMultiplier;\n\t\tif (pValueMultiplier && pValueMultiplier !== '')\n\t\t{\n\t\t\ttmpValueMultiplier = this.parsePrecise(pValueMultiplier);\n\t\t}\n\t\tif (isNaN(tmpValueMultiplier))\n\t\t{\n\t\t\ttmpValueMultiplier = this.parsePrecise(\"1.0\");\n\t\t}\n\n\t\t// Default to start from the current value address\n\t\tlet tmpSummationValue;\n\t\t// This logic ensures we don't default to 0 when pStartingValue is an empty string\n\t\tif (pStartingValue || (pStartingValue !== ''))\n\t\t{\n\t\t\ttmpSummationValue = this.parsePrecise(pStartingValue);\n\t\t}\n\t\tif (isNaN(tmpSummationValue) || typeof(pStartingValue) === 'undefined' || pStartingValue === null)\n\t\t{\n\t\t\ttmpSummationValue = '';\n\t\t}\n\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest));\n\t\t\t// Since summation might start on a row after the first,\n\t\t\tlet tmpFirstRowWithValue = false;\n\t\t\tif ((tmpSummationValue === '') && tmpValue && !isNaN(tmpSummationValue))\n\t\t\t{\n\t\t\t\t// Try to grab the summation value from the first row with a value\n\t\t\t\ttmpSummationValue = tmpValue;\n\t\t\t\ttmpFirstRowWithValue = true;\n\t\t\t}\n\n\t\t\t// Continue on with the values as they are if the current row doesn't have a change\n\t\t\tif (isNaN(tmpValue))\n\t\t\t{\n\t\t\t\tthis.fable.Utility.setValueByHash(pValueObjectSet[i], pCumulationResultAddress, tmpSummationValue, pManifest);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmpValue = this.multiplyPrecise(tmpValue, tmpValueMultiplier);\n\n\t\t\t// Now perform the operation\n\t\t\tif (!tmpFirstRowWithValue || tmpProcessFirstRow)\n\t\t\t{\n\t\t\t\tswitch (pSummationOperation)\n\t\t\t\t{\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase 'add':\n\t\t\t\t\tcase 'plus':\n\t\t\t\t\tcase 'addition':\n\t\t\t\t\t\ttmpSummationValue = this.addPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase 'sub':\n\t\t\t\t\tcase 'minus':\n\t\t\t\t\tcase 'subtract':\n\t\t\t\t\t\ttmpSummationValue = this.subtractPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase 'mul':\n\t\t\t\t\tcase 'times':\n\t\t\t\t\tcase 'multiply':\n\t\t\t\t\t\ttmpSummationValue = this.multiplyPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase 'div':\n\t\t\t\t\tcase 'over':\n\t\t\t\t\tcase 'divide':\n\t\t\t\t\t\ttmpSummationValue = this.dividePrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.fable.Utility.setValueByHash(pValueObjectSet[i], pCumulationResultAddress, tmpSummationValue, pManifest);\n\t\t}\n\n\t\treturn pValueObjectSet;\n\t}\n\n\t/**\n\t * Finds the maximum value from a set of precise values.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to find the maximum from.\n\t * @returns {number} - The maximum value from the set.\n\t */\n\tmaxPrecise(pValueSet)\n\t{\n\t\tlet tmpMaxValue = NaN;\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMaxValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMaxValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t\tif (this.gtPrecise(tmpComparisonValue, tmpMaxValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMaxValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMaxValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMaxValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t\tif (this.gtPrecise(tmpComparisonValue, tmpMaxValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMaxValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpMaxValue;\n\t}\n\n\t/**\n\t * Finds the minimum value from a set of values.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to find the minimum from.\n\t * @returns {number} The minimum value from the set.\n\t */\n\tminPrecise(pValueSet)\n\t{\n\t\tlet tmpMinValue = NaN;\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMinValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMinValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t\tif (!isNaN(tmpComparisonValue) && this.ltPrecise(tmpComparisonValue, tmpMinValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMinValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMinValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMinValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t\tif (!isNaN(tmpComparisonValue) && this.ltPrecise(tmpComparisonValue, tmpMinValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMinValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpMinValue;\n\t}\n\n\t/**\n\t * Calculates the precise sum of values in the given value set.\n\t *\n\t * @param {Array|Object} pValueSet - The value set to calculate the sum from.\n\t * @returns {string} The precise sum value as a string.\n\t */\n\tsumPrecise(pValueSet)\n\t{\n\t\tlet tmpSumValue = \"0.0\";\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\tif (!isNaN(tmpComparisonValue))\n\t\t\t\t{\n\t\t\t\t\ttmpSumValue = this.addPrecise(tmpSumValue, tmpComparisonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\tif (!isNaN(tmpComparisonValue))\n\t\t\t\t{\n\t\t\t\t\ttmpSumValue = this.addPrecise(tmpSumValue, tmpComparisonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpSumValue;\n\t}\n\n\t/**\n\t * Calculates the precise mean of a given value set.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the mean.\n\t * @returns {string} The precise mean value as a string.\n\t */\n\tmeanPrecise(pValueSet)\n\t{\n\t\tlet tmpSumValue = this.sumPrecise(pValueSet);\n\t\tlet tmpCount = this.countSetElements(pValueSet);\n\t\tif (tmpCount == 0)\n\t\t{\n\t\t\treturn '0.0';\n\t\t}\n\t\treturn this.dividePrecise(tmpSumValue, tmpCount);\n\t}\n\n\t/**\n\t * Calculates the average of an array of values precisely.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the average of.\n\t * @returns {string} The precise average of the values.\n\t */\n\taveragePrecise(pValueSet)\n\t{\n\t\treturn this.meanPrecise(pValueSet);\n\t}\n\n\t/**\n\t * Calculates the precise median value of a given value set.\n\t *\n\t * @param {Array<number>} pValueSet - The array of values to calculate the median from.\n\t * @returns {number|string} - The median value of the given value set. If the value set is empty, returns '0.0'.\n\t */\n\tmedianPrecise(pValueSet)\n\t{\n\t\tlet tmpCount = this.countSetElements(pValueSet);\n\t\t// If there are no elements, return 0 ... should this be NaN?\n\t\tif (tmpCount == 0)\n\t\t{\n\t\t\treturn '0.0';\n\t\t}\n\n\t\tlet tmpSortedValueSet = this.sortSetPrecise(pValueSet);\n\t\tlet tmpMiddleElement = Math.floor(tmpCount / 2);\n\n\t\t// If the count is odd, return the middle element\n\t\tif (tmpCount % 2 == 1)\n\t\t{\n\t\t\treturn tmpSortedValueSet[tmpMiddleElement];\n\t\t}\n\t\t// If the count is even, return the average of the two middle elements\n\t\telse\n\t\t{\n\t\t\tlet tmpLeftMiddleValue = tmpSortedValueSet[tmpMiddleElement - 1];\n\t\t\tlet tmpRightMiddleValue = tmpSortedValueSet[tmpMiddleElement];\n\t\t\treturn this.dividePrecise(this.addPrecise(tmpLeftMiddleValue, tmpRightMiddleValue), 2);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the mode (most frequently occurring value) of a given value set using precise mode calculation.\n\t *\n\t * @param {Array} pValueSet - The array of values to calculate the mode from.\n\t * @returns {Array} - An array containing the mode value(s) from the given value set.\n\t */\n\tmodePrecise(pValueSet)\n\t{\n\t\tlet tmpHistogram = this.bucketSetPrecise(pValueSet);\n\t\tlet tmpMaxCount = 0;\n\n\t\t// Philosophical question about whether the values should be returned sorted.\n\t\tlet tmpHistogramValueSet = Object.keys(tmpHistogram);\n\n\t\tlet tmpModeValueSet = [];\n\n\t\tfor (let i = 0; i < tmpHistogramValueSet.length; i++)\n\t\t{\n\t\t\tif (tmpHistogram[tmpHistogramValueSet[i]] > tmpMaxCount)\n\t\t\t{\n\t\t\t\ttmpMaxCount = tmpHistogram[tmpHistogramValueSet[i]];\n\t\t\t\ttmpModeValueSet = [tmpHistogramValueSet[i]];\n\t\t\t}\n\t\t\telse if (tmpHistogram[tmpHistogramValueSet[i]] == tmpMaxCount)\n\t\t\t{\n\t\t\t\ttmpModeValueSet.push(tmpHistogramValueSet[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn tmpModeValueSet;\n\t}\n\n\t/**\n\t * Calculates the variance of a given value set using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the variance from.\n\t * @param {boolean} [pIsPopulation=false] - Whether to calculate population variance (true) or sample variance (false).\n\t *\n\t * @return {string} - The variance of the given value set.\n\t */\n\tvariancePrecise(pValueSet, pIsPopulation = false)\n\t{\n\t\tlet tmpValueSet = pValueSet;\n\t\tif (!Array.isArray(tmpValueSet) && typeof tmpValueSet === 'object')\n\t\t{\n\t\t\ttmpValueSet = Object.keys(tmpValueSet).map((pKey) => tmpValueSet[pKey]);\n\t\t}\n\t\tconst tmpMeanValue = this.meanPrecise(tmpValueSet);\n\t\tconst tmpVarianceSum = tmpValueSet.reduce((pAccumulator, pValue) =>\n\t\t{\n\t\t\tconst tmpDiff = this.subtractPrecise(pValue, tmpMeanValue);\n\t\t\tconst tmpSquaredDiff = this.multiplyPrecise(tmpDiff, tmpDiff);\n\t\t\treturn this.addPrecise(pAccumulator, tmpSquaredDiff);\n\t\t}, '0.0');\n\t\treturn this.dividePrecise(tmpVarianceSum, pIsPopulation ? tmpValueSet.length : tmpValueSet.length - 1);\n\t}\n\n\t/**\n\t * Calculates the variance of a given population of values using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the variance from.\n\t *\n\t * @return {string} - The variance of the given value set.\n\t */\n\tpopulationVariancePrecise(pValueSet)\n\t{\n\t\treturn this.variancePrecise(pValueSet, true);\n\t}\n\n\t/**\n\t * Calculates the standard deviation of a given value set using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the standard deviation from.\n\t * @param {boolean} [pIsPopulation=false] - Whether to calculate population variance (true) or sample variance (false).\n\t *\n\t * @return {string} - The standard deviation of the given value set.\n\t */\n\tstandardDeviationPrecise(pValueSet, pIsPopulation = false)\n\t{\n\t\treturn this.sqrtPrecise(this.variancePrecise(pValueSet, pIsPopulation));\n\t}\n\n\t/**\n\t * Calculates the standard deviation of a given population of values using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the standard deviation from.\n\t *\n\t * @return {string} - The standard deviation of the given value set.\n\t */\n\tpopulationStandardDeviationPrecise(pValueSet)\n\t{\n\t\treturn this.standardDeviationPrecise(pValueSet, true);\n\t}\n\n\t/**\n\t * Performs an nth degree polynomial regression on the given data points.\n\t *\n\t * @param {Array<number|string>} pXVector - The x-coordinates of the data points.\n\t * @param {Array<number|string>} pYVector - The y-coordinates of the data points.\n\t * @param {number} [pDegree=2] - The degree of the polynomial to fit.\n\t *\n\t * @return {Array<number|string>} The coefficients of the fitted polynomial, starting from the constant term.\n\t */\n\tpolynomialRegression(pXVector, pYVector, pDegree = 2)\n\t{\n\t\tconst n = pDegree;\n\t\tconst tmpXMatrix = [];\n\t\tconst tmpYVector = pYVector;\n\n\t\t// Build Vandermonde matrix\n\t\tfor (let i = 0; i < pXVector.length; ++i)\n\t\t{\n\t\t\tconst row = [];\n\t\t\tfor (let j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\trow.push(this.powerPrecise(pXVector[i], j));\n\t\t\t}\n\t\t\ttmpXMatrix.push(row);\n\t\t}\n\n\t\t// Compute coefficients\n\t\tconst X_T = this.matrixTranspose(tmpXMatrix);\n\t\tconst XTX = this.matrixMultiply(X_T, tmpXMatrix);\n\t\tconst XTY = this.matrixMultiply(X_T, tmpYVector.map(v => [v]));\n\t\tconst XTX_inv = this.matrixInverse(XTX);\n\t\tconst A = this.matrixMultiply(XTX_inv, XTY);\n\n\t\t// Flatten coefficients\n\t\treturn A.map((row) => row[0]);\n\t}\n\n\t/**\n\t * Compute least squares regression coefficients for multivariable linear interpolation.\n\t *\n\t * @param {Array<Array<number|string>> | Array<number|string> | string} pIndependentVariableVectors - array of arrays [[x11, x12, ...], [x21, x22, ...], ...] or single array for single variable.\n\t * @param {Array<number|string>|string} pDependentVariableVector - array of target values [y1, y2, ...]\n\t *\n\t * @return {Array<number|string>} - linear coefficients [b0, b1, ..., bn] where y = b0 + b1*x1 + b2*x2 + ... + bn*xn\n\t */\n\tleastSquares(pIndependentVariableVectors, pDependentVariableVector)\n\t{\n\t\tconst tmpIndependentVariableVectors = Array.isArray(pIndependentVariableVectors) ? (Array.isArray(pIndependentVariableVectors[0]) ? this.matrixTranspose(pIndependentVariableVectors) : pIndependentVariableVectors.map(value => [value])) : [ [ pIndependentVariableVectors ] ];\n\t\tconst tmpDependentVariableVector = Array.isArray(pDependentVariableVector) ? pDependentVariableVector : [ pDependentVariableVector ];\n\t\tif (tmpIndependentVariableVectors.length  === 1)\n\t\t{\n\t\t\t// degenerate case: only one independent variable value, result is just a y-intercept\n\t\t\treturn [ tmpDependentVariableVector[0], '0.0' ];\n\t\t}\n\t\t// Add bias term (intercept)\n\t\tconst tmpIndependentVariableMatrixWithBiasTerm = tmpIndependentVariableVectors.map(row => [1, ...row]);\n\n\t\t// Compute X^T * X\n\t\tconst tmpIndependentTermTranpose = this.matrixTranspose(tmpIndependentVariableMatrixWithBiasTerm);\n\t\tconst tmpDependentTransposeMultiplication = this.matrixMultiply(tmpIndependentTermTranpose, tmpIndependentVariableMatrixWithBiasTerm);\n\n\t\t// Compute X^T * y\n\t\tconst tmpIndependentTransposeMultiplication = this.matrixVectorMultiply(tmpIndependentTermTranpose, tmpDependentVariableVector);\n\n\t\t// Solve (XtX) * beta = Xty\n\t\tconst tmpLinearCoefficients = this.gaussianElimination(tmpDependentTransposeMultiplication, tmpIndependentTransposeMultiplication);\n\n\t\treturn tmpLinearCoefficients;\n\t}\n\n\t/**\n\t * Helper function to transpose a matrix\n\t *\n\t * @param {Array<Array<number|string>>} pInputMatrix - matrix to transpose\n\t *\n\t * @return {Array<Array<number|string>>} - transposed matrix\n\t */\n\tmatrixTranspose(pInputMatrix)\n\t{\n\t\treturn pInputMatrix[0].map((_, i) => pInputMatrix.map((row) => row[i]));\n\t}\n\n\tmatrixMultiply(pLHSMatrix, pRHSMatrix)\n\t{\n\t\tconst result = Array(pLHSMatrix.length)\n\t\t\t.fill(0)\n\t\t\t.map(() => Array(pRHSMatrix[0].length).fill(0));\n\t\tfor (let i = 0; i < pLHSMatrix.length; ++i)\n\t\t{\n\t\t\tfor (let j = 0; j < pRHSMatrix[0].length; ++j)\n\t\t\t{\n\t\t\t\tfor (let k = 0; k < pRHSMatrix.length; ++k)\n\t\t\t\t{\n\t\t\t\t\tresult[i][j] = this.addPrecise(result[i][j], this.multiplyPrecise(pLHSMatrix[i][k], pRHSMatrix[k][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Array<Array<number|string>>} pMatrix - matrix to multiply\n\t * @param {Array<number|string>} pVector - vector to multiply\n\t *\n\t * @return {Array<number|string>} - result vector\n\t */\n\tmatrixVectorMultiply(pMatrix, pVector)\n\t{\n\t\tconst result = Array(pMatrix.length).fill(0);\n\t\tfor (let i = 0; i < pMatrix.length; ++i)\n\t\t{\n\t\t\tfor (let j = 0; j < pMatrix[0].length; ++j)\n\t\t\t{\n\t\t\t\tresult[i] = this.addPrecise(result[i], this.multiplyPrecise(pMatrix[i][j], pVector[j]));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Matrix inverse (using Gaussian elimination)\n\t *\n\t * @param {Array<Array<number|string>>} pMatrix - matrix to invert\n\t *\n\t * @return {Array<Array<number|string>>} - inverted matrix\n\t */\n\tmatrixInverse(pMatrix)\n\t{\n\t\tconst n = pMatrix.length;\n\t\tconst tmpIdentityMatrix = pMatrix.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));\n\t\tconst tmpAugmentedMatrix = pMatrix.map((row, i) => row.concat(tmpIdentityMatrix[i]));\n\n\t\tfor (let i = 0; i < n; ++i)\n\t\t{\n\t\t\t// Pivot\n\t\t\tlet maxRow = i;\n\t\t\tfor (let k = i + 1; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (this.gtPrecise(this.absPrecise(tmpAugmentedMatrix[k][i]), this.absPrecise(tmpAugmentedMatrix[maxRow][i])))\n\t\t\t\t{\n\t\t\t\t\tmaxRow = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\t[tmpAugmentedMatrix[i], tmpAugmentedMatrix[maxRow]] = [tmpAugmentedMatrix[maxRow], tmpAugmentedMatrix[i]];\n\n\t\t\t// divide by pivot\n\t\t\tconst tmpPivotValue = tmpAugmentedMatrix[i][i];\n\t\t\tfor (let j = 0; j < 2 * n; ++j)\n\t\t\t{\n\t\t\t\ttmpAugmentedMatrix[i][j] = this.dividePrecise(tmpAugmentedMatrix[i][j], tmpPivotValue);\n\t\t\t}\n\n\t\t\t// Eliminate other rows\n\t\t\tfor (let k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (k === i)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst tmpFactor = tmpAugmentedMatrix[k][i];\n\t\t\t\tfor (let j = 0; j < 2 * n; ++j)\n\t\t\t\t{\n\t\t\t\t\ttmpAugmentedMatrix[k][j] = this.subtractPrecise(tmpAugmentedMatrix[k][j], this.multiplyPrecise(tmpFactor, tmpAugmentedMatrix[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract right half (inverse)\n\t\treturn tmpAugmentedMatrix.map((row) => row.slice(n));\n\t}\n\n\n\t/**\n\t * Compute solution to linear system using Gaussian elimination.\n\t *\n\t * @param {Array<Array<number|string>>} pCoefficientMatrix - Coefficient matrix\n\t * @param {Array<number|string>} pVector - Right-hand side vector\n\t *\n\t * @return {Array<number|string>} - Solution vector x\n\t */\n\tgaussianElimination(pCoefficientMatrix, pVector)\n\t{\n\t\t// Solve A*x = b using Gaussian elimination\n\t\tconst n = pCoefficientMatrix.length;\n\t\tconst tmpAugmentedMatrix = pCoefficientMatrix.map((row, i) => [...row, pVector[i]]);\n\n\t\tfor (let i = 0; i < n; ++i)\n\t\t{\n\t\t\t// Pivot\n\t\t\tlet maxRow = i;\n\t\t\tfor (let k = i + 1; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (this.gtPrecise(this.absPrecise(tmpAugmentedMatrix[k][i]), this.absPrecise(tmpAugmentedMatrix[maxRow][i])))\n\t\t\t\t{\n\t\t\t\t\tmaxRow = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst tmpSwapValue = tmpAugmentedMatrix[i];\n\t\t\ttmpAugmentedMatrix[i] = tmpAugmentedMatrix[maxRow];\n\t\t\ttmpAugmentedMatrix[maxRow] = tmpSwapValue;\n\n\t\t\t// Normalize pivot row\n\t\t\tconst tmpPivotValue = tmpAugmentedMatrix[i][i];\n\t\t\tif (this.comparePrecise(tmpPivotValue, 0) == 0)\n\t\t\t{\n\t\t\t\tthrow new Error('Matrix not invertible');\n\t\t\t}\n\t\t\tfor (let j = i; j <= n; ++j)\n\t\t\t{\n\t\t\t\ttmpAugmentedMatrix[i][j] = this.dividePrecise(tmpAugmentedMatrix[i][j], tmpPivotValue);\n\t\t\t}\n\n\t\t\t// Eliminate other rows\n\t\t\tfor (let k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (k === i)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst tmpFactor = tmpAugmentedMatrix[k][i];\n\t\t\t\tfor (let j = i; j <= n; ++j)\n\t\t\t\t{\n\t\t\t\t\ttmpAugmentedMatrix[k][j] = this.subtractPrecise(tmpAugmentedMatrix[k][j], this.multiplyPrecise(tmpFactor, tmpAugmentedMatrix[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract solution\n\t\treturn tmpAugmentedMatrix.map((row) => row[n]);\n\t}\n\n\tgenerateValueFromEasingDescription(pEasingConfiguration)\n\t{\n\t\t// Branch based on type\n\t\tswitch (pEasingConfiguration.Easing)\n\t\t{\n\t\t\tcase 'LINEAR':\n\t\t\tdefault:\n\t\t\t\tlet tmpDomainRange = pEasingConfiguration.DomainLength;\n\n\t\t\t\tif (this.comparePrecise(tmpDomainRange, 0) == 0)\n\t\t\t\t{\n\t\t\t\t\treturn this.parsePrecise(pEasingConfiguration.DomainRangeStart);\n\t\t\t\t}\n\n\t\t\t\t// Now, generate a random number and then multiply it to fit in the domain length\n\t\t\t\tlet tmpRandomFraction = Math.random();\n\t\t\t\t// Scale it to the domain\n\t\t\t\tlet tmpScaledValue = this.multiplyPrecise(tmpRandomFraction, tmpDomainRange);\n\t\t\t\t// Shift it to the range start\n\t\t\t\treturn this.addPrecise(pEasingConfiguration.DomainRangeStart, tmpScaledValue);\n\t\t}\n\t}\n\n\t/**\n\t * Predicts the dependent variable using a regression model.\n\t *\n\t * @param {Array<number|string>} pRegressionCoefficients - The regression coefficients [b0, b1, ..., bn].\n\t * @param {Array<number|string>|number|string} pIndependentVariableVector - The independent variable values [x1, x2, ..., xn] or single value for single variable.\n\t *\n\t * @return {number|string} - The predicted dependent variable value.\n\t */\n\tpredictFromRegressionModel(pRegressionCoefficients, pIndependentVariableVector)\n\t{\n\t\tlet tmpIndependentVariableVector = pIndependentVariableVector;\n\t\tif (!Array.isArray(pIndependentVariableVector))\n\t\t{\n\t\t\ttmpIndependentVariableVector = [ pIndependentVariableVector ];\n\t\t}\n\t\treturn pRegressionCoefficients.slice(1).reduce((sum, b, i) =>\n\t\t\t{\n\t\t\t\treturn this.addPrecise(sum, this.multiplyPrecise(b, tmpIndependentVariableVector[i]));\n\t\t\t}, pRegressionCoefficients[0]);\n\t}\n\n\t/**\n\t * Evaluate a point on a cubic bezier curve at parameter t.\n\t *\n\t * B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n\t *\n\t * @param {number|string} pP0 - First control point value\n\t * @param {number|string} pP1 - Second control point value\n\t * @param {number|string} pP2 - Third control point value\n\t * @param {number|string} pP3 - Fourth control point value\n\t * @param {number|string} pT - Parameter t in [0,1]\n\t *\n\t * @return {string} - The bezier curve value at parameter t\n\t */\n\tbezierPoint(pP0, pP1, pP2, pP3, pT)\n\t{\n\t\tlet tmpT = this.parsePrecise(pT, 0);\n\t\tlet tmpOneMinusT = this.subtractPrecise(1, tmpT);\n\n\t\t// (1-t)^3 * P0\n\t\tlet tmpTerm0 = this.multiplyPrecise(this.powerPrecise(tmpOneMinusT, 3), pP0);\n\t\t// 3 * (1-t)^2 * t * P1\n\t\tlet tmpTerm1 = this.multiplyPrecise(this.multiplyPrecise(this.multiplyPrecise(3, this.powerPrecise(tmpOneMinusT, 2)), tmpT), pP1);\n\t\t// 3 * (1-t) * t^2 * P2\n\t\tlet tmpTerm2 = this.multiplyPrecise(this.multiplyPrecise(this.multiplyPrecise(3, tmpOneMinusT), this.powerPrecise(tmpT, 2)), pP2);\n\t\t// t^3 * P3\n\t\tlet tmpTerm3 = this.multiplyPrecise(this.powerPrecise(tmpT, 3), pP3);\n\n\t\treturn this.addPrecise(this.addPrecise(tmpTerm0, tmpTerm1), this.addPrecise(tmpTerm2, tmpTerm3));\n\t}\n\n\t/**\n\t * Fit a cubic bezier curve to a set of data points using least-squares optimization.\n\t *\n\t * Given arrays of X and Y values representing data points, this function finds the four\n\t * control points (P0, P1, P2, P3) of a cubic bezier curve that best fits the data.\n\t *\n\t * The first and last control points are pinned to the first and last data points.\n\t * The interior control points (P1, P2) are found by least-squares minimization of\n\t * the squared distances between the data points and the curve.\n\t *\n\t * Parameter t values are assigned by chord-length parameterization: each data point\n\t * gets a t value proportional to its cumulative distance along the polyline.\n\t *\n\t * @param {Array<number|string>} pXValues - Array of x coordinates\n\t * @param {Array<number|string>} pYValues - Array of y coordinates\n\t *\n\t * @return {Array<Array<string>>} - Four control points as [[x0,y0], [x1,y1], [x2,y2], [x3,y3]]\n\t */\n\tbezierCurveFit(pXValues, pYValues)\n\t{\n\t\tif (!Array.isArray(pXValues) || !Array.isArray(pYValues))\n\t\t{\n\t\t\tthis.log.warn('bezierCurveFit: pXValues and pYValues must be arrays');\n\t\t\treturn [[0, 0], [0, 0], [0, 0], [0, 0]];\n\t\t}\n\n\t\tlet tmpN = Math.min(pXValues.length, pYValues.length);\n\n\t\tif (tmpN < 2)\n\t\t{\n\t\t\tthis.log.warn('bezierCurveFit: need at least 2 data points');\n\t\t\treturn [[0, 0], [0, 0], [0, 0], [0, 0]];\n\t\t}\n\n\t\t// Pin P0 and P3 to the first and last data points\n\t\tlet tmpP0x = this.parsePrecise(pXValues[0], 0);\n\t\tlet tmpP0y = this.parsePrecise(pYValues[0], 0);\n\t\tlet tmpP3x = this.parsePrecise(pXValues[tmpN - 1], 0);\n\t\tlet tmpP3y = this.parsePrecise(pYValues[tmpN - 1], 0);\n\n\t\tif (tmpN === 2)\n\t\t{\n\t\t\t// With only two points, place control points at 1/3 and 2/3 along the line\n\t\t\tlet tmpP1x = this.addPrecise(tmpP0x, this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3));\n\t\t\tlet tmpP1y = this.addPrecise(tmpP0y, this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3));\n\t\t\tlet tmpP2x = this.addPrecise(tmpP0x, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3), 2));\n\t\t\tlet tmpP2y = this.addPrecise(tmpP0y, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3), 2));\n\t\t\treturn [\n\t\t\t\t[tmpP0x.toString(), tmpP0y.toString()],\n\t\t\t\t[tmpP1x.toString(), tmpP1y.toString()],\n\t\t\t\t[tmpP2x.toString(), tmpP2y.toString()],\n\t\t\t\t[tmpP3x.toString(), tmpP3y.toString()]\n\t\t\t];\n\t\t}\n\n\t\t// Compute chord-length parameterization for t values\n\t\tlet tmpDistances = [0];\n\t\tfor (let i = 1; i < tmpN; i++)\n\t\t{\n\t\t\tlet tmpDx = this.subtractPrecise(pXValues[i], pXValues[i - 1]);\n\t\t\tlet tmpDy = this.subtractPrecise(pYValues[i], pYValues[i - 1]);\n\t\t\tlet tmpDist = this.sqrtPrecise(this.addPrecise(this.multiplyPrecise(tmpDx, tmpDx), this.multiplyPrecise(tmpDy, tmpDy)));\n\t\t\ttmpDistances.push(this.addPrecise(tmpDistances[i - 1], tmpDist));\n\t\t}\n\n\t\tlet tmpTotalLength = tmpDistances[tmpN - 1];\n\t\tlet tmpTValues = [];\n\t\tfor (let i = 0; i < tmpN; i++)\n\t\t{\n\t\t\tif (this.comparePrecise(tmpTotalLength, 0) == 0)\n\t\t\t{\n\t\t\t\ttmpTValues.push(this.dividePrecise(i, tmpN - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpTValues.push(this.dividePrecise(tmpDistances[i], tmpTotalLength));\n\t\t\t}\n\t\t}\n\n\t\t// Build the least-squares system for interior control points P1 and P2.\n\t\t// For each data point i with parameter t_i:\n\t\t//   B(t_i) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n\t\t//\n\t\t// We want to minimize sum of |DataPoint_i - B(t_i)|^2 over P1 and P2.\n\t\t// Let A1(t) = 3*(1-t)^2*t and A2(t) = 3*(1-t)*t^2.\n\t\t// Then: A1(t)*P1 + A2(t)*P2 = DataPoint - (1-t)^3*P0 - t^3*P3\n\t\t//\n\t\t// This gives a 2x2 linear system (solved independently for x and y).\n\n\t\tlet tmpC11 = 0, tmpC12 = 0, tmpC22 = 0;\n\t\tlet tmpRx1 = 0, tmpRx2 = 0;\n\t\tlet tmpRy1 = 0, tmpRy2 = 0;\n\n\t\tfor (let i = 0; i < tmpN; i++)\n\t\t{\n\t\t\tlet tmpT = tmpTValues[i];\n\t\t\tlet tmpOneMinusT = this.subtractPrecise(1, tmpT);\n\n\t\t\t// Basis functions for P1 and P2\n\t\t\tlet tmpA1 = this.multiplyPrecise(this.multiplyPrecise(3, this.powerPrecise(tmpOneMinusT, 2)), tmpT);\n\t\t\tlet tmpA2 = this.multiplyPrecise(this.multiplyPrecise(3, tmpOneMinusT), this.powerPrecise(tmpT, 2));\n\n\t\t\t// Build normal equations: C * [P1; P2] = R\n\t\t\ttmpC11 = this.addPrecise(tmpC11, this.multiplyPrecise(tmpA1, tmpA1));\n\t\t\ttmpC12 = this.addPrecise(tmpC12, this.multiplyPrecise(tmpA1, tmpA2));\n\t\t\ttmpC22 = this.addPrecise(tmpC22, this.multiplyPrecise(tmpA2, tmpA2));\n\n\t\t\t// Right-hand side: DataPoint - (1-t)^3*P0 - t^3*P3\n\t\t\tlet tmpB0 = this.powerPrecise(tmpOneMinusT, 3);\n\t\t\tlet tmpB3 = this.powerPrecise(tmpT, 3);\n\n\t\t\tlet tmpResidualX = this.subtractPrecise(this.subtractPrecise(pXValues[i], this.multiplyPrecise(tmpB0, tmpP0x)), this.multiplyPrecise(tmpB3, tmpP3x));\n\t\t\tlet tmpResidualY = this.subtractPrecise(this.subtractPrecise(pYValues[i], this.multiplyPrecise(tmpB0, tmpP0y)), this.multiplyPrecise(tmpB3, tmpP3y));\n\n\t\t\ttmpRx1 = this.addPrecise(tmpRx1, this.multiplyPrecise(tmpA1, tmpResidualX));\n\t\t\ttmpRx2 = this.addPrecise(tmpRx2, this.multiplyPrecise(tmpA2, tmpResidualX));\n\t\t\ttmpRy1 = this.addPrecise(tmpRy1, this.multiplyPrecise(tmpA1, tmpResidualY));\n\t\t\ttmpRy2 = this.addPrecise(tmpRy2, this.multiplyPrecise(tmpA2, tmpResidualY));\n\t\t}\n\n\t\t// Solve the 2x2 system: [[C11, C12], [C12, C22]] * [P1, P2] = [R1, R2]\n\t\tlet tmpDet = this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpC22), this.multiplyPrecise(tmpC12, tmpC12));\n\n\t\tlet tmpP1x, tmpP1y, tmpP2x, tmpP2y;\n\n\t\tif (this.comparePrecise(this.absPrecise(tmpDet), '1e-20') < 0)\n\t\t{\n\t\t\t// Degenerate case: place control points at 1/3 and 2/3 along the line\n\t\t\ttmpP1x = this.addPrecise(tmpP0x, this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3));\n\t\t\ttmpP1y = this.addPrecise(tmpP0y, this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3));\n\t\t\ttmpP2x = this.addPrecise(tmpP0x, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3), 2));\n\t\t\ttmpP2y = this.addPrecise(tmpP0y, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3), 2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpP1x = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC22, tmpRx1), this.multiplyPrecise(tmpC12, tmpRx2)), tmpDet);\n\t\t\ttmpP1y = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC22, tmpRy1), this.multiplyPrecise(tmpC12, tmpRy2)), tmpDet);\n\t\t\ttmpP2x = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpRx2), this.multiplyPrecise(tmpC12, tmpRx1)), tmpDet);\n\t\t\ttmpP2y = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpRy2), this.multiplyPrecise(tmpC12, tmpRy1)), tmpDet);\n\t\t}\n\n\t\treturn [\n\t\t\t[tmpP0x.toString(), tmpP0y.toString()],\n\t\t\t[tmpP1x.toString(), tmpP1y.toString()],\n\t\t\t[tmpP2x.toString(), tmpP2y.toString()],\n\t\t\t[tmpP3x.toString(), tmpP3y.toString()]\n\t\t];\n\t}\n}\n\nmodule.exports = FableServiceMath;\n\n},{\"./Fable-SetConcatArray.js\":183,\"fable-serviceproviderbase\":59}],172:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\n/**\n* Precedent Meta-Templating\n* @author      Steven Velozo <steven@velozo.com>\n* @description Process text stream trie and postfix tree, parsing out meta-template expression functions.\n*/\nconst libWordTree = require(`./Fable-Service-MetaTemplate/MetaTemplate-WordTree.js`);\nconst libStringParser = require(`./Fable-Service-MetaTemplate/MetaTemplate-StringParser.js`);\n\n\nclass FableServiceMetaTemplate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'MetaTemplate';\n\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser(this.fable);\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\n\taddPattern(pPatternStart, pPatternEnd, pParser, pParserContext)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser, pParserContext);\n\t}\n\n\taddPatternBoth(pPatternStart, pPatternEnd, pParser, pParserPromise, pParserContext)\n\t{\n\t\treturn this.WordTree.addPatternBoth(pPatternStart, pPatternEnd, pParser, pParserPromise, pParserContext);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @param {function} fCallback - The callback function to call when a pattern is matched\n\t * @param {array} pDataContext - The history of data objects already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\tif (this.LogNoisiness > 4)\n\t\t{\n\t\t\tthis.fable.log.trace(`Metatemplate parsing template string [${pString}] where the callback is a ${typeof(fCallback)}`, {TemplateData:pData});\n\t\t}\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData, fCallback, pDataContext, pScope, pState);\n\t}\n}\n\nmodule.exports = FableServiceMetaTemplate;\n\n},{\"./Fable-Service-MetaTemplate/MetaTemplate-StringParser.js\":173,\"./Fable-Service-MetaTemplate/MetaTemplate-WordTree.js\":174,\"fable-serviceproviderbase\":59}],173:[function(require,module,exports){\n/**\n* String Parser\n* @author      Steven Velozo <steven@velozo.com>\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tAsynchronous: false,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: {},\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchEnd: false\n\t\t});\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\tresetOutputBuffer (pParserState)\n\t{\n\t\t// Flush the output buffer.\n\t\tthis.flushOutputBuffer(pParserState);\n\t\t// End pattern mode\n\t\tpParserState.Pattern = false;\n\t\tpParserState.PatternStartNode = false;\n\t\tpParserState.StartPatternMatchComplete = false;\n\t\tpParserState.EndPatternMatchBegan = false;\n\t\tpParserState.PatternMatch = false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {any} pData - The data available to the template\n\t * @param {Array<any>} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData, pDataContext, pScope, pState)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && (pCharacter in pParserState.Pattern))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\t// Run the function\n\t\t\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\t\t\tif (tmpFunctionContext)\n\t\t\t\t\t{\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t}\n\t\t\t\telse if (pCharacter in pParserState.PatternStartNode.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('PatternEnd' in pParserState.Pattern)\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the t*mplate function\n\t\t\t\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\t\t\t\tif (tmpFunctionContext)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\tif (!pParserState.PatternMatch)\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pCharacter in pParserState.ParseTree)\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t */\n\texecutePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t// Trim the start and end tags off the output buffer now\n\t\tif (pParserState.Pattern.isAsync)\n\t\t{\n\t\t\t// Run the function\n\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\tif (tmpFunctionContext)\n\t\t\t{\n\t\t\t\treturn pParserState.Pattern.ParseAsync.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData,\n\t\t\t\t\t(pError, pAsyncOutput) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.fable.log.info(`Precedent ERROR: Async template error happened parsing ${pParserState.Pattern.PatternStart} ... ${pParserState.Pattern.PatternEnd}: ${pError}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpParserState.OutputBuffer = pAsyncOutput;\n\t\t\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn pParserState.Pattern.ParseAsync(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData,\n\t\t\t\t\t(pError, pAsyncOutput) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.fable.log.info(`Precedent ERROR: Async template error happened parsing ${pParserState.Pattern.PatternStart} ... ${pParserState.Pattern.PatternEnd}: ${pError}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpParserState.OutputBuffer = pAsyncOutput;\n\t\t\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}, pDataContext, pScope, pState);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Run the t*mplate function\n\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\tif (tmpFunctionContext)\n\t\t\t{\n\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacterAsync\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @private\n\t */\n\tparseCharacterAsync (pCharacter, pParserState, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && (pCharacter in pParserState.Pattern))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this.executePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pCharacter in pParserState.PatternStartNode.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('PatternEnd' in pParserState.Pattern)\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this.executePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pCharacter in pParserState.ParseTree)\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\t// Without this, templates of all sizes work fine in node.  They do not in the browser.\n\t\t// Trying this out without the timout on non asynchronous template flips.\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t */\n\tparseString (pString, pParseTree, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// TODO: There is danger here if a template function attempts to functionally recurse and doesn't pass this in.\n\t\tlet tmpPreviousDataContext = (Array.isArray(pDataContext)) ? pDataContext : [];\n\t\tlet tmpDataContext = Array.from(tmpPreviousDataContext);\n\t\ttmpDataContext.push(pData)\n\n\t\tif (typeof(fCallback) !== 'function')\n\t\t{\n\t\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\t\tfor (var i = 0; i < pString.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: This is not fast.\n\t\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData, tmpDataContext, pScope, pState);\n\t\t\t}\n\n\t\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\t\treturn tmpParserState.Output;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is the async mode\n\t\t\tlet tmpParserState = this.newParserState(pParseTree);\n\t\t\ttmpParserState.Asynchronous = true;\n\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tfor (let i = 0; i < pString.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(\n\t\t\t\t\t(fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.parseCharacterAsync(pString[i], tmpParserState, pData, fCallback, tmpDataContext, pScope, pState);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\t// Flush the remaining data\n\t\t\t\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\t\t\treturn fCallback(pError, tmpParserState.Output);\n\t\t\t\t});\n\t\t}\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],174:[function(require,module,exports){\n/**\n* Word Tree\n* @author      Steven Velozo <steven@velozo.com>\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern)\n\t{\n\t\tif (!(pPattern in pTree))\n\t\t{\n\t\t\tpTree[pPattern] = {};\n\t\t}\n\n\t\treturn pTree[pPattern];\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree PatternEnd subtree\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddEndChild (pTree, pPattern)\n\t{\n\t\tif (!('PatternEnd' in pTree))\n\t\t{\n\t\t\tpTree.PatternEnd = {};\n\t\t}\n\n\t\tpTree.PatternEnd[pPattern] = {};\n\n\t\treturn pTree.PatternEnd[pPattern];\n\t}\n\n\t/** Add a Pattern to the Parse Tree with both function parameter types\n\t * @method addPatternAll\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {function} fParserAsync - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {Object} pParserContext - The context to pass to the parser function\n\t * @return {Object} The leaf parser from the tree\n\t */\n\taddPatternBoth (pPatternStart, pPatternEnd, fParser, fParserAsync, pParserContext)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart[i], i);\n\t\t}\n\n\t\tif (!('PatternEnd' in tmpLeaf))\n\t\t{\n\t\t\ttmpLeaf.PatternEnd = {};\n\t\t}\n\n\t\tlet tmpPatternEnd = (typeof(pPatternEnd) === 'string') ? pPatternEnd : pPatternStart;\n\t\tfor (let i = 0; i < tmpPatternEnd.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addEndChild(tmpLeaf, tmpPatternEnd[i], i);\n\t\t}\n\n\t\ttmpLeaf.PatternStartString = pPatternStart;\n\t\ttmpLeaf.PatternEndString = tmpPatternEnd;\n\t\ttmpLeaf.Parse = (typeof(fParser) === 'function') ? fParser :\n\t\t\t\t\t\t(typeof(fParser) === 'string') ? (pHash, pData) => { return fParser; } :\n\t\t\t\t\t\t(pHash, pData) => { return pHash; };\n\n\t\ttmpLeaf.ParseAsync = (typeof(fParserAsync) === 'function') ? fParserAsync :\n\t\t\t\t\t\t(typeof(fParserAsync) === 'string') ? (pHash, pData, fCallback) => { return fCallback(null, fParserAsync); } :\n\t\t\t\t\t\t(pHash, pData, fCallback) => { return fCallback(null, tmpLeaf.Parse(pHash, pData)); }\n\n\t\t// A \"this\" for every object\n\t\tif (pParserContext)\n\t\t{\n\t\t\ttmpLeaf.ParserContext = pParserContext;\n\t\t}\n\n\t\ttmpLeaf.isAsync = true;\n\n\t\treturn tmpLeaf;\n\t}\n\n\t/** Add a Pattern to the Parse Tree with both function parameter types\n\t * @method addPatternAll\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {Object} pParserContext - The context to pass to the parser function\n\t */\n\taddPattern (pPatternStart, pPatternEnd, fParser, pParserContext)\n\t{\n\t\treturn this.addPatternBoth(pPatternStart, pPatternEnd, fParser, null, pParserContext);\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],175:[function(require,module,exports){\nmodule.exports = (\n\t{\n\t\t\"Metadata\": {\n\t\t\t\"UUID\": false,\n\t\t\t\"Hash\": false,\n\n\t\t\t\"Name\": \"\",\n\t\t\t\"Summary\": \"\",\n\n\t\t\t\"Version\": 0\n\t\t},\n\t\t\"Status\": {\n\t\t\t\"Completed\": false,\n\t\t\t\"StepCount\": 1\n\t\t},\n\t\t\"Steps\": [],\n\t\t\"Errors\": [],\n\t\t\"Log\": []\n\t}\n);\n},{}],176:[function(require,module,exports){\nconst { PE } = require('big.js');\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst _OperationStatePrototypeString = JSON.stringify(require('./Fable-Service-Operation-DefaultSettings.js'));\n\nclass FableOperation extends libFableServiceBase\n{\n\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t// Timestamps will just be the long ints\n\t\tthis.timeStamps = {};\n\n\t\tthis.serviceType = 'PhasedOperation';\n\n\t\tthis.state = JSON.parse(_OperationStatePrototypeString);\n\n\t\tthis.stepMap = {};\n\t\tthis.stepFunctions = {};\n\n\t\t// Match the service instantiation to the operation.\n\t\tthis.state.Metadata.Hash = this.Hash;\n\t\tthis.state.Metadata.UUID = this.UUID;\n\n\t\tthis.state.Metadata.Name = (typeof(this.options.Name) == 'string') ? this.options.Name : `Unnamed Operation ${this.state.Metadata.UUID}`;\n\t\tthis.name = this.state.Metadata.Name;\n\n\t\tthis.progressTrackerSet = this.fable.instantiateServiceProviderWithoutRegistration('ProgressTrackerSet');\n\n\t\tthis.state.OverallProgressTracker = this.progressTrackerSet.createProgressTracker(`Overall-${this.state.Metadata.UUID}`);\n\n\t\t// This is here to use the pass-through logging functions in the operation itself.\n\t\tthis.log = this;\n\t}\n\n\texecute(fExecutionCompleteCallback)\n\t{\n\t\t// TODO: Should the same operation be allowed to execute more than one time?\n\t\tif (this.state.OverallProgressTracker.StartTimeStamp > 0)\n\t\t{\n\t\t\treturn fExecutionCompleteCallback(new Error(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} has already been executed!`));\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tthis.progressTrackerSet.setProgressTrackerTotalOperations(this.state.OverallProgressTracker.Hash, this.state.Status.StepCount);\n\t\tthis.progressTrackerSet.startProgressTracker(this.state.OverallProgressTracker.Hash);\n\t\tthis.info(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} starting...`);\n\n\t\tfor (let i = 0; i < this.state.Steps.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(\n\t\t\t\tfunction(fNext)\n\t\t\t\t{\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} starting...`);\n\t\t\t\t\tthis.progressTrackerSet.startProgressTracker(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\treturn fNext();\n\t\t\t\t}.bind(this));\n\t\t\t// Steps are executed in a custom context with\n\t\t\ttmpAnticipate.anticipate(this.stepFunctions[this.state.Steps[i].GUIDStep].bind(\n\t\t\t\t{\n\t\t\t\t\tlog:this,\n\t\t\t\t\tfable:this.fable,\n\t\t\t\t\toptions:this.state.Steps[i].Metadata,\n\t\t\t\t\tmetadata:this.state.Steps[i].Metadata,\n\t\t\t\t\tProgressTracker:this.progressTrackerSet.getProgressTracker(this.state.Steps[i].ProgressTracker.Hash),\n\t\t\t\t\tlogProgressTrackerStatus: function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}]: ${this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash)}`);\n\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\tOperationState:this.state,\n\t\t\t\t\tStepState:this.state.Steps[i]\n\t\t\t\t}));\n\t\t\ttmpAnticipate.anticipate(\n\t\t\t\tfunction(fNext)\n\t\t\t\t{\n\t\t\t\t\tthis.progressTrackerSet.endProgressTracker(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\tlet tmpStepTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} complete.`);\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} ${tmpStepTimingMessage}.`);\n\n\t\t\t\t\tthis.progressTrackerSet.incrementProgressTracker(this.state.OverallProgressTracker.Hash, 1);\n\t\t\t\t\tlet tmpOperationTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.OverallProgressTracker.Hash);\n\t\t\t\t\tthis.fable.log.info(`Operation [${this.state.Metadata.UUID}] ${tmpOperationTimingMessage}.`);\n\t\t\t\t\treturn fNext();\n\t\t\t\t}.bind(this));\n\t\t}\n\n\t\t// Wait for the anticipation to complete\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.fable.log.error(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} had an error: ${pError}`, pError);\n\t\t\t\t\treturn fExecutionCompleteCallback(pError);\n\t\t\t\t}\n\t\t\t\tthis.info(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} complete.`);\n\t\t\t\tlet tmpOperationTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.OverallProgressTracker.Hash);\n\t\t\t\tthis.progressTrackerSet.endProgressTracker(this.state.OverallProgressTracker.Hash);\n\t\t\t\tthis.fable.log.info(`Operation [${this.state.Metadata.UUID}] ${tmpOperationTimingMessage}.`);\n\t\t\t\treturn fExecutionCompleteCallback();\n\t\t\t});\n\t}\n\n\t// There are three ways to add steps:\n\t// 1. As a basic javascript function\n\t//    --\n\t//    This is the most basic, java\"script\" way to add a step.  It will\n\t//    setup a \"this\" context that has the following properties:\n\t//    - log: A reference to the operation's log object\n\n\taddStep(fStepFunction, pStepMetadata, pStepName, pStepDescription, pGUIDStep)\n\t{\n\t\tlet tmpStep = {};\n\n\t\t// GUID is optional\n\t\ttmpStep.GUIDStep = (typeof(pGUIDStep) !== 'undefined') ? pGUIDStep : `STEP-${this.state.Steps.length}-${this.fable.DataGeneration.randomNumericString()}`;\n\n\n\t\t// Name is optional\n\t\ttmpStep.Name = (typeof(pStepName) !== 'undefined') ? pStepName : `Step [${tmpStep.GUIDStep}]`;\n\t\ttmpStep.Description = (typeof(pStepDescription) !== 'undefined') ? pStepDescription : `Step execution of ${tmpStep.Name}.`;\n\n\t\ttmpStep.ProgressTracker = this.progressTrackerSet.createProgressTracker(tmpStep.GUIDStep);\n\n\t\ttmpStep.Metadata = (typeof(pStepMetadata) === 'object') ? pStepMetadata : {};\n\n\t\t// There is an array of steps, in the Operation State itself ... push a step there\n\t\tthis.state.Steps.push(tmpStep);\n\n\t\tthis.stepMap[tmpStep.GUIDStep] = tmpStep;\n\n\t\tthis.stepFunctions[tmpStep.GUIDStep] = typeof(fStepFunction) == 'function' ? fStepFunction : function (fDone) { return fDone(); };\n\n\t\tthis.state.Status.StepCount++;\n\n\t\treturn tmpStep;\n\t}\n\n\tsetStepTotalOperations(pGUIDStep, pTotalOperationCount)\n\t{\n\t\tif (!(pGUIDStep in this.stepMap))\n\t\t{\n\t\t\treturn new Error(`Step [${pGUIDStep}] does not exist in operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} when attempting to set total operations to ${pTotalOperationCount}.`);\n\t\t}\n\n\t\tthis.progressTrackerSet.setProgressTrackerTotalOperations(this.stepMap[pGUIDStep].ProgressTracker.Hash, pTotalOperationCount);\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`[${new Date().toUTCString()}]-[${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n\n},{\"./Fable-Service-Operation-DefaultSettings.js\":175,\"big.js\":17,\"fable-serviceproviderbase\":59}],177:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceProgressTime extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ProgressTime';\n\n\t\tthis.timeStamps = {};\n\t}\n\n\tformatTimeDuration(pTimeDurationInMilliseconds)\n\t{\n\t\tlet tmpTimeDuration = typeof(pTimeDurationInMilliseconds) == 'number' ? pTimeDurationInMilliseconds : 0;\n\n\t\tif (pTimeDurationInMilliseconds < 0)\n\t\t{\n\t\t\treturn 'unknown';\n\t\t}\n\n\t\tlet tmpTimeDurationString = '';\n\t\tif (tmpTimeDuration > 3600000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/3600000)+'h ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 3600000;\n\t\t}\n\t\tif (tmpTimeDuration > 60000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/60000)+'m ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 60000;\n\t\t}\n\t\tif (tmpTimeDuration > 1000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/1000)+'s ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 1000;\n\t\t}\n\t\ttmpTimeDurationString += Math.round(tmpTimeDuration)+'ms';\n\n\t\treturn tmpTimeDurationString;\n\t}\n\n\tcreateTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tthis.timeStamps[tmpTimeStampHash] = +new Date();\n\t\treturn this.timeStamps[tmpTimeStampHash];\n\t}\n\n\tgetTimeStampValue(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\treturn (tmpTimeStampHash in this.timeStamps) ? this.timeStamps[tmpTimeStampHash] : -1;\n\t}\n\n\tupdateTimeStampValue(pTimeStampHash, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpReferenceTime = false;\n\n\t\t// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.\n\t\tif (typeof(pReferenceTime) == 'string')\n\t\t{\n\t\t\ttmpReferenceTime = (tmpReference in this.timeStamps) ? this.timeStamps[tmpReference] : false;\n\t\t}\n\t\telse if (typeof(pReferenceTime) == 'number')\n\t\t{\n\t\t\ttmpReferenceTime = pReferenceTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpReferenceTime = +new Date();\n\t\t}\n\n\t\tif ((tmpTimeStampHash in this.timeStamps) && tmpReferenceTime)\n\t\t{\n\t\t\tthis.timeStamps[tmpTimeStampHash] = tmpReferenceTime;\n\t\t\treturn this.timeStamps[tmpTimeStampHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tremoveTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tif (tmpTimeStampHash in this.timeStamps)\n\t\t{\n\t\t\tdelete this.timeStamps[tmpTimeStampHash];\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetTimeStampDelta(pTimeStampHash, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpReferenceTime = false;\n\n\t\t// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.\n\t\tif (typeof(pReferenceTime) == 'string')\n\t\t{\n\t\t\ttmpReferenceTime = (tmpReference in this.timeStamps) ? this.timeStamps[tmpReference] : false;\n\t\t}\n\t\telse if (typeof(pReferenceTime) == 'number')\n\t\t{\n\t\t\ttmpReferenceTime = pReferenceTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpReferenceTime = +new Date();\n\t\t}\n\n\t\tif ((tmpTimeStampHash in this.timeStamps) && tmpReferenceTime)\n\t\t{\n\t\t\treturn tmpReferenceTime-this.timeStamps[tmpTimeStampHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgetDurationBetweenTimestamps(pTimeStampHashStart, pTimeStampHashEnd)\n\t{\n\t\tlet tmpTimeStampHashStart = (typeof(pTimeStampHashStart) == 'string') ? pTimeStampHashStart : 'Default';\n\t\tlet tmpTimeStampHashEnd = (typeof(pTimeStampHashEnd) == 'string') ? pTimeStampHashEnd : 'Default';\n\t\tif ((tmpTimeStampHashStart in this.timeStamps) && (tmpTimeStampHashEnd in this.timeStamps))\n\t\t{\n\t\t\treturn this.timeStamps[tmpTimeStampHashEnd]-this.timeStamps[tmpTimeStampHashStart];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgetTimeStampDeltaMessage(pTimeStampHash, pMessage, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : `Elapsed for ${tmpTimeStampHash}: `;\n\t\tlet tmpOperationTime = this.getTimeStampDelta(tmpTimeStampHash, pReferenceTime);\n\n\t\treturn `${tmpMessage} ${this.formatTimeDuration(tmpOperationTime)}`;\n\t}\n\n\tlogTimeStampDelta(pTimeStampHash, pMessage, pReferenceTime)\n\t{\n\t\tthis.fable.log.info(this.getTimeStampDeltaMessage(pTimeStampHash, pMessage, pReferenceTime));\n\t}\n}\n\nmodule.exports = FableServiceProgressTime;\n\n},{\"fable-serviceproviderbase\":59}],178:[function(require,module,exports){\nclass ProgressTracker\n{\n\tconstructor(pProgressTrackerSet, pProgressTrackerHash)\n\t{\n\t\tthis.progressTrackerSet = pProgressTrackerSet;\n\t\tthis.progressTrackerHash = pProgressTrackerHash;\n\n\t\tthis.data = this.progressTrackerSet.getProgressTrackerData(this.progressTrackerHash);\n\t}\n\n\tupdateProgressTracker(pProgressAmount)\n\t{\n\t\treturn this.progressTrackerSet.updateProgressTracker(this.progressTrackerHash, pProgressAmount);\n\t}\n\n\tincrementProgressTracker(pProgressIncrementAmount)\n\t{\n\t\treturn this.progressTrackerSet.incrementProgressTracker(this.progressTrackerHash, pProgressIncrementAmount);\n\t}\n\n\tsetProgressTrackerTotalOperations(pTotalOperationCount)\n\t{\n\t\treturn this.progressTrackerSet.setProgressTrackerTotalOperations(this.progressTrackerHash, pTotalOperationCount);\n\t}\n\n\tgetProgressTrackerStatusString()\n\t{\n\t\treturn this.progressTrackerSet.getProgressTrackerStatusString(this.progressTrackerHash);\n\t}\n}\n\nmodule.exports = ProgressTracker;\n},{}],179:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libProgressTrackerClass = require('./Fable-Service-ProgressTracker/ProgressTracker.js');\n\nclass FableServiceProgressTrackerSet extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ProgressTrackerSet';\n\n\t\tthis.progressTrackers = {};\n\n\t\t// Create an internal PorgressTime service to track timestamps\n\t\tthis.progressTimes = this.fable.instantiateServiceProviderWithoutRegistration('ProgressTime');\n\n\t\t// This timestamp is used and updated by *all* progress trackers.\n\t\tthis.progressTimes.createTimeStamp('CurrentTime');\n\t}\n\n\tgetProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\treturn new libProgressTrackerClass(this, pProgressTrackerHash);\n\t}\n\n\tgetProgressTrackerData(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tcreateProgressTracker(pProgressTrackerHash, pTotalOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tlet tmpProgressTracker = (\n\t\t\t{\n\t\t\t\tHash: tmpProgressTrackerHash,\n\n\t\t\t\tStartTimeHash: `${tmpProgressTrackerHash}-Start`,\n\t\t\t\tStartTimeStamp: -1,\n\t\t\t\tCurrentTimeStamp: -1,\n\t\t\t\tEndTimeHash: `${tmpProgressTrackerHash}-End`,\n\t\t\t\tEndTimeStamp: -1,\n\n\t\t\t\tPercentComplete: -1,\n\t\t\t\t// If this is set to true, PercentComplete will be calculated as CurrentCount / TotalCount even if it goes over 100%\n\t\t\t\tAllowTruePercentComplete: false,\n\n\t\t\t\tElapsedTime: -1,\n\t\t\t\tAverageOperationTime: -1,\n\t\t\t\tEstimatedCompletionTime: -1,\n\n\t\t\t\tTotalCount: tmpTotalOperations,\n\n\t\t\t\tCurrentCount:-1\n\t\t\t});\n\n\t\tif (tmpProgressTrackerHash in this.progressTrackers)\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} already exists!  Overwriting with a new tracker...`);\n\t\t\tthis.progressTimes.removeTimeStamp(tmpProgressTracker.StartTimeHash);\n\t\t\tthis.progressTimes.removeTimeStamp(tmpProgressTracker.EndTimeHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash] = tmpProgressTracker;\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tsetProgressTrackerTotalOperations(pProgressTrackerHash, pTotalOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to set the total operations of ProgressTracker ${tmpProgressTrackerHash} but it does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, tmpTotalOperations);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].TotalCount = tmpTotalOperations;\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tstartProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This is the only method to lazily create ProgressTrackers now\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tthis.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);\n\t\ttmpProgressTracker.StartTimeStamp = this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);\n\t\tif (tmpProgressTracker.CurrentCount < 0)\n\t\t{\n\t\t\ttmpProgressTracker.CurrentCount = 0;\n\t\t}\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tendProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.error(`Attempted to end ProgressTracker ${tmpProgressTrackerHash} that does not exist!`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tthis.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);\n\t\ttmpProgressTracker.EndTimeStamp = this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tsolveProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.error(`Attempted to solve ProgressTracker ${tmpProgressTrackerHash} that does not exist!`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tif ((tmpProgressTracker.TotalCount < 1) || isNaN(tmpProgressTracker.TotalCount))\n\t\t{\n\t\t\tthis.fable.log.error(`ProgressTracker ${tmpProgressTracker.Hash} has an invalid total count of operations (${tmpProgressTracker.TotalCount}!  Setting it to the default of 100...`);\n\t\t\ttmpProgressTracker.TotalCount = 100;\n\t\t}\n\n\t\t// Compute the percentage of progress that is complete.\n\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = (tmpProgressTracker.CurrentCount / tmpProgressTracker.TotalCount) * 100.0;\n\t\t}\n\n\t\tif (!tmpProgressTracker.AllowTruePercentComplete && (tmpProgressTracker.PercentComplete > 100))\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = 100;\n\t\t}\n\n\t\t// Compute the average time per operation\n\t\tthis.progressTimes.updateTimeStampValue('CurrentTime');\n\t\ttmpProgressTracker.CurrentTimeStamp = this.progressTimes.getTimeStampValue('CurrentTime');\n\t\ttmpProgressTracker.ElapsedTime = tmpProgressTracker.CurrentTimeStamp - tmpProgressTracker.StartTimeStamp;\n\n\t\tif (tmpProgressTracker.EndTimeStamp > 0)\n\t\t{\n\t\t\ttmpProgressTracker.ElapsedTime = tmpProgressTracker.EndTimeStamp - tmpProgressTracker.StartTimeStamp;\n\t\t}\n\n\t\tif (tmpProgressTracker.CurrentCount > 0)\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = (tmpProgressTracker.CurrentTimeStamp-tmpProgressTracker.StartTimeStamp) / tmpProgressTracker.CurrentCount;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = -1;\n\t\t}\n\n\t\t// Compute the estimated completion\n\t\tif (tmpProgressTracker.AverageOperationTime > 0)\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = Math.max((tmpProgressTracker.TotalCount - tmpProgressTracker.CurrentCount), 0) * tmpProgressTracker.AverageOperationTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = -1;\n\t\t}\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tupdateProgressTracker(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to update ProgressTracker ${tmpProgressTrackerHash} with an invalid number of operations!`)\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = tmpCurrentOperations;\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tincrementProgressTracker(pProgressTrackerHash, pOperationIncrementAmount)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpOperationIncrementAmount = parseInt(pOperationIncrementAmount);\n\n\t\tif (isNaN(tmpOperationIncrementAmount))\n\t\t{\n\t\t\ttmpOperationIncrementAmount = 1;\n\t\t}\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to increment ProgressTracker ${tmpProgressTrackerHash} but it did not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.progressTrackers[tmpProgressTrackerHash].StartTimeStamp < 1)\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to increment ProgressTracker ${tmpProgressTrackerHash} but it was not started.. starting now.`);\n\t\t\tthis.startProgressTracker(tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = this.progressTrackers[tmpProgressTrackerHash].CurrentCount + tmpOperationIncrementAmount;\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tgetProgressTrackerCompletedOperationCountString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t// The states of a progress tracker:\n\t\tif (tmpProgressTracker.CurrentCount < 0)\n\t\t{\n\t\t\treturn `none`;\n\t\t}\n\t\telse if (tmpProgressTracker.CurrentCount < 1)\n\t\t{\n\t\t\treturn `0`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn `${tmpProgressTracker.CurrentCount}`;\n\t\t}\n\t}\n\n\tgetProgressTrackerPercentCompleteString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\t// TODO: Is there a pattern to avoid this double call that's worth putting in?\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\treturn `ProgressTracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\t// The states of a progress tracker:\n\t\t\t// 1. Not started\n\t\t\tif (tmpProgressTracker.StartTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `0%`;\n\t\t\t}\n\t\t\t// 2. Started, but no operations completed\n\n\t\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t\t{\n\t\t\t\treturn `0%`;\n\t\t\t}\n\t\t\t// 3. Started, some operations completed\n\t\t\telse if (tmpProgressTracker.EndTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `${tmpProgressTracker.PercentComplete.toFixed(3)}%`;\n\t\t\t}\n\t\t\t// 4. Done\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn `${tmpProgressTracker.PercentComplete.toFixed(3)}%`;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetProgressTrackerStatusString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\t// TODO: Is there a pattern to avoid this double call that's worth putting in?\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\treturn `ProgressTracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\t// The states of a progress tracker:\n\t\t\t// 1. Not started\n\t\t\tif (tmpProgressTracker.StartTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} has not been started yet.`;\n\t\t\t}\n\t\t\t// 2. Started, but no operations completed\n\n\t\t\tif ((tmpProgressTracker.CurrentCount < 1) && (tmpProgressTracker.EndTimeStamp < 1))\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} has no completed operations.  ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} have elapsed since it was started.`;\n\t\t\t}\n\t\t\t// 3. Started, some operations completed\n\t\t\telse if (tmpProgressTracker.EndTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} is ${tmpProgressTracker.PercentComplete.toFixed(3)}% completed - ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations over ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} (median ${this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)} per).  Estimated completion: ${this.progressTimes.formatTimeDuration(tmpProgressTracker.EstimatedCompletionTime)}`;\t\t\t}\n\t\t\t// 4. Done\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} is done.  ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations were completed in ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} (median ${this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)} per).`;\n\t\t\t}\n\t\t}\n\t}\n\n\tlogProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tthis.fable.log.info(this.getProgressTrackerStatusString(pProgressTrackerHash));\n\t}\n}\n\nmodule.exports = FableServiceProgressTrackerSet;\n},{\"./Fable-Service-ProgressTracker/ProgressTracker.js\":178,\"fable-serviceproviderbase\":59}],180:[function(require,module,exports){\n(function (Buffer){(function (){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libSimpleGet = require('simple-get');\nconst libCookie = require('cookie');\n\nclass FableServiceRestClient extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.TraceLog = false;\n\t\tif (this.options.TraceLog || this.fable.TraceLog)\n\t\t{\n\t\t\tthis.TraceLog = true;\n\t\t}\n\n\t\tthis.dataFormat = this.fable.services.DataFormat;\n\n\t\tthis.serviceType = 'RestClient';\n\n\t\tthis.cookie = false;\n\n\t\t// This is a function that can be overridden, to allow the management\n\t\t// of the request options before they are passed to the request library.\n\t\tthis.prepareRequestOptions = (pOptions) => { return pOptions; };\n\t}\n\n\tget simpleGet()\n\t{\n\t\treturn libSimpleGet;\n\t}\n\n\tprepareCookies(pRequestOptions)\n\t{\n\t\tif (this.cookie)\n\t\t{\n\t\t\tlet tmpCookieObject = this.cookie;\n\t\t\tif (!('headers' in pRequestOptions))\n\t\t\t{\n\t\t\t\tpRequestOptions.headers = {};\n\t\t\t}\n\t\t\tlet tmpCookieKeys = Object.keys(tmpCookieObject);\n\t\t\tif (tmpCookieKeys.length > 0)\n\t\t\t{\n\t\t\t\t// Only grab the first for now.\n\t\t\t\tpRequestOptions.headers.cookie = libCookie.serialize(tmpCookieKeys[0], tmpCookieObject[tmpCookieKeys[0]]);\n\t\t\t}\n\t\t}\n\t\treturn pRequestOptions;\n\t}\n\n\tpreRequest(pOptions)\n\t{\n\t\t// Validate the options object\n\t\tlet tmpOptions = this.prepareCookies(pOptions);\n\n\t\t// Prepend a string to the URL if it exists in the Fable Config\n\t\tif ('RestClientURLPrefix' in this.fable.settings)\n\t\t{\n\t\t\ttmpOptions.url = this.fable.settings.RestClientURLPrefix + tmpOptions.url;\n\t\t}\n\n\t\treturn this.prepareRequestOptions(tmpOptions);\n\t}\n\n\texecuteChunkedRequest(pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpData = '';\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// For JSON, the chunk is the serialized object.\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> ${tmpOptions.method} completed data size ${tmpData.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, tmpData);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\texecuteChunkedRequestBinary(pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\ttmpOptions.json = false;\n\t\ttmpOptions.encoding = null;\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpDataBuffer = false;\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// For JSON, the chunk is the serialized object.\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: Potentially create a third option that streams this to a file?  So it doesn't have to hold it all in memory.\n\t\t\t\t\t\tif (!tmpDataBuffer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDataBuffer = Buffer.from(pChunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDataBuffer = Buffer.concat([tmpDataBuffer, pChunk]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> ${tmpOptions.method} completed data size ${tmpDataBuffer.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, tmpDataBuffer);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\texecuteJSONRequest(pOptions, fCallback)\n\t{\n\t\tpOptions.json = true;\n\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\tif (!('headers' in tmpOptions))\n\t\t{\n\t\t\ttmpOptions.headers = {};\n\t\t}\n\t\t/* Automated headers break some APIs\n\t\tif (!('Content-Type' in tmpOptions.headers))\n\t\t{\n\t\t\ttmpOptions.headers['Content-Type'] = 'application/json';\n\t\t}\n\t\t*/\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} JSON request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> JSON ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpJSONData = '';\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> JSON ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpJSONData += pChunk;\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> JSON ${tmpOptions.method} completed - received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, JSON.parse(tmpJSONData));\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tgetJSON(pOptionsOrURL, fCallback)\n\t{\n\t\tlet tmpRequestOptions = (typeof(pOptionsOrURL) == 'object') ? pOptionsOrURL : {};\n\t\tif (typeof(pOptionsOrURL) == 'string')\n\t\t{\n\t\t\ttmpRequestOptions.url = pOptionsOrURL;\n\t\t}\n\n\t\ttmpRequestOptions.method = 'GET';\n\n\t\treturn this.executeJSONRequest(tmpRequestOptions, fCallback);\n\t}\n\n\tputJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`PUT JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'PUT';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tpostJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`POST JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'POST';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tpatchJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`PATCH JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'PATCH';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\theadJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`HEAD JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'HEAD';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tdelJSON(pOptions, fCallback)\n\t{\n\t\tpOptions.method = 'DELETE';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tgetRawText(pOptionsOrURL, fCallback)\n\t{\n\t\tlet tmpRequestOptions = (typeof(pOptionsOrURL) == 'object') ? pOptionsOrURL : {};\n\t\tif (typeof(pOptionsOrURL) == 'string')\n\t\t{\n\t\t\ttmpRequestOptions.url = pOptionsOrURL;\n\t\t}\n\n\t\ttmpRequestOptions.method = 'GET';\n\n\t\treturn this.executeChunkedRequest(tmpRequestOptions, fCallback);\n\t}\n}\n\nmodule.exports = FableServiceRestClient;\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":20,\"cookie\":31,\"fable-serviceproviderbase\":59,\"simple-get\":123}],181:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n\t\tthis.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction()\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n\n},{\"fable-serviceproviderbase\":59}],182:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nconst libBigNumber = require('big.js');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\n\t\tthis.bigNumber = libBigNumber;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\t// Nevermind, the native thing is not stable enough across environments\n\t// Basic shallow copy\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\tfor (let i = 0; i < pSourceObjects.length; i++)\n\t\t{\n\t\t\tlet tmpSourceObject = pSourceObjects[i];\n\t\t\tif (typeof(tmpSourceObject) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpObjectProperties = Object.keys(tmpSourceObject);\n\t\t\t\tfor (let k = 0; k < tmpObjectProperties.length; k++)\n\t\t\t\t{\n\t\t\t\t\tpDestinationObject[tmpObjectProperties[k]] = tmpSourceObject[tmpObjectProperties[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pDestinationObject;\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.instantiateServiceProviderWithoutRegistration('Template');\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.instantiateServiceProvider('Template', {}, pTemplateHash);\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n\n\t/**\n\t * Get a value from fable/pict by hash/address\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t */\n\tgetInternalValueByHash(pValueAddress)\n\t{\n\t\t// Get the value from the internal manifest and return it\n\t\treturn this.getValueByHash(this.fable, pValueAddress);\n\t}\n\n\t/**\n\t * Set a value from fable/pict by hash/address\n\t *\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {any} pValue - The value to set\n\t */\n\tsetInternalValueByHash(pValueAddress, pValue)\n\t{\n\t\t// Get the value from the internal manifest and return it\n\t\treturn this.setValueByHash(this.fable, pValueAddress, pValue);\n\t}\n\n\t/**\n\t * Get a value from an object by hash/address\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value from the object\n\t */\n\tgetValueByHash(pObject, pValueAddress, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpManifest.getValueByHash(pObject, pValueAddress);\n\t}\n\n\t/**\n\t * Set a value to an object by hash/address\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} pValue - The value to set\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value from the object\n\t */\n\tsetValueByHash(pObject, pValueAddress, pValue, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpManifest.setValueByHash(pObject, pValueAddress, pValue);\n\t}\n\n\t/**\n\t * Get a value array from an object by hash/address list\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueArrayByHashes(pObject, pValueHashes, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\tif (!Array.isArray(pValueHashes))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpValueArray = [];\n\t\tfor (let i = 0; i < pValueHashes.length; i++)\n\t\t{\n\t\t\ttmpValueArray.push(tmpManifest.getValueByHash(pObject, pValueHashes[i]));\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpValueArray;\n\t}\n\n\tslice(pValueArray, pStartIndex, pEndIndex)\n\t{\n\t\tif (!Array.isArray(pValueArray))\n\t\t{\n\t\t\tthis.fable.log.error('Fable.Math.slice called with non-array value', { pValueArray });\n\t\t\treturn [];\n\t\t}\n\t\tconst tmpStartIndex = Number(this.fable.Math.parsePrecise(pStartIndex, '0'));\n\t\tconst tmpEndIndex = Number(this.fable.Math.parsePrecise(pEndIndex, pValueArray.length.toString()));\n\t\treturn pValueArray.slice(tmpStartIndex, tmpEndIndex);\n\t}\n\n\t/**\n\t * Get a value array by hash/address list from the internal fable/pict state\n\t * @param {string} pValueHashes - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueArrayByHashesFromInternal(pValueHashes, pManifest)\n\t{\n\t\treturn this.createValueArrayByHashes(this.fable, pValueHashes, pManifest);\n\t}\n\n\tcreateValueArrayByHashParametersFromInternal()\n\t{\n\t\tif (arguments.length < 2)\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpValueHashes = Array.prototype.slice.call(arguments);\n\t\treturn this.createValueArrayByHashes(this.fable, tmpValueHashes);\n\t}\n\n\t/**\n\t * Get a value object from a list of hash/addressese\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueHashes - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value object built from the hash list\n\t */\n\tcreateValueObjectByHashes(pObject, pValueHashes, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\tif (!Array.isArray(pValueHashes))\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObject = {};\n\t\tfor (let i = 0; i < pValueHashes.length; i++)\n\t\t{\n\t\t\ttmpValueObject[pValueHashes[i]] = tmpManifest.getValueByHash(pObject, pValueHashes[i]);\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpValueObject;\n\t}\n\n\t/**\n\t * Get a value object by hash/address list from the internal fable/pict state\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value object built from the hash list\n\t */\n\tcreateValueObjectByHashesFromInternal(pValueHashes, pManifest)\n\t{\n\t\treturn this.createValueObjectByHashes(this.fable, pValueHashes, pManifest);\n\t}\n\n\t/**\n\t * Get a value object by hash/address list as parameters from the internal fable/pict state\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueObjectByHashParametersFromInternal()\n\t{\n\t\tlet tmpValueHashes = Array.prototype.slice.call(arguments);\n\t\treturn this.createValueObjectByHashes(this.fable, tmpValueHashes);\n\t}\n\n\n\t/**\n\t * Check if a value is null or empty\n\t * @param {object} pObject - The object to check\n\t * @param {string} pValueAddress - The manyfest hash/address to check\n\t */\n\taddressIsNullOrEmpty(pObject, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\t// If it doesn't exist, it is null or empty.\n\t\tif (!this.manifest.checkAddressExists(pObject, pValueAddress))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\tlet tmpValue = this.manifest.getValueByHash(pObject, pValueAddress);\n\t\tif (tmpValue === null || tmpValue === '')\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Convert objects to arrays of labels or values for solvers\n\tobjectKeysToArray(pObject)\n\t{\n\t\treturn Object.keys(pObject);\n\t}\n\n\t// Convert object values to an array of values\n\tobjectValuesToArray(pObject)\n\t{\n\t\tif ((typeof(pObject) !== 'object') || (pObject === null))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\t\tlet tmpKeys = Object.keys(pObject);\n\t\tlet tmpValues = [];\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpValues.push(pObject[tmpKeys[i]]);\n\t\t}\n\n\t\treturn tmpValues;\n\t}\n\n\tobjectValuesSortByExternalArray(pArray, pObjectArray, pDescending, pSearchAddress)\n\t{\n\t\tlet tmpDescending = (typeof(pDescending) == 'boolean') ? pDescending :\n\t\t\t\t\t\t\t((typeof(pDescending) == 'number') && (pDescending == 1)) ? true :\n\t\t\t\t\t\t\t((typeof(pDescending) == 'string') && (pDescending == '1')) ? true :\n\t\t\t\t\t\t\tfalse;\n\t\tlet tmpManifest = this.fable.newManyfest();\n\n\t\tlet tmpSearchAddresses = pSearchAddress;\n\n\t\tif (typeof(tmpSearchAddresses) != 'string')\n\t\t{\n\t\t\t// Defaulting to \"label\"...\n\t\t\ttmpSearchAddresses = 'label';\n\t\t}\n\n\t\tlet tmpSortHelperArray = [];\n\n\t\tfor (let i = 0; i < pArray.length; i++)\n\t\t{\n\t\t\ttmpSortHelperArray.push(\n\t\t\t\t{\n\t\t\t\t\tValue: pArray[i],\n\t\t\t\t\tSortValue: tmpManifest.getValueByHash(pObjectArray[i], tmpSearchAddresses),\n\t\t\t\t\tSortObject: pObjectArray[i]\n\t\t\t\t});\n\t\t}\n\n\t\tlet tmpSortedArray = tmpSortHelperArray.sort((pLeft, pRight) =>\n\t\t{\n\t\t\tif (pLeft.SortValue < pRight.SortValue)\n\t\t\t{\n\t\t\t\treturn tmpDescending ? 1 : -1;\n\t\t\t}\n\t\t\tif (pLeft.SortValue > pRight.SortValue)\n\t\t\t{\n\t\t\t\treturn tmpDescending ? -1 : 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}).map((pSortHelperArrayObject) => { return pSortHelperArrayObject.Value; });\n\n\t\treturn tmpSortedArray;\n\t}\n\n\t// Convert an ISO string to a javascript date object\n\t// Adapted from https://stackoverflow.com/a/54751179\n\t//\n\t// Takes strings like: 2022-11-04T11:34:45.000Z\n\t//                and: 1986-06-11T09:34:46.012Z+0200\n\t// ... and converts them into javascript timestamps, following the directions of the timezone stuff.\n\t//\n\t// This is not meant to replace the more complex libraries such as moment or luxon.\n\t// This *is* meant to be a simple, small, and fast way to convert ISO strings to dates in engines\n\t// with ultra limited JS capabilities where those don't work.\n\tisoStringToDate (pISOString)\n\t{\n\t\tif (!('Dates' in this.fable))\n\t\t{\n\t\t\tthis.fable.instantiateServiceProvider('Dates');\n\t\t}\n\n\t\tlet tmpDate = false;\n\n\t\ttry\n\t\t{\n\t\t\ttmpDate = this.fable.Dates.dayJS.utc(pISOString);\n\t\t}\n\t\tcatch(pError)\n\t\t{\n\t\t\t// TODO: Should this throw?  Doubtful.\n\t\t\tthis.fable.log.error(`Could not parse date string ${pISOString} with dayJS.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tmpDate)\n\t\t{\n\t\t\treturn tmpDate.toDate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {array} pObjectArray - The array of objects to search\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByStringIncludes(pObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (!Array.isArray(pObjectArray))\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (let i = 0; i < pObjectArray.length; i++)\n\t\t{\n\t\t\tlet tmpValueToMatch = this.manifest.getValueByHash(pObjectArray[i], pValueToMatchAddress);\n\t\t\tif (tmpValueToMatch && (tmpValueToMatch.includes(pValueToMatch)))\n\t\t\t{\n\t\t\t\treturn this.manifest.getValueByHash(pObjectArray[i], pValueAddress);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {string} pFableAddress - The address in the fable object to pull the value from\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByStringIncludesInternal(pFableAddress, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (typeof(pFableAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpObjectArray = this.manifest.getValueByHash(this.fable, pFableAddress);\n\n\t\treturn this.findFirstValueByStringIncludes(tmpObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress);\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {array} pObjectArray - The array of objects to search\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByExactMatch(pObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (!Array.isArray(pObjectArray))\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (let i = 0; i < pObjectArray.length; i++)\n\t\t{\n\t\t\tlet tmpValueToMatch = this.manifest.getValueByHash(pObjectArray[i], pValueToMatchAddress);\n\t\t\tif (tmpValueToMatch && (tmpValueToMatch == pValueToMatch))\n\t\t\t{\n\t\t\t\treturn this.manifest.getValueByHash(pObjectArray[i], pValueAddress);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {string} pFableAddress - The address in the fable object to pull the value from\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByExactMatchInternal(pFableAddress, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (typeof(pFableAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpObjectArray = this.manifest.getValueByHash(this.fable, pFableAddress);\n\n\t\treturn this.findFirstValueByExactMatch(tmpObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress);\n\t}\n\n\t/**\n\t * Find the index of a value in an array, using the specified search mode.\n\t *\n\t * @param {any} pValueToFind - The value to find.\n\t * @param {Array<any>|string} pSearchArray - The array to search, or the address of such an array.\n\t * @param {string|number} [pSearchMode='1'] - The search mode ('0' for exact match, '1' (or default) for searching sorted sets and finding the first value >= the specifid value. '-1' is the same behavior as '1' but sorted descending.\n\t *\n\t * @returns {number} - The index of the found value, or -1 if not found.\n\t */\n\tfindIndexInternal(pValueToFind, pSearchArray, pSearchMode = '1')\n\t{\n\t\tlet tmpSearchArray = pSearchArray;\n\t\tif (typeof (pSearchArray) === 'string')\n\t\t{\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpSearchArray = this.manifest.getValueByHash(this.fable, pSearchArray);\n\t\t}\n\n\t\tif (!Array.isArray(tmpSearchArray))\n\t\t{\n\t\t\tthis.fable.log.error('findIndexInternal called with non-array search array.');\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst tmpIsNumericSearch = this.fable.Math.parsePrecise(pValueToFind, null) !== null;\n\t\tlet tmpMatchIndex = -1;\n\t\tlet tmpComparisonFunction;\n\t\tif (Number(pSearchMode) === 0)\n\t\t{\n\t\t\t// Exact match\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.comparePrecise(pCandidate, pValueToFind) === 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate === pValueToFind;\n\t\t\t}\n\t\t}\n\t\telse if (Number(pSearchMode) === -1)\n\t\t{\n\t\t\t// Sorted descending\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.ltePrecise(pCandidate, pValueToFind);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate <= pValueToFind;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Sorted ascending\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.gtePrecise(pCandidate, pValueToFind);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate >= pValueToFind;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < tmpSearchArray.length; i++)\n\t\t{\n\t\t\tif (tmpComparisonFunction(tmpSearchArray[i]))\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Flatten an array of solver inputs into a single array\n\t *\n\t * @param {Array<any>} pInputArray - The array of inputs to flatten\n\t * @return {Array<any>} - The flattened array\n\t */\n\tflattenArrayOfSolverInputs(pInputArray)\n\t{\n\t\tif (!Array.isArray(pInputArray))\n\t\t{\n\t\t\tif (typeof pInputArray === 'object')\n\t\t\t{\n\t\t\t\tpInputArray = Object.values(pInputArray);\n\t\t\t}\n\t\t\tif (!pInputArray)\n\t\t\t{\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t\tconst tmpArrayFlattener = (p) =>\n\t\t{\n\t\t\tif (Array.isArray(p))\n\t\t\t{\n\t\t\t\treturn p; // .flatMap(tmpArrayFlattener);\n\t\t\t}\n\t\t\tif (typeof p === 'object')\n\t\t\t{\n\t\t\t\treturn Object.values(p);\n\t\t\t}\n\t\t\treturn [ p ];\n\t\t};\n\t\treturn pInputArray.flatMap(tmpArrayFlattener);\n\t}\n\n\tgenerateArrayOfObjectsFromSets()\n\t{\n\t\t// For each argument pair, map data to an array of objects with the first parameter of the pairs as the property name and the second parameter as the array of values\n\t\tlet tmpResultArray = [];\n\t\tif (arguments.length % 2 != 0)\n\t\t{\n\t\t\t// Must be pairs\n\t\t\treturn tmpResultArray;\n\t\t}\n\n\t\tlet tmpPropertyNames = [];\n\t\tlet tmpValueArrays = [];\n\n\t\tfor (let i = 0; i < arguments.length; i += 2)\n\t\t{\n\t\t\ttmpPropertyNames.push(arguments[i]);\n\t\t\ttmpValueArrays.push(this.objectValuesToArray(arguments[i + 1]));\n\t\t}\n\n\t\tfor (let h = 0; h < tmpValueArrays.length; h++)\n\t\t{\n\t\t\tlet tmpValueArray = tmpValueArrays[h];\n\t\t\tlet tmpPropertyName = tmpPropertyNames[h];\n\t\t\tif (!Array.isArray(tmpValueArray))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0; i < tmpValueArray.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpResultArray.length <= i)\n\t\t\t\t{\n\t\t\t\t\ttmpResultArray.push({});\n\t\t\t\t}\n\n\t\t\t\tlet tmpObject = tmpResultArray[i];\n\t\t\t\tif (!tmpObject)\n\t\t\t\t{\n\t\t\t\t\t// This shouldn't be possible\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttmpObject[tmpPropertyName] = tmpValueArray[i];\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResultArray;\n\t}\n\n\t/**\n\t * Take a set of arbitrary parameters and build an array from them\n\t * @returns {Array} - An array built from the absolute values of the parameters\n\t */\n\tcreateArrayFromAbsoluteValues()\n\t{\n\t\tlet tmpArray = [];\n\t\tfor (let i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\ttmpArray.push(arguments[i]);\n\t\t}\n\t\treturn tmpArray;\n\t}\n\n\t/**\n\t * Concatenate multiple arrays into a single array\n\t *\n\t * @return {Array<any>} - The concatenated array\n\t */\n\tconcatenateArrays()\n\t{\n\t\tlet tmpResultArray = [];\n\t\tfor (let i = 0; i < arguments.length; ++i)\n\t\t{\n\t\t\tlet tmpArray = arguments[i];\n\t\t\tif (Array.isArray(tmpArray))\n\t\t\t{\n\t\t\t\ttmpResultArray = tmpResultArray.concat(tmpArray);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.fable.log.error('Fable.Service.Utility.concatenateArrays called with non-array argument', { index: i, value: tmpArray });\n\t\t\t}\n\t\t}\n\t\treturn tmpResultArray;\n\t}\n}\n\nmodule.exports = FableServiceUtility;\n\n},{\"async.eachlimit\":1,\"async.waterfall\":15,\"big.js\":17,\"fable-serviceproviderbase\":59}],183:[function(require,module,exports){\n\nclass SetConcatArray\n{\n\t/**\n\t * @param {Array<any>|SetConcatArray} pLeftValue - The left value to concatenate.\n\t * @param {Array<any>|SetConcatArray} pRightValue - The right value to concatenate.\n\t */\n\tconstructor(pLeftValue, pRightValue)\n\t{\n\t\tif (pLeftValue instanceof SetConcatArray)\n\t\t{\n\t\t\tthis.values = pLeftValue.values.concat([ pRightValue ]);\n\t\t}\n\t\telse if (pRightValue instanceof SetConcatArray)\n\t\t{\n\t\t\tthis.values = [ pLeftValue ].concat(pRightValue.values);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.values = [ pLeftValue, pRightValue ];\n\t\t}\n\t}\n}\n\nmodule.exports = SetConcatArray;\n\n},{}]},{},[150])(150)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nvar eachOfLimit = require('async.util.eachoflimit');\nvar withoutIndex = require('async.util.withoutindex');\n\nmodule.exports = function eachLimit(arr, limit, iterator, cb) {\n    return eachOfLimit(limit)(arr, withoutIndex(iterator), cb);\n};\n","'use strict';\n\nmodule.exports = function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n};\n","var once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar onlyOnce = require('async.util.onlyonce');\nvar keyIterator = require('async.util.keyiterator');\n\nmodule.exports = function eachOfLimit(limit) {\n    return function(obj, iterator, cb) {\n        cb = once(cb || noop);\n        obj = obj || [];\n        var nextKey = keyIterator(obj);\n        if (limit <= 0) {\n            return cb(null);\n        }\n        var done = false;\n        var running = 0;\n        var errored = false;\n\n        (function replenish() {\n            if (done && running <= 0) {\n                return cb(null);\n            }\n\n            while (running < limit && !errored) {\n                var key = nextKey();\n                if (key === null) {\n                    done = true;\n                    if (running <= 0) {\n                        cb(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iterator(obj[key], key, onlyOnce(function(err) {\n                    running -= 1;\n                    if (err) {\n                        cb(err);\n                        errored = true;\n                    } else {\n                        replenish();\n                    }\n                }));\n            }\n        })();\n    };\n};\n","'use strict';\nvar setImmediate = require('async.util.setimmediate');\nvar restParam = require('async.util.restparam');\n\nmodule.exports = function(fn) {\n    return restParam(function(args) {\n        var callback = args.pop();\n        args.push(function() {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function() {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        var sync = true;\n        fn.apply(this, args);\n        sync = false;\n    });\n};\n","'use strict';\n\nmodule.exports = Array.isArray || function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar isArray = require('async.util.isarray');\n\nmodule.exports = function isArrayLike(arr) {\n    return isArray(arr) || (\n        // has a positive integer length property\n        typeof arr.length === 'number' &&\n        arr.length >= 0 &&\n        arr.length % 1 === 0\n    );\n};\n","'use strict';\n\nvar _keys = require('async.util.keys');\nvar isArrayLike = require('async.util.isarraylike');\n\nmodule.exports = function keyIterator(coll) {\n    var i = -1;\n    var len;\n    var keys;\n    if (isArrayLike(coll)) {\n        len = coll.length;\n        return function next() {\n            i++;\n            return i < len ? i : null;\n        };\n    } else {\n        keys = _keys(coll);\n        len = keys.length;\n        return function next() {\n            i++;\n            return i < len ? keys[i] : null;\n        };\n    }\n};\n","'use strict';\n\nmodule.exports = Object.keys || function keys(obj) {\n    var _keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            _keys.push(k);\n        }\n    }\n    return _keys;\n};\n","'use strict';\n\nmodule.exports = function noop () {};\n","'use strict';\n\nmodule.exports = function once(fn) {\n    return function() {\n        if (fn === null) return;\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\n\nmodule.exports = function only_once(fn) {\n    return function() {\n        if (fn === null) throw new Error('Callback was already called.');\n        fn.apply(this, arguments);\n        fn = null;\n    };\n};\n","'use strict';\nmodule.exports = function restParam(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = new Array(length);\n        for (var index = 0; index < length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n        }\n    };\n};\n","'use strict';\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\nvar fallback = function(fn) {\n    setTimeout(fn, 0);\n};\n\nmodule.exports = function setImmediate(fn) {\n    // not a direct alias for IE10 compatibility\n    return (_setImmediate || fallback)(fn);\n};\n","'use strict';\n\nmodule.exports = function withoutIndex(iterator) {\n    return function(value, index, callback) {\n        return iterator(value, callback);\n    };\n};\n","'use strict';\n\nvar once = require('async.util.once');\nvar noop = require('async.util.noop');\nvar isArray = require('async.util.isarray');\nvar restParam = require('async.util.restparam');\nvar ensureAsync = require('async.util.ensureasync');\nvar iterator = require('async.iterator');\n\nmodule.exports = function(tasks, cb) {\n    cb = once(cb || noop);\n    if (!isArray(tasks)) return cb(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return cb();\n\n    function wrapIterator(iterator) {\n        return restParam(function(err, args) {\n            if (err) {\n                cb.apply(null, [err].concat(args));\n            } else {\n                var next = iterator.next();\n                if (next) {\n                    args.push(wrapIterator(next));\n                } else {\n                    args.push(cb);\n                }\n                ensureAsync(iterator).apply(null, args);\n            }\n        });\n    }\n    wrapIterator(iterator(tasks))();\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*\r\n *  big.js v7.0.1\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2025 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */\r\n;(function (GLOBAL) {\r\n  'use strict';\r\n  var Big,\r\n\r\n\r\n/************************************** EDITABLE DEFAULTS *****************************************/\r\n\r\n\r\n    // The default values below must be integers within the stated ranges.\r\n\r\n    /*\r\n     * The maximum number of decimal places (DP) of the results of operations involving division:\r\n     * div and sqrt, and pow with negative exponents.\r\n     */\r\n    DP = 20,            // 0 to MAX_DP\r\n\r\n    /*\r\n     * The rounding mode (RM) used when rounding to the above decimal places.\r\n     *\r\n     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n     *  3  Away from zero.                                  (ROUND_UP)\r\n     */\r\n    RM = 1,             // 0, 1, 2 or 3\r\n\r\n    // The maximum value of DP and Big.DP.\r\n    MAX_DP = 1E6,       // 0 to 1000000\r\n\r\n    // The maximum magnitude of the exponent argument to the pow method.\r\n    MAX_POWER = 1E6,    // 1 to 1000000\r\n\r\n    /*\r\n     * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n     * (JavaScript numbers: -7)\r\n     * -1000000 is the minimum recommended exponent value of a Big.\r\n     */\r\n    NE = -7,            // 0 to -1000000\r\n\r\n    /*\r\n     * The positive exponent (PE) at and above which toString returns exponential notation.\r\n     * (JavaScript numbers: 21)\r\n     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n     */\r\n    PE = 21,            // 0 to 1000000\r\n\r\n    /*\r\n     * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n     * primitive number without a loss of precision.\r\n     */\r\n    STRICT = false,     // true or false\r\n\r\n\r\n/**************************************************************************************************/\r\n\r\n\r\n    // Error messages.\r\n    NAME = '[big.js] ',\r\n    INVALID = NAME + 'Invalid ',\r\n    INVALID_DP = INVALID + 'decimal places',\r\n    INVALID_RM = INVALID + 'rounding mode',\r\n    DIV_BY_ZERO = NAME + 'Division by zero',\r\n\r\n    // The shared prototype object.\r\n    P = {},\r\n    UNDEFINED = void 0,\r\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\r\n\r\n\r\n  /*\r\n   * Create and return a Big constructor.\r\n   */\r\n  function _Big_() {\r\n\r\n    /*\r\n     * The Big constructor and exported function.\r\n     * Create and return a new instance of a Big number object.\r\n     *\r\n     * n {number|string|Big} A numeric value.\r\n     */\r\n    function Big(n) {\r\n      var x = this;\r\n\r\n      // Enable constructor usage without new.\r\n      if (!(x instanceof Big)) {\r\n        return n === UNDEFINED && arguments.length === 0 ? _Big_() : new Big(n);\r\n      }\r\n\r\n      // Duplicate.\r\n      if (n instanceof Big) {\r\n        x.s = n.s;\r\n        x.e = n.e;\r\n        x.c = n.c.slice();\r\n      } else {\r\n        if (typeof n !== 'string') {\r\n          if (Big.strict === true && typeof n !== 'bigint') {\r\n            throw TypeError(INVALID + 'value');\r\n          }\r\n\r\n          // Minus zero?\r\n          n = n === 0 && 1 / n < 0 ? '-0' : String(n);\r\n        }\r\n\r\n        parse(x, n);\r\n      }\r\n\r\n      // Retain a reference to this Big constructor.\r\n      // Shadow Big.prototype.constructor which points to Object.\r\n      x.constructor = Big;\r\n    }\r\n\r\n    Big.prototype = P;\r\n    Big.DP = DP;\r\n    Big.RM = RM;\r\n    Big.NE = NE;\r\n    Big.PE = PE;\r\n    Big.strict = STRICT;\r\n    Big.roundDown = 0;\r\n    Big.roundHalfUp = 1;\r\n    Big.roundHalfEven = 2;\r\n    Big.roundUp = 3;\r\n\r\n    return Big;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the number or string value passed to a Big constructor.\r\n   *\r\n   * x {Big} A Big number instance.\r\n   * n {number|string} A numeric value.\r\n   */\r\n  function parse(x, n) {\r\n    var e, i, nl;\r\n\r\n    if (!NUMERIC.test(n)) {\r\n      throw Error(INVALID + 'number');\r\n    }\r\n\r\n    // Determine sign.\r\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n    // Decimal point?\r\n    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = n.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +n.slice(i + 1);\r\n      n = n.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = n.length;\r\n    }\r\n\r\n    nl = n.length;\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\r\n\r\n    if (i == nl) {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    } else {\r\n\r\n      // Determine trailing zeros.\r\n      for (; nl > 0 && n.charAt(--nl) == '0';);\r\n      x.e = e - i - 1;\r\n      x.c = [];\r\n\r\n      // Convert string to array of digits without leading/trailing zeros.\r\n      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n   *\r\n   * x {Big} The Big to round.\r\n   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   * [more] {boolean} Whether the result of division was truncated.\r\n   */\r\n  function round(x, sd, rm, more) {\r\n    var xc = x.c;\r\n\r\n    if (rm === UNDEFINED) rm = x.constructor.RM;\r\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\r\n      throw Error(INVALID_RM);\r\n    }\r\n\r\n    if (sd < 1) {\r\n      more =\r\n        rm === 3 && (more || !!xc[0]) || sd === 0 && (\r\n        rm === 1 && xc[0] >= 5 ||\r\n        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\r\n      );\r\n\r\n      xc.length = 1;\r\n\r\n      if (more) {\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        x.e = x.e - sd + 1;\r\n        xc[0] = 1;\r\n      } else {\r\n\r\n        // Zero.\r\n        xc[0] = x.e = 0;\r\n      }\r\n    } else if (sd < xc.length) {\r\n\r\n      // xc[sd] is the digit after the digit that may be rounded up.\r\n      more =\r\n        rm === 1 && xc[sd] >= 5 ||\r\n        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\r\n          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\r\n        rm === 3 && (more || !!xc[0]);\r\n\r\n      // Remove any digits after the required precision.\r\n      xc.length = sd;\r\n\r\n      // Round up?\r\n      if (more) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up.\r\n        for (; ++xc[--sd] > 9;) {\r\n          xc[sd] = 0;\r\n          if (sd === 0) {\r\n            ++x.e;\r\n            xc.unshift(1);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (sd = xc.length; !xc[--sd];) xc.pop();\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of Big x in normal or exponential notation.\r\n   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n   */\r\n  function stringify(x, doExponential, isNonzero) {\r\n    var e = x.e,\r\n      s = x.c.join(''),\r\n      n = s.length;\r\n\r\n    // Exponential notation?\r\n    if (doExponential) {\r\n      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\r\n\r\n    // Normal notation.\r\n    } else if (e < 0) {\r\n      for (; ++e;) s = '0' + s;\r\n      s = '0.' + s;\r\n    } else if (e > 0) {\r\n      if (++e > n) {\r\n        for (e -= n; e--;) s += '0';\r\n      } else if (e < n) {\r\n        s = s.slice(0, e) + '.' + s.slice(e);\r\n      }\r\n    } else if (n > 1) {\r\n      s = s.charAt(0) + '.' + s.slice(1);\r\n    }\r\n\r\n    return x.s < 0 && isNonzero ? '-' + s : s;\r\n  }\r\n\r\n\r\n  // Prototype/instance methods\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the absolute value of this Big.\r\n   */\r\n  P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return 1 if the value of this Big is greater than the value of Big y,\r\n   *       -1 if the value of this Big is less than the value of Big y, or\r\n   *        0 if they have the same value.\r\n   */\r\n  P.cmp = function (y) {\r\n    var isneg,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new x.constructor(y)).c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    isneg = i < 0;\r\n\r\n    // Compare exponents.\r\n    if (k != l) return k > l ^ isneg ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = -1; ++i < j;) {\r\n      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.div = function (y) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      a = x.c,                  // dividend\r\n      b = (y = new Big(y)).c,   // divisor\r\n      k = x.s == y.s ? 1 : -1,\r\n      dp = Big.DP;\r\n\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n\r\n    // Divisor is zero?\r\n    if (!b[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    // Dividend is 0? Return +-0.\r\n    if (!a[0]) {\r\n      y.s = k;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    var bl, bt, n, cmp, ri,\r\n      bz = b.slice(),\r\n      ai = bl = b.length,\r\n      al = a.length,\r\n      r = a.slice(0, bl),   // remainder\r\n      rl = r.length,\r\n      q = y,                // quotient\r\n      qc = q.c = [],\r\n      qi = 0,\r\n      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\r\n\r\n    q.s = k;\r\n    k = p < 0 ? 0 : p;\r\n\r\n    // Create version of divisor with leading zero.\r\n    bz.unshift(0);\r\n\r\n    // Add zeros to make remainder as long as divisor.\r\n    for (; rl++ < bl;) r.push(0);\r\n\r\n    do {\r\n\r\n      // n is how many times the divisor goes into current remainder.\r\n      for (n = 0; n < 10; n++) {\r\n\r\n        // Compare divisor and remainder.\r\n        if (bl != (rl = r.length)) {\r\n          cmp = bl > rl ? 1 : -1;\r\n        } else {\r\n          for (ri = -1, cmp = 0; ++ri < bl;) {\r\n            if (b[ri] != r[ri]) {\r\n              cmp = b[ri] > r[ri] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // If divisor < remainder, subtract divisor from remainder.\r\n        if (cmp < 0) {\r\n\r\n          // Remainder can't be more than 1 digit longer than divisor.\r\n          // Equalise lengths using divisor with extra leading zero?\r\n          for (bt = rl == bl ? b : bz; rl;) {\r\n            if (r[--rl] < bt[rl]) {\r\n              ri = rl;\r\n              for (; ri && !r[--ri];) r[ri] = 9;\r\n              --r[ri];\r\n              r[rl] += 10;\r\n            }\r\n            r[rl] -= bt[rl];\r\n          }\r\n\r\n          for (; !r[0];) r.shift();\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Add the digit n to the result array.\r\n      qc[qi++] = cmp ? n : ++n;\r\n\r\n      // Update the remainder.\r\n      if (r[0] && cmp) r[rl] = a[ai] || 0;\r\n      else r = [a[ai]];\r\n\r\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\r\n\r\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n    if (!qc[0] && qi != 1) {\r\n\r\n      // There can't be more than one zero.\r\n      qc.shift();\r\n      q.e--;\r\n      p--;\r\n    }\r\n\r\n    // Round?\r\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\r\n\r\n    return q;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n   */\r\n  P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n   * false.\r\n   */\r\n  P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.gte = function (y) {\r\n    return this.cmp(y) > -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n   */\r\n  P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var i, j, t, xlty,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xc = x.c.slice(),\r\n      xe = x.e,\r\n      yc = y.c,\r\n      ye = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (yc[0]) {\r\n        y.s = -b;\r\n      } else if (xc[0]) {\r\n        y = new Big(x);\r\n      } else {\r\n        y.s = 1;\r\n      }\r\n      return y;\r\n    }\r\n\r\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\r\n    if (a = xe - ye) {\r\n\r\n      if (xlty = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (b = a; b--;) t.push(0);\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = ((xlty = xc.length < yc.length) ? xc : yc).length;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n        if (xc[b] != yc[b]) {\r\n          xlty = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xlty) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    /*\r\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n     * needs to start at yc.length.\r\n     */\r\n    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\r\n\r\n    // Subtract yc from xc.\r\n    for (b = i; j > a;) {\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i];) xc[i] = 9;\r\n        --xc[i];\r\n        xc[j] += 10;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xc[--b] === 0;) xc.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] === 0;) {\r\n      xc.shift();\r\n      --ye;\r\n    }\r\n\r\n    if (!xc[0]) {\r\n\r\n      // n - n = +0\r\n      y.s = 1;\r\n\r\n      // Result must be zero.\r\n      xc = [ye = 0];\r\n    }\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n   */\r\n  P.mod = function (y) {\r\n    var ygtx,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    if (!y.c[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    x.s = y.s = 1;\r\n    ygtx = y.cmp(x) == 1;\r\n    x.s = a;\r\n    y.s = b;\r\n\r\n    if (ygtx) return new Big(x);\r\n\r\n    a = Big.DP;\r\n    b = Big.RM;\r\n    Big.DP = Big.RM = 0;\r\n    x = x.div(y);\r\n    Big.DP = a;\r\n    Big.RM = b;\r\n\r\n    return this.minus(x.times(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big negated.\r\n   */\r\n  P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var e, k, t,\r\n      x = this,\r\n      Big = x.constructor;\r\n\r\n    y = new Big(y);\r\n\r\n    // Signs differ?\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e,\r\n      xc = x.c,\r\n      ye = y.e,\r\n      yc = y.c;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (!yc[0]) {\r\n        if (xc[0]) {\r\n          y = new Big(x);\r\n        } else {\r\n          y.s = x.s;\r\n        }\r\n      }\r\n      return y;\r\n    }\r\n\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    // Note: reverse faster than unshifts.\r\n    if (e = xe - ye) {\r\n      if (e > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        e = -e;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; e--;) t.push(0);\r\n      t.reverse();\r\n    }\r\n\r\n    // Point xc to the longer array.\r\n    if (xc.length - yc.length < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n    }\r\n\r\n    e = yc.length;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\r\n    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n    if (k) {\r\n      xc.unshift(k);\r\n      ++ye;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (e = xc.length; xc[--e] === 0;) xc.pop();\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a Big whose value is the value of this Big raised to the power n.\r\n   * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n   * mode Big.RM.\r\n   *\r\n   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n   */\r\n  P.pow = function (n) {\r\n    var x = this,\r\n      one = new x.constructor('1'),\r\n      y = one,\r\n      isneg = n < 0;\r\n\r\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n      throw Error(INVALID + 'exponent');\r\n    }\r\n\r\n    if (isneg) n = -n;\r\n\r\n    for (;;) {\r\n      if (n & 1) y = y.times(x);\r\n      n >>= 1;\r\n      if (!n) break;\r\n      x = x.times(x);\r\n    }\r\n\r\n    return isneg ? one.div(y) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n   * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.prec = function (sd, rm) {\r\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n      throw Error(INVALID + 'precision');\r\n    }\r\n    return round(new this.constructor(this), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n   * using rounding mode rm, or Big.RM if rm is not specified.\r\n   * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n   * If dp is not specified, round to 0 decimal places.\r\n   *\r\n   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.round = function (dp, rm) {\r\n    if (dp === UNDEFINED) dp = 0;\r\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    return round(new this.constructor(this), dp + this.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.sqrt = function () {\r\n    var r, c, t,\r\n      x = this,\r\n      Big = x.constructor,\r\n      s = x.s,\r\n      e = x.e,\r\n      half = new Big('0.5');\r\n\r\n    // Zero?\r\n    if (!x.c[0]) return new Big(x);\r\n\r\n    // Negative?\r\n    if (s < 0) {\r\n      throw Error(NAME + 'No square root');\r\n    }\r\n\r\n    // Estimate.\r\n    s = Math.sqrt(+stringify(x, true, true));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\r\n    if (s === 0 || s === 1 / 0) {\r\n      c = x.c.join('');\r\n      if (!(c.length + e & 1)) c += '0';\r\n      s = Math.sqrt(c);\r\n      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\r\n    } else {\r\n      r = new Big(s + '');\r\n    }\r\n\r\n    e = r.e + (Big.DP += 4);\r\n\r\n    // Newton-Raphson iteration.\r\n    do {\r\n      t = r;\r\n      r = half.times(t.plus(x.div(t)));\r\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\r\n\r\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big times the value of Big y.\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var c,\r\n      x = this,\r\n      Big = x.constructor,\r\n      xc = x.c,\r\n      yc = (y = new Big(y)).c,\r\n      a = xc.length,\r\n      b = yc.length,\r\n      i = x.e,\r\n      j = y.e;\r\n\r\n    // Determine sign of result.\r\n    y.s = x.s == y.s ? 1 : -1;\r\n\r\n    // Return signed 0 if either 0.\r\n    if (!xc[0] || !yc[0]) {\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // Initialise exponent of result as x.e + y.e.\r\n    y.e = i + j;\r\n\r\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n    if (a < b) {\r\n      c = xc;\r\n      xc = yc;\r\n      yc = c;\r\n      j = a;\r\n      a = b;\r\n      b = j;\r\n    }\r\n\r\n    // Initialise coefficient array of result with zeros.\r\n    for (c = new Array(j = a + b); j--;) c[j] = 0;\r\n\r\n    // Multiply.\r\n\r\n    // i is initially xc.length.\r\n    for (i = b; i--;) {\r\n      b = 0;\r\n\r\n      // a is yc.length.\r\n      for (j = a + i; j > i;) {\r\n\r\n        // Current sum of products at this digit position, plus carry.\r\n        b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n        c[j--] = b % 10;\r\n\r\n        // carry\r\n        b = b / 10 | 0;\r\n      }\r\n\r\n      c[j] = b;\r\n    }\r\n\r\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\r\n    if (b) ++y.e;\r\n    else c.shift();\r\n\r\n    // Remove trailing zeros.\r\n    for (i = c.length; !c[--i];) c.pop();\r\n    y.c = c;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), ++dp, rm);\r\n      for (; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, true, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), dp + x.e + 1, rm);\r\n\r\n      // x.e may have changed if the value is rounded up.\r\n      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, false, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Omit the sign for negative zero.\r\n   */\r\n  P.toJSON = P.toString = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Big as a primitve number.\r\n   */\r\n  P.toNumber = function () {\r\n    var n = +stringify(this, true, true);\r\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\r\n      throw Error(NAME + 'Imprecise conversion');\r\n    }\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big rounded to sd significant digits using\r\n   * rounding mode rm, or Big.RM if rm is not specified.\r\n   * Use exponential notation if sd is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      n = x.c[0];\r\n\r\n    if (sd !== UNDEFINED) {\r\n      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n        throw Error(INVALID + 'precision');\r\n      }\r\n      x = round(new Big(x), sd, rm);\r\n      for (; x.c.length < sd;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Include the sign for negative zero.\r\n   */\r\n  P.valueOf = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    if (Big.strict === true) {\r\n      throw Error(NAME + 'valueOf disallowed');\r\n    }\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\r\n  };\r\n\r\n\r\n  // Export\r\n\r\n\r\n  Big = _Big_();\r\n\r\n  Big['default'] = Big.Big = Big;\r\n\r\n  //AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () { return Big; });\r\n\r\n  // Node and other CommonJS-like environments that support module.exports.\r\n  } else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Big;\r\n\r\n  //Browser.\r\n  } else {\r\n    GLOBAL.Big = Big;\r\n  }\r\n})(this);\r\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - pet friendly\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'ObjectCache';\n\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._RecordMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\tget RecordMap()\n\t{\n\t\treturn this._RecordMap;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\tthis._RecordMap[pHash] = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\t\tthis._RecordMap[pHash] = pData;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._RecordMap[pHash];\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t{\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\t\t\t}\n\t\t}\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;","/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;","\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;","'use strict';\n\nvar bind = require('function-bind');\n\nvar $apply = require('./functionApply');\nvar $call = require('./functionCall');\nvar $reflectApply = require('./reflectApply');\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n","'use strict';\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n","'use strict';\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n","'use strict';\n\nvar bind = require('function-bind');\nvar $TypeError = require('es-errors/type');\n\nvar $call = require('./functionCall');\nvar $actualApply = require('./actualApply');\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n","'use strict';\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBindBasic = require('call-bind-apply-helpers');\n\n/** @type {(thisArg: string, searchString: string, position?: number) => number} */\nvar $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);\n\n/** @type {import('.')} */\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\t/* eslint no-extra-parens: 0 */\n\n\tvar intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBindBasic(/** @type {const} */ ([intrinsic]));\n\t}\n\treturn intrinsic;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCookie = parseCookie;\nexports.parse = parseCookie;\nexports.stringifyCookie = stringifyCookie;\nexports.stringifySetCookie = stringifySetCookie;\nexports.serialize = stringifySetCookie;\nexports.parseSetCookie = parseSetCookie;\nexports.stringifySetCookie = stringifySetCookie;\nexports.serialize = stringifySetCookie;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n/**\n * RegExp to match max-age-value in RFC 6265 sec 5.6.2\n */\nconst maxAgeRegExp = /^-?\\d+$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a `Cookie` header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parseCookie(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = eqIndex(str, index, len);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const endIdx = endIndex(str, index, len);\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const key = valueSlice(str, index, eqIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\n/**\n * Stringifies an object into an HTTP `Cookie` header.\n */\nfunction stringifyCookie(cookie, options) {\n    const enc = options?.encode || encodeURIComponent;\n    const cookieStrings = [];\n    for (const name of Object.keys(cookie)) {\n        const val = cookie[name];\n        if (val === undefined)\n            continue;\n        if (!cookieNameRegExp.test(name)) {\n            throw new TypeError(`cookie name is invalid: ${name}`);\n        }\n        const value = enc(val);\n        if (!cookieValueRegExp.test(value)) {\n            throw new TypeError(`cookie val is invalid: ${val}`);\n        }\n        cookieStrings.push(`${name}=${value}`);\n    }\n    return cookieStrings.join(\"; \");\n}\nfunction stringifySetCookie(_name, _val, _opts) {\n    const cookie = typeof _name === \"object\"\n        ? _name\n        : { ..._opts, name: _name, value: String(_val) };\n    const options = typeof _val === \"object\" ? _val : _opts;\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(cookie.name)) {\n        throw new TypeError(`argument name is invalid: ${cookie.name}`);\n    }\n    const value = cookie.value ? enc(cookie.value) : \"\";\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${cookie.value}`);\n    }\n    let str = cookie.name + \"=\" + value;\n    if (cookie.maxAge !== undefined) {\n        if (!Number.isInteger(cookie.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);\n        }\n        str += \"; Max-Age=\" + cookie.maxAge;\n    }\n    if (cookie.domain) {\n        if (!domainValueRegExp.test(cookie.domain)) {\n            throw new TypeError(`option domain is invalid: ${cookie.domain}`);\n        }\n        str += \"; Domain=\" + cookie.domain;\n    }\n    if (cookie.path) {\n        if (!pathValueRegExp.test(cookie.path)) {\n            throw new TypeError(`option path is invalid: ${cookie.path}`);\n        }\n        str += \"; Path=\" + cookie.path;\n    }\n    if (cookie.expires) {\n        if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${cookie.expires}`);\n        }\n        str += \"; Expires=\" + cookie.expires.toUTCString();\n    }\n    if (cookie.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (cookie.secure) {\n        str += \"; Secure\";\n    }\n    if (cookie.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (cookie.priority) {\n        const priority = typeof cookie.priority === \"string\"\n            ? cookie.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${cookie.priority}`);\n        }\n    }\n    if (cookie.sameSite) {\n        const sameSite = typeof cookie.sameSite === \"string\"\n            ? cookie.sameSite.toLowerCase()\n            : cookie.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * Deserialize a `Set-Cookie` header into an object.\n *\n * deserialize('foo=bar; httpOnly')\n *   => { name: 'foo', value: 'bar', httpOnly: true }\n */\nfunction parseSetCookie(str, options) {\n    const dec = options?.decode || decode;\n    const len = str.length;\n    const endIdx = endIndex(str, 0, len);\n    const eqIdx = eqIndex(str, 0, endIdx);\n    const setCookie = eqIdx === -1\n        ? { name: \"\", value: dec(valueSlice(str, 0, endIdx)) }\n        : {\n            name: valueSlice(str, 0, eqIdx),\n            value: dec(valueSlice(str, eqIdx + 1, endIdx)),\n        };\n    let index = endIdx + 1;\n    while (index < len) {\n        const endIdx = endIndex(str, index, len);\n        const eqIdx = eqIndex(str, index, endIdx);\n        const attr = eqIdx === -1\n            ? valueSlice(str, index, endIdx)\n            : valueSlice(str, index, eqIdx);\n        const val = eqIdx === -1 ? undefined : valueSlice(str, eqIdx + 1, endIdx);\n        switch (attr.toLowerCase()) {\n            case \"httponly\":\n                setCookie.httpOnly = true;\n                break;\n            case \"secure\":\n                setCookie.secure = true;\n                break;\n            case \"partitioned\":\n                setCookie.partitioned = true;\n                break;\n            case \"domain\":\n                setCookie.domain = val;\n                break;\n            case \"path\":\n                setCookie.path = val;\n                break;\n            case \"max-age\":\n                if (val && maxAgeRegExp.test(val))\n                    setCookie.maxAge = Number(val);\n                break;\n            case \"expires\":\n                if (!val)\n                    break;\n                const date = new Date(val);\n                if (Number.isFinite(date.valueOf()))\n                    setCookie.expires = date;\n                break;\n            case \"priority\":\n                if (!val)\n                    break;\n                const priority = val.toLowerCase();\n                if (priority === \"low\" ||\n                    priority === \"medium\" ||\n                    priority === \"high\") {\n                    setCookie.priority = priority;\n                }\n                break;\n            case \"samesite\":\n                if (!val)\n                    break;\n                const sameSite = val.toLowerCase();\n                if (sameSite === \"lax\" ||\n                    sameSite === \"strict\" ||\n                    sameSite === \"none\") {\n                    setCookie.sameSite = sameSite;\n                }\n                break;\n        }\n        index = endIdx + 1;\n    }\n    return setCookie;\n}\n/**\n * Find the `;` character between `min` and `len` in str.\n */\nfunction endIndex(str, min, len) {\n    const index = str.indexOf(\";\", min);\n    return index === -1 ? len : index;\n}\n/**\n * Find the `=` character between `min` and `max` in str.\n */\nfunction eqIndex(str, min, max) {\n    const index = str.indexOf(\"=\", min);\n    return index < max ? index : -1;\n}\n/**\n * Slice out a value between startPod to max.\n */\nfunction valueSlice(str, min, max) {\n    let start = min;\n    let end = max;\n    do {\n        const code = str.charCodeAt(start);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            break;\n    } while (++start < end);\n    while (end > start) {\n        const code = str.charCodeAt(end - 1);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            break;\n        end--;\n    }\n    return str.slice(start, end);\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n//# sourceMappingURL=index.js.map","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_advancedFormat=t()}(this,(function(){\"use strict\";return function(e,t){var r=t.prototype,n=r.format;r.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return n.bind(this)(e);var s=this.$utils(),a=(e||\"YYYY-MM-DDTHH:mm:ssZ\").replace(/\\[([^\\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case\"Q\":return Math.ceil((t.$M+1)/3);case\"Do\":return r.ordinal(t.$D);case\"gggg\":return t.weekYear();case\"GGGG\":return t.isoWeekYear();case\"wo\":return r.ordinal(t.week(),\"W\");case\"w\":case\"ww\":return s.s(t.week(),\"w\"===e?1:2,\"0\");case\"W\":case\"WW\":return s.s(t.isoWeek(),\"W\"===e?1:2,\"0\");case\"k\":case\"kk\":return s.s(String(0===t.$H?24:t.$H),\"k\"===e?1:2,\"0\");case\"X\":return Math.floor(t.$d.getTime()/1e3);case\"x\":return t.$d.getTime();case\"z\":return\"[\"+t.offsetName()+\"]\";case\"zzz\":return\"[\"+t.offsetName(\"long\")+\"]\";default:return e}}));return n.bind(this)(a)}}}));","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_isoWeek=t()}(this,(function(){\"use strict\";var e=\"day\";return function(t,i,s){var a=function(t){return t.add(4-t.isoWeekday(),e)},d=i.prototype;d.isoWeekYear=function(){return a(this).year()},d.isoWeek=function(t){if(!this.$utils().u(t))return this.add(7*(t-this.isoWeek()),e);var i,d,n,o,r=a(this),u=(i=this.isoWeekYear(),d=this.$u,n=(d?s.utc:s)().year(i).startOf(\"year\"),o=4-n.isoWeekday(),n.isoWeekday()>4&&(o+=7),n.add(o,e));return r.diff(u,\"week\")+1},d.isoWeekday=function(e){return this.$utils().u(e)?this.day()||7:this.day(this.day()%7?e:e-7)};var n=d.startOf;d.startOf=function(e,t){var i=this.$utils(),s=!!i.u(t)||t;return\"isoweek\"===i.p(e)?s?this.date(this.date()-(this.isoWeekday()-1)).startOf(\"day\"):this.date(this.date()-1-(this.isoWeekday()-1)+7).endOf(\"day\"):n.bind(this)(e,t)}}}));","!function(r,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(r=\"undefined\"!=typeof globalThis?globalThis:r||self).dayjs_plugin_relativeTime=e()}(this,(function(){\"use strict\";return function(r,e,t){r=r||{};var n=e.prototype,o={future:\"in %s\",past:\"%s ago\",s:\"a few seconds\",m:\"a minute\",mm:\"%d minutes\",h:\"an hour\",hh:\"%d hours\",d:\"a day\",dd:\"%d days\",M:\"a month\",MM:\"%d months\",y:\"a year\",yy:\"%d years\"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:\"s\",r:44,d:\"second\"},{l:\"m\",r:89},{l:\"mm\",r:44,d:\"minute\"},{l:\"h\",r:89},{l:\"hh\",r:21,d:\"hour\"},{l:\"d\",r:35},{l:\"dd\",r:25,d:\"day\"},{l:\"M\",r:45},{l:\"MM\",r:10,d:\"month\"},{l:\"y\",r:17},{l:\"yy\",d:\"year\"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(\"\"+p)),a=\"string\"==typeof v?v.replace(\"%d\",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return\"function\"==typeof M?M(a):M.replace(\"%s\",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_timezone=e()}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,h=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n,i=this.utcOffset(),a=this.toDate(),u=a.toLocaleString(\"en-US\",{timeZone:t}),f=Math.round((a-new Date(u))/1e3/60),s=15*-Math.round(a.getTimezoneOffset()/15)-f;if(!Number(s))n=this.utcOffset(0,e);else if(n=o(u,{locale:this.$L}).$set(\"millisecond\",this.$ms).utcOffset(s,!0),e){var m=n.utcOffset();n=n.add(i-m,\"minute\")}return n.$x.$timezone=t,n},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_utc=i()}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var r=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),r.call(this,t)};var o=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else o.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s;if(0===u)return this.utc(f);var r=this.clone();if(f)return r.$offset=u,r.$u=!1,r;var o=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();return(r=this.local().add(u+o,t)).$offset=u,r.$x.$localOffset=o,r};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekOfYear=t()}(this,(function(){\"use strict\";var e=\"week\",t=\"year\";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),\"day\");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,\"millisecond\"),o=this.diff(a,e,!0);return o<0?r(this).startOf(\"week\").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}));","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekday=t()}(this,(function(){\"use strict\";return function(e,t){t.prototype.weekday=function(e){var t=this.$locale().weekStart||0,i=this.$W,n=(i<t?i+7:i)-t;return this.$utils().u(e)?n:this.subtract(n,\"day\").add(e,\"day\")}}}));","'use strict';\n\nvar callBind = require('call-bind-apply-helpers');\nvar gOPD = require('gopd');\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n","'use strict';\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n","'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n","'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n","'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n","'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n","'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n","'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Object;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","module.exports={\n    \"name\": \"fable-log\",\n    \"version\": \"3.0.17\",\n    \"description\": \"A simple logging wrapper.\",\n    \"main\": \"source/Fable-Log.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-Log.js\",\n        \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n        \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"browser\": {\n        \"./source/Fable-Log-DefaultProviders-Node.js\": \"./source/Fable-Log-DefaultProviders-Web.js\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-log.git\"\n    },\n    \"keywords\": [\n        \"logging\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-log/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-log\",\n    \"devDependencies\": {\n        \"quackage\": \"^1.0.51\"\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.17\"\n    }\n}\n","/**\n* Base Logger Class\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass BaseLogger extends libFableServiceProviderBase\n{\n\tconstructor(pLogStreamSettings, pLogStreamHash)\n\t{\n\t\tsuper(pLogStreamSettings, pLogStreamHash);\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\tthis.serviceType = 'Logging-Provider';\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = ('showtimestamps' in this._Settings) ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = ('formattedtimestamps' in this._Settings) ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = ('Context' in this._Settings) ? `(${this._Settings.Context})` :\n\t\t\t\t\t\t\t\t('Product' in pFableLog._Settings) ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = ('outputloglinestoconsole' in this._Settings) ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = ('outputobjectstoconsole' in this._Settings) ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t}\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Service\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nconst libPackage = require('../package.json');\n\nclass FableLog extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'Logging';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\tlet tmpSettings = (typeof(pSettings) === 'object') ? pSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (('LogStreams' in tmpSettings)) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (pLogger.loggerUUID in this.activeLogStreams)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!(tmpStreamDefinition.loggertype in this._Providers))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\nmodule.exports = FableLog;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderFlatfile = require('./Fable-Log-Logger-SimpleFlatFile.js');\n","module.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.18\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"types\": \"tsc -p ./tsconfig.build.json\",\n        \"check\": \"tsc -p . --noEmit\"\n    },\n    \"types\": \"types/source/Fable-ServiceProviderBase.d.ts\",\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"@types/mocha\": \"^10.0.10\",\n        \"fable\": \"^3.1.55\",\n        \"quackage\": \"^1.0.51\",\n        \"typescript\": \"^5.9.3\"\n    }\n}\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t/**\n\t * The constructor can be used in two ways:\n\t * 1) With a fable, options object and service hash (the options object and service hash are optional)a\n\t * 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\t *\n\t * @param {import('fable')|Record<string, any>} [pFable] - (optional) The fable instance, or the options object if there is no fable\n\t * @param {Record<string, any>|string} [pOptions] - (optional) The options object, or the service hash if there is no fable\n\t * @param {string} [pServiceHash] - (optional) The service hash to identify this service instance\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t/** @type {import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.options;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.services;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.servicesMap;\n\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Record<string, any>} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\t/**\n\t * @param {import('fable')} pFable\n\t */\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n","module.exports={\n  \"name\": \"fable-settings\",\n  \"version\": \"3.0.15\",\n  \"description\": \"A simple, tolerant configuration chain.\",\n  \"main\": \"source/Fable-Settings.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable-Settings.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"./node_modules/.bin/gulp build\",\n    \"docker-dev-build-image\": \"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-settings:local\",\n    \"docker-dev-run\": \"docker run -it -d --name retold-fable-settings-dev -p 30003:8080 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable-settings\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" retold/fable-settings:local\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable-settings.git\"\n  },\n  \"keywords\": [\n    \"configuration\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable-settings/issues\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable-settings\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"fable-serviceproviderbase\": \"^3.0.17\",\n    \"precedent\": \"^1.0.15\"\n  }\n}\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\nconst libPrecedent = require('precedent');\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new libPrecedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\tconst tmpDefaultValue = tmpSeparatorIndex >= 0 ? tmpTemplateValue.substring(tmpSeparatorIndex+1) : '';\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (tmpEnvironmentVariableName in process.env)\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n","/**\n* Fable Settings Add-on\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'SettingsManager';\n\n\t\tthis._Package = require('../package.json');\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor();\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;","module.exports={\n  \"name\": \"fable-uuid\",\n  \"version\": \"3.0.12\",\n  \"description\": \"A simple UUID Generator.\",\n  \"main\": \"source/Fable-UUID.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable-UUID.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"./node_modules/.bin/gulp build\",\n    \"docker-dev-build-image\": \"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-uuid:local\",\n    \"docker-dev-run\": \"docker run -it -d --name retold-fable-uuid-dev -p 30002:8080 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable-uuid\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" retold/fable-uuid:local\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable-uuid.git\"\n  },\n  \"keywords\": [\n    \"logging\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable-uuid/issues\"\n  },\n  \"browser\": {\n    \"./source/Fable-UUID-Random.js\": \"./source/Fable-UUID-Random-Browser.js\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable-uuid\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"fable-serviceproviderbase\": \"^3.0.17\"\n  }\n}\n","/**\n* Random Byte Generator - Browser version\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;0\n\nconst libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nconst libPackage = require('../package.json');\n\nclass FableUUID extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'UUID';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && ('UUIDModeRandom' in pSettings) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && ('UUIDLength' in pSettings) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && ('UUIDDictionary' in pSettings) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $Object = require('es-object-atoms');\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar abs = require('math-intrinsics/abs');\nvar floor = require('math-intrinsics/floor');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar pow = require('math-intrinsics/pow');\nvar round = require('math-intrinsics/round');\nvar sign = require('math-intrinsics/sign');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = require('gopd');\nvar $defineProperty = require('es-define-property');\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = require('get-proto');\nvar $ObjectGPO = require('get-proto/Object.getPrototypeOf');\nvar $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');\n\nvar $apply = require('call-bind-apply-helpers/functionApply');\nvar $call = require('call-bind-apply-helpers/functionCall');\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar $Object = require('es-object-atoms');\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n","'use strict';\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n","'use strict';\n\nvar reflectGetProto = require('./Reflect.getPrototypeOf');\nvar originalGetProto = require('./Object.getPrototypeOf');\n\nvar getDunderProto = require('dunder-proto/get');\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n","'use strict';\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n","'use strict';\n\n/** @type {import('.')} */\nvar $gOPD = require('./gOPD');\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\n/**\n * @param {string} pCharacter - The character to remove from the start and end of the string\n * @param {string} pString - The string to clean\n *\n * @return {string} The cleaned string\n */\nconst cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n    /**\n     * @param {function} [pInfoLog] - (optional) A logging function for info messages\n     * @param {function} [pErrorLog] - (optional) A logging function for error messages\n     */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    /**\n     * @return {number} The number of translations in the table\n     */\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    /**\n     * @param {object} pTranslation - An object containing source:destination hash pairs to add to the translation table\n     */\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    /**\n     * @param {string} pTranslationHash - The source hash to remove from the translation table\n     */\n    removeTranslationHash(pTranslationHash)\n    {\n        delete this.translationTable[pTranslationHash];\n    }\n\n    /**\n     * This removes translations.\n     * If passed a string, just removes the single one.\n     * If passed an object, it does all the source keys.\n     *\n     * @param {string|object} pTranslation - Either a source hash string to remove, or an object containing source:destination hash pairs to remove\n     *\n     * @return {boolean} True if the removal was successful, false otherwise\n     */\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    /**\n     * @param {string} pTranslation - The source hash to translate\n     *\n     * @return {string} The translated hash, or the original if no translation exists\n     */\n    translate(pTranslation)\n    {\n        if (pTranslation in this.translationTable)\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;\n","/**\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Manyfest-LogToConsole.js');\n// This is for resolving functions mid-address\nconst libGetObjectValue = require('./Manyfest-ObjectAddress-GetValue.js');\n\nconst fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n// TODO: Just until this is a fable service.\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) Function to use for info logging\n\t * @param {function} [pErrorLog] - (optional) Function to use for error logging\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.getObjectValueClass = new libGetObjectValue(this.logInfo, this.logError);\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * Check if an address exists.\n\t *\n\t * This is necessary because the getValueAtAddress function is ambiguous on\n\t * whether the element/property is actually there or not (it returns\n\t * undefined whether the property exists or not).  This function checks for\n\t * existance and returns true or false dependent.\n\t *\n\t * @param {object} pObject - The object to check within\n\t * @param {string} pAddress - The address to check for\n\t * @param {object} [pRootObject] - (optional) The root object for function resolution context\n\t *\n\t * @return {boolean} - True if the address exists, false if it does not\n\t */\n\tcheckAddressExists(pObject, pAddress, pRootObject)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\t// NOTE: This was added to support functions mid-stream\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (((tmpFunctionAddress in pObject)) && (typeof(pObject[tmpFunctionAddress]) == 'function'))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn (tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn (pAddress in pObject);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\t//tmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// NOTE: This is where the resolves get really tricky.  Recursion within recursion.  Programming gom jabbar, yo.\n\t\t\t\t\t\ttmpArgumentValues.push(this.getObjectValueClass.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t//return this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// The sub-object doesn't exist, so the address doesn't exist\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`)\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// TODO: Dry me\n\t/**\n\t * @param {string} pAddress - The address being evaluated\n\t * @param {object} pRecord - The record being evaluated\n\t *\n\t * @return {boolean} True if the record passes the filters, false if it does not\n\t */\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t/**\n\t * Delete the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to delete the value from\n\t * @param {string} pAddress - The address to delete the value at\n\t * @param {string} [pParentAddress] - (optional) The parent address for recursion\n\t *\n\t * @return {boolean|object|undefined} - True if the value was deleted, false if it could not be deleted, undefined on error\n\t */\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Use enclosure-aware parser to find the first segment separator\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`);\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * @param {string} pAddress - The address of the record to check\n\t * @param {object} pRecord - The record to check against the filters\n\t *\n\t * @return {boolean} - True if the record passes the filters, false otherwise\n\t */\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t/**\n\t * Get the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to resolve the address against\n\t * @param {string} pAddress - The address to resolve\n\t * @param {string} [pParentAddress] - (optional) The parent address for back-navigation\n\t * @param {object} [pRootObject] - (optional) The root object for function argument resolution\n\t *\n\t * @return {any} The value at the address, or undefined if not found\n\t */\n\tgetValueAtAddress (pObject, pAddress, pParentAddress, pRootObject)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tif (pObject === null)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// Adding simple back-navigation in objects\n\t\tif (tmpAddressPartBeginning == '')\n\t\t{\n\t\t\t// Given an address of \"Bundle.Contract.IDContract...Project.IDProject\" the ... would be interpreted as two back-navigations from IDContract.\n\t\t\t// When the address is passed in, though, the first . is already eliminated.  So we can count the dots.\n\t\t\tlet tmpParentAddressParts = _MockFable.DataFormat.stringGetSegments(tmpParentAddress);\n\n\t\t\tlet tmpBackNavigationCount = 0;\n\n\t\t\t// Count the number of dots\n\t\t\tfor (let i = 0; i < pAddress.length; i++)\n\t\t\t{\n\t\t\t\tif (pAddress.charAt(i) != '.')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpBackNavigationCount++;\n\t\t\t}\n\n\t\t\tlet tmpParentAddressLength = tmpParentAddressParts.length - tmpBackNavigationCount;\n\n\t\t\tif (tmpParentAddressLength < 0)\n\t\t\t{\n\t\t\t\t// We are trying to back navigate more than we can.\n\t\t\t\t// TODO: Should this be undefined or should we bank out at the bottom and try to go forward?\n\t\t\t\t// This seems safest for now.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are trying to back navigate to a parent object.\n\t\t\t\t// Recurse with the back-propagated parent address, and, the new address without the back-navigation dots.\n\t\t\t\tlet tmpRecurseAddress = pAddress.slice(tmpBackNavigationCount);\n\t\t\t\tif (tmpParentAddressLength > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRecurseAddress = `${tmpParentAddressParts.slice(0, tmpParentAddressLength).join('.')}.${tmpRecurseAddress}`;\n\t\t\t\t}\n\t\t\t\tthis.logInfo(`Back-navigation detected.  Recursing back to address [${tmpRecurseAddress}]`);\n\t\t\t\treturn this.getValueAtAddress(tmpRootObject, tmpRecurseAddress);\n\t\t\t}\n\t\t}\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// TODO: Optimize this by having these calls only happen when the previous fails.\n\t\t\t// TODO: Alternatively look for all markers in one pass?\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(pAddress.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tif (typeof(pObject[pAddress]) != 'undefined')\n\t\t\t\t{\n\t\t\t\t\treturn pObject[pAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//let tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\t//let tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (typeof pObject[tmpFunctionAddress] !== 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;\n","// TODO: This is an inelegant solution to delay the rewrite of Manyfest.\n\n// Fable 3.0 has a service for data formatting that deals well with nested enclosures.\n\n// The Manyfest library predates fable 3.0 and the services structure of it, so the functions\n// are more or less pure javascript and as functional as they can be made to be.\n\n// Until we shift Manyfest to be a fable service, these three functions were pulled out of\n// fable to aid in parsing functions with nested enclosures.\n\nconst DEFAULT_START_SYMBOL_MAP = { '{': 0, '[': 1, '(': 2 };\nconst DEFAULT_END_SYMBOL_MAP = { '}': 0, ']': 1, ')': 2 };\n\nmodule.exports = {\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {number} - The number of segments in the string\n\t */\n\tstringCountSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t},\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {string} - the first segment in the string as a string\n\t */\n\tstringGetFirstSegment: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t},\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} [pSeparator]\n\t * @param {Record<string, number>} [pEnclosureStartSymbolMap]\n\t * @param {Record<string, number>} [pEnclosureEndSymbolMap]\n\t *\n\t * @return {Array<string>} - the segments in the string as an array of strings\n\t */\n\tstringGetSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStartSymbolMap : DEFAULT_START_SYMBOL_MAP;\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEndSymbolMap : DEFAULT_END_SYMBOL_MAP;\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (tmpString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t},\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} [pEnclosureStart]\n\t * @param {string} [pEnclosureEnd]\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures: (pString, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t},\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} [pEnclosureStart]\n\t * @param {string} [pEnclosureEnd]\n\t *\n\t * @return {string} - The value of the enclosure at the specified index\n\t */\n\tstringGetEnclosureValueByIndex: (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n}\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t/**\n\t * Set the value of an element at an address\n\t *\n\t * @param {object} pObject - The object to set the value in\n\t * @param {string} pAddress - The address to set the value at\n\t * @param {any} pValue - The value to set at the address\n\t *\n\t * @return {boolean} True if the value was set, false otherwise\n\t */\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Use enclosure-aware parser to find the first segment separator\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\t\t\t\tlet tmpIndexIsNumeric = !isNaN(tmpBoxedPropertyNumber);\n\n\t\t\t\tif (pObject[tmpBoxedPropertyName] == null)\n\t\t\t\t{\n\t\t\t\t\tif (tmpIndexIsNumeric)\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = [];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\tif (!(tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\t//TODO: For cases where we have chained [][] properties, this needs to recurse somehow\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(pObject[tmpBoxedPropertyName].length < (tmpBoxedPropertyNumber + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName].push({});\n\t\t\t\t\t}\n\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\t\t\t\tlet tmpIndexIsNumeric = !isNaN(tmpBoxedPropertyNumber);\n\n\t\t\t\t//if (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\tif (pObject[tmpBoxedPropertyName] == null)\n\t\t\t\t{\n\t\t\t\t\tif (tmpIndexIsNumeric)\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = [];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) != tmpIndexIsNumeric)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\tif (!(tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(pObject[tmpBoxedPropertyName].length < (tmpBoxedPropertyNumber + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the subobject doesn't exist, create it\n\t\t\t\t\t\tpObject[tmpBoxedPropertyName].push({});\n\t\t\t\t\t}\n\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!('__ERROR' in pObject))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t/**\n\t * generateAddressses\n\t *\n\t * This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t * POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t * quickly.  This is not meant to be used directly to generate schemas, but\n\t * instead as a starting point for scripts or UIs.\n\t *\n\t * This will return a mega set of key:value pairs with all possible schema\n\t * permutations and default values (when not an object) and everything else.\n\t *\n\t * @param {any} pObject - The object to generate addresses for\n\t * @param {string} [pBaseAddress] - (optional) The base address to start from\n\t * @param {object} [pSchema] - (optional) The schema object to append to\n\t *\n\t * @return {object} The generated schema object\n\t */\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'undefined';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;\n","// Given a string, parse out any conditional expressions and set whether or not to keep the record.\n//\n// For instance:\n// \t\t'files[]<<~?format,==,Thumbnail?~>>'\n//      'files[]<<~?format,==,Metadata?~>>'\n//      'files[]<<~?size,>,4000?~>>'\n//\n// The wrapping parts are the <<~? and ?~>> megabrackets.\n//\n// The function does not need to alter the string -- just check the conditionals within.\n\n// TODO: Consider making this an es6 class\n\n// Let's use indexOf since it is apparently the fastest.\nconst _ConditionalStanzaStart = '<<~?';\nconst _ConditionalStanzaStartLength = _ConditionalStanzaStart.length;\nconst _ConditionalStanzaEnd = '?~>>';\nconst _ConditionalStanzaEndLength = _ConditionalStanzaEnd.length;\n\n// Ugh dependency injection.  Can't wait to make these all fable services.\n//let libObjectAddressCheckAddressExists = new (require('./Manyfest-ObjectAddress-CheckAddressExists.js'))();\n\n// Test the condition of a value in a record\nconst testCondition = (pManyfest, pRecord, pSearchAddress, pSearchComparator, pValue) =>\n{\n\tswitch(pSearchComparator)\n\t{\n\t\tcase 'TRUE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === true);\n\t\tcase 'FALSE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === false);\n\t\tcase 'LNGT':\n\t\tcase 'LENGTH_GREATER_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'LNLT':\n\t\tcase 'LENGTH_LESS_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t// TODO: Welcome to dependency hell.  This fixes itself when we move to fable services.\n\t\t// case 'EX':\n\t\t// case 'EXISTS':\n\t\t// \treturn libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\t// case 'DNEX':\n\t\t// case 'DOES_NOT_EXIST':\n\t\t// \treturn !libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\tcase '!=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) != pValue);\n\t\tcase '<':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) < pValue);\n\t\tcase '>':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) > pValue);\n\t\tcase '<=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) <= pValue);\n\t\tcase '>=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) >= pValue);\n\t\tcase '===':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === pValue);\n\t\tcase '==':\n\t\tdefault:\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) == pValue);\n\t}\n};\n\nconst parseConditionals = (pManyfest, pAddress, pRecord) =>\n{\n\tlet tmpKeepRecord = true;\n\n\t/*\n\t\tAlgorithm is simple:\n\n\t\t1.  Enuerate start points\n\t\t2.  Find stop points within each start point\n\t\t3. Check the conditional\n\t*/\n\tlet tmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart);\n\n\twhile (tmpStartIndex != -1)\n\t{\n\t\tlet tmpStopIndex = pAddress.indexOf(_ConditionalStanzaEnd, tmpStartIndex+_ConditionalStanzaStartLength);\n\n\t\tif (tmpStopIndex != -1)\n\t\t{\n\t\t\tlet tmpMagicComparisonPatternSet = pAddress.substring(tmpStartIndex+_ConditionalStanzaStartLength, tmpStopIndex).split(',');\n\n\t\t\t// The address to search for\n\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\n\t\t\t// The copmparison expression (EXISTS as default)\n\t\t\tlet tmpSearchComparator = 'EXISTS';\n\t\t\tif (tmpMagicComparisonPatternSet.length > 1)\n\t\t\t{\n\t\t\t\ttmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t}\n\n\t\t\t// The value to search for\n\t\t\tlet tmpSearchValue = false;\n\t\t\tif (tmpMagicComparisonPatternSet.length > 2)\n\t\t\t{\n\t\t\t\ttmpSearchValue = tmpMagicComparisonPatternSet[2];\n\t\t\t}\n\n\t\t\t// Process the piece\n\t\t\ttmpKeepRecord = tmpKeepRecord && testCondition(pManyfest, pRecord, tmpSearchAddress, tmpSearchComparator, tmpSearchValue);\n\t\t\ttmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart, tmpStopIndex+_ConditionalStanzaEndLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpStartIndex = -1;\n\t\t}\n\n\t}\n\n\treturn tmpKeepRecord;\n}\n\nmodule.exports = parseConditionals;\n","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\t/**\n\t * @param {function} [pInfoLog] - (optional) A logging function for info messages\n\t * @param {function} [pErrorLog] - (optional) A logging function for error messages\n\t */\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t/**\n     * This translates the default address mappings to something different.\n     *\n     * For instance you can pass in manyfest schema descriptor object:\n     * \t{\n\t *\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t *\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t *  }\n     *\n     *\n     * And then an address mapping (basically a Hash->Address map)\n     *  {\n     *    \"a\": \"New.Address.Of.a\",\n     *    \"b\": \"New.Address.Of.b\"\n     *  }\n     *\n     * NOTE: This mutates the schema object permanently, altering the base hash.\n     *       If there is a collision with an existing address, it can lead to overwrites.\n     * TODO: Discuss what should happen on collisions.\n\t *\n\t * @param {object} pManyfestSchemaDescriptors - The manyfest schema descriptors to resolve address mappings for\n\t * @param {object} pAddressMapping - The address mapping object to use for remapping\n\t *\n\t * @return {boolean} True if successful, false if there was an error\n\t */\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif ('Hash' in pManyfestSchemaDescriptors[pAddress])\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = null;\n\t\t\t\tlet tmpDescriptor;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pInputAddress in pManyfestSchemaDescriptors)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (pInputAddress in tmpHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {object} pManyfestSchemaDescriptors - The manyfest schema descriptors to resolve address mappings for\n\t * @param {object} pAddressMapping - The address mapping object to use for remapping\n\t *\n\t * @return {object} A new object containing the remapped schema descriptors\n\t */\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\t/**\n\t * @param {object} pManyfestSchemaDescriptorsDestination - The destination manyfest schema descriptors\n\t * @param {object} pManyfestSchemaDescriptorsSource - The source manyfest schema descriptors\n\t *\n\t * @return {object} A new object containing the merged schema descriptors\n\t */\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!(pDescriptorAddress in tmpNewManyfestSchemaDescriptors))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;\n","/**\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\nconst _DefaultConfiguration = { Scope:'DEFAULT', Descriptors: {} }\n\n/**\n * @typedef {{\n *   Hash?: string,\n *   Name?: string,\n *   DataType?: string,\n *   Required?: boolean,\n *   Address?: string,\n *   Description?: string,\n *   [key: string]: any,\n * }} ManifestDescriptor\n */\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n\t\t/** @type {import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.options;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\n        this.serviceType = 'Manifest';\n\n\t\t// Wire in logging\n\t\tthis.logInfo = libSimpleLog;\n\t\tthis.logError = libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tif (!('defaultValues' in this.options))\n\t\t{\n\t\t\tthis.options.defaultValues = (\n\t\t\t\t{\n\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\"PreciseNumber\": \"0.0\",\n\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\"Null\": null\n\t\t\t\t});\n\t\t}\n\t\tif (!('strict' in this.options))\n\t\t{\n\t\t\tthis.options.strict = false;\n\t\t}\n\n\t\t/** @type {string} */\n\t\tthis.scope = undefined;\n\t\t/** @type {Array<string>} */\n\t\tthis.elementAddresses = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.elementHashes = undefined;\n\t\t/** @type {Record<string, ManifestDescriptor>} */\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(this.options) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(this.options);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\n\t\tthis.numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.fable, tmpNewOptions, this.Hash);\n\t\ttmpNewManyfest.logInfo = this.logInfo;\n\t\ttmpNewManyfest.logError = this.logError;\n\t\t//FIXME: mostly written by co-pilot\n\t\tconst { Scope, Descriptors, HashTranslations } = this.getManifest();\n\t\ttmpNewManyfest.scope = Scope;\n\t\ttmpNewManyfest.elementDescriptors = Descriptors;\n\t\ttmpNewManyfest.elementAddresses = Object.keys(Descriptors);\n\t\t// Rebuild the element hashes\n\t\tfor (let i = 0; i < tmpNewManyfest.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpAddress = tmpNewManyfest.elementAddresses[i];\n\t\t\tlet tmpDescriptor = tmpNewManyfest.elementDescriptors[tmpAddress];\n\t\t\ttmpNewManyfest.elementHashes[tmpAddress] = tmpAddress;\n\t\t\tif ('Hash' in tmpDescriptor)\n\t\t\t{\n\t\t\t\ttmpNewManyfest.elementHashes[tmpDescriptor.Hash] = tmpAddress;\n\t\t\t}\n\t\t}\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\t/**\n\t * @param {string} pManifestString - The manifest string to deserialize\n\t *\n\t * @return {Manyfest} The deserialized manifest\n\t */\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\tthis.loadManifest(JSON.parse(pManifestString));\n\t\treturn this;\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t}\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : {};\n\n\t\tlet tmpDescriptorKeys = Object.keys(_DefaultConfiguration);\n\n\t\tfor (let i = 0; i < tmpDescriptorKeys.length; i++)\n\t\t{\n\t\t\tif (!(tmpDescriptorKeys[i] in tmpManifest))\n\t\t\t{\n\t\t\t\ttmpManifest[tmpDescriptorKeys[i]] = JSON.parse(JSON.stringify(_DefaultConfiguration[tmpDescriptorKeys[i]]));\n\t\t\t}\n\t\t}\n\n\t\tif ('Scope' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = tmpManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(tmpManifest.Scope)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, tmpManifest);\n\t\t}\n\n\t\tif ('Descriptors' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(tmpManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], tmpManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(tmpManifest.Descriptors)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, tmpManifest);\n\t\t}\n\n\t\tif ('HashTranslations' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.HashTranslations) === 'object')\n\t\t\t{\n\t\t\t\t// HashTranslations is serialized as a plain object of source:target pairs\n\t\t\t\tthis.hashTranslations.addTranslation(tmpManifest.HashTranslations);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Serialize the Manifest to a string\n\t *\n\t * @return {string} - The serialized manifest\n\t */\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\t/**\n\t * @return {{ Scope: string, Descriptors: Record<string, ManifestDescriptor>, HashTranslations: Record<string, string> }} - A copy of the manifest state.\n\t */\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors)),\n\t\t\t\tHashTranslations: JSON.parse(JSON.stringify(this.hashTranslations.translationTable))\n\t\t\t});\n\t}\n\n\t/**\n\t * Add a descriptor to the manifest\n\t *\n\t * @param {string} pAddress - The address of the element to add the descriptor for.\n\t * @param {ManifestDescriptor} pDescriptor - The descriptor object to add.\n\t */\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!('Address' in pDescriptor))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!(pAddress in this.elementDescriptors))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif ('Hash' in pDescriptor)\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} pHash - The hash of the address to resolve.\n\t *\n\t * @return {ManifestDescriptor} The descriptor for the address\n\t */\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\t/**\n\t * @param {string} pAddress - The address of the element to get the descriptor for.\n\t *\n\t * @return {ManifestDescriptor} The descriptor for the address\n\t */\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/**\n\t * execute an action function for each descriptor\n\t * @param {(d: ManifestDescriptor) => void} fAction - The action function to execute for each descriptor.\n\t */\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = (pHash in this.elementHashes);\n\t\tlet tmpInTranslationTable = (pHash in this.hashTranslations.translationTable);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && (this.hashTranslations.translate(pHash) in this.elementHashes))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\tlintAddress(pAddress)\n\t{\n\t\t// Guard against non-string input\n\t\tif (typeof(pAddress) != 'string')\n\t\t{\n\t\t\treturn '';\n\t\t}\n\t\tlet tmpLintedAddress = pAddress.trim();\n\t\t// Check for a single trailing . (but not a ..) at the end of the address and remove it.\n\t\t// We must not strip '..' because that is back-navigation syntax.\n\t\tif (tmpLintedAddress.endsWith('.') && !tmpLintedAddress.endsWith('..'))\n\t\t{\n\t\t\ttmpLintedAddress = tmpLintedAddress.slice(0, -1);\n\t\t}\n\n\t\treturn tmpLintedAddress;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\tif (tmpLintedAddress == '')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error getting value at address; address is an empty string.`, pObject);\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, tmpLintedAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(tmpLintedAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, tmpLintedAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = this.lintAddress(pAddress);\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, tmpLintedAddress);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"precisenumber\":\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!this.numberRegex.test(tmpValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not a valid number`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tif (tmpElementType != 'boolean')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'datetime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t/**\n\t * Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\t *\n\t * @param {ManifestDescriptor} pDescriptor - The descriptor definition.\n\t */\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ('Default' in pDescriptor)\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = ('DataType' in pDescriptor) ? pDescriptor.DataType : 'String';\n\t\t\tif (tmpDataType in this.options.defaultValues)\n\t\t\t{\n\t\t\t\tlet tmpDefaultValue = this.options.defaultValues[tmpDataType];\n\t\t\t\t// Return a copy of mutable defaults (Array and Object) to prevent shared state\n\t\t\t\tif (typeof(tmpDefaultValue) == 'object' && tmpDefaultValue !== null)\n\t\t\t\t{\n\t\t\t\t\treturn JSON.parse(JSON.stringify(tmpDefaultValue));\n\t\t\t\t}\n\t\t\t\treturn tmpDefaultValue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn ('Default' in pDescriptor);\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;\n","'use strict';\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n","'use strict';\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n","'use strict';\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n","'use strict';\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n","'use strict';\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n","'use strict';\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n","'use strict';\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n","'use strict';\n\nvar $isNaN = require('./isNaN');\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n","var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = require('./util.inspect');\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nvar quotes = {\n    __proto__: null,\n    'double': '\"',\n    single: \"'\"\n};\nvar quoteREs = {\n    __proto__: null,\n    'double': /([\"\\\\])/g,\n    single: /(['\\\\])/g\n};\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (\n        (typeof globalThis !== 'undefined' && obj === globalThis)\n        || (typeof global !== 'undefined' && obj === global)\n    ) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var style = opts.quoteStyle || defaultStyle;\n    var quoteChar = quotes[style];\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction canTrustToString(obj) {\n    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));\n}\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    var quoteRE = quoteREs[opts.quoteStyle || 'single'];\n    quoteRE.lastIndex = 0;\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, quoteRE, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n* @author      Steven Velozo <steven@velozo.com>\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tAsynchronous: false,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: {},\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchEnd: false\n\t\t});\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\tresetOutputBuffer (pParserState)\n\t{\n\t\t// Flush the output buffer.\n\t\tthis.flushOutputBuffer(pParserState);\n\t\t// End pattern mode\n\t\tpParserState.Pattern = false;\n\t\tpParserState.PatternStartNode = false;\n\t\tpParserState.StartPatternMatchComplete = false;\n\t\tpParserState.EndPatternMatchBegan = false;\n\t\tpParserState.PatternMatch = false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && pParserState.Pattern.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif (pParserState.Pattern.hasOwnProperty('Parse'))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the function\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData);\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pParserState.PatternStartNode.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pParserState.Pattern.hasOwnProperty('PatternEnd'))\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter))\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif (pParserState.Pattern.hasOwnProperty('Parse'))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the t*mplate function\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData);\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\tif (!pParserState.PatternMatch)\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t */\n\tparseString (pString, pParseTree, pData)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData);\n\t\t}\n\n\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n* @author      Steven Velozo <steven@velozo.com>\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern))\n\t\t{\n\t\t\tpTree[pPattern] = {};\n\t\t}\n\n\t\treturn pTree[pPattern];\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree PatternEnd subtree\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddEndChild (pTree, pPattern)\n\t{\n\t\tif (!pTree.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\tpTree.PatternEnd = {};\n\t\t}\n\n\t\tpTree.PatternEnd[pPattern] = {};\n\n\t\treturn pTree.PatternEnd[pPattern];\n\t}\n\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, fParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart[i], i);\n\t\t}\n\n\t\tif (!tmpLeaf.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\ttmpLeaf.PatternEnd = {};\n\t\t}\n\n\t\tlet tmpPatternEnd = (typeof(pPatternEnd) === 'string') ? pPatternEnd : pPatternStart;\n\t\tfor (let i = 0; i < tmpPatternEnd.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addEndChild(tmpLeaf, tmpPatternEnd[i], i);\n\t\t}\n\n\t\ttmpLeaf.PatternStartString = pPatternStart;\n\t\ttmpLeaf.PatternEndString = tmpPatternEnd;\n\t\ttmpLeaf.Parse = (typeof(fParser) === 'function') ? fParser :\n\t\t\t\t\t\t(typeof(fParser) === 'string') ? () => { return fParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = {\n    'default': Format.RFC3986,\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return String(value);\n        }\n    },\n    RFC1738: Format.RFC1738,\n    RFC3986: Format.RFC3986\n};\n","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowEmptyArrays: false,\n    allowPrototypes: false,\n    allowSparse: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decodeDotInKeys: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    duplicates: 'combine',\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictDepth: false,\n    strictMerge: true,\n    strictNullHandling: false,\n    throwOnLimitExceeded: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\nvar parseArrayValue = function (val, options, currentArrayLength) {\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n        return val.split(',');\n    }\n\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n\n    return val;\n};\n\n// This is what browsers will submit when the  character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the  character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = { __proto__: null };\n\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n\n    var limit = options.parameterLimit === Infinity ? void undefined : options.parameterLimit;\n    var parts = cleanStr.split(\n        options.delimiter,\n        options.throwOnLimitExceeded ? limit + 1 : limit\n    );\n\n    if (options.throwOnLimitExceeded && parts.length > limit) {\n        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');\n    }\n\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key;\n        var val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n\n            if (key !== null) {\n                val = utils.maybeMap(\n                    parseArrayValue(\n                        part.slice(pos + 1),\n                        options,\n                        isArray(obj[key]) ? obj[key].length : 0\n                    ),\n                    function (encodedVal) {\n                        return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n                    }\n                );\n            }\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(String(val));\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        if (options.comma && isArray(val) && val.length > options.arrayLimit) {\n            if (options.throwOnLimitExceeded) {\n                throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n            }\n            val = utils.combine([], val, options.arrayLimit, options.plainObjects);\n        }\n\n        if (key !== null) {\n            var existing = has.call(obj, key);\n            if (existing && (options.duplicates === 'combine' || part.indexOf('[]=') > -1)) {\n                obj[key] = utils.combine(\n                    obj[key],\n                    val,\n                    options.arrayLimit,\n                    options.plainObjects\n                );\n            } else if (!existing || options.duplicates === 'last') {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options, valuesParsed) {\n    var currentArrayLength = 0;\n    if (chain.length > 0 && chain[chain.length - 1] === '[]') {\n        var parentKey = chain.slice(0, -1).join('');\n        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;\n    }\n\n    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            if (utils.isOverflow(leaf)) {\n                // leaf is already an overflow object, preserve it\n                obj = leaf;\n            } else {\n                obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n                    ? []\n                    : utils.combine(\n                        [],\n                        leaf,\n                        options.arrayLimit,\n                        options.plainObjects\n                    );\n            }\n        } else {\n            obj = options.plainObjects ? { __proto__: null } : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;\n            var index = parseInt(decodedRoot, 10);\n            var isValidArrayIndex = !isNaN(index)\n                && root !== decodedRoot\n                && String(index) === decodedRoot\n                && index >= 0\n                && options.parseArrays;\n            if (!options.parseArrays && decodedRoot === '') {\n                obj = { 0: leaf };\n            } else if (isValidArrayIndex && index < options.arrayLimit) {\n                obj = [];\n                obj[index] = leaf;\n            } else if (isValidArrayIndex && options.throwOnLimitExceeded) {\n                throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n            } else if (isValidArrayIndex) {\n                obj[index] = leaf;\n                utils.markOverflow(obj, index);\n            } else if (decodedRoot !== '__proto__') {\n                obj[decodedRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar splitKeyIntoSegments = function splitKeyIntoSegments(givenKey, options) {\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    if (options.depth <= 0) {\n        if (!options.plainObjects && has.call(Object.prototype, key)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        return [key];\n    }\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    var keys = [];\n\n    if (parent) {\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys[keys.length] = parent;\n    }\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n\n        var segmentContent = segment[1].slice(1, -1);\n        if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys[keys.length] = segment[1];\n    }\n\n    if (segment) {\n        if (options.strictDepth === true) {\n            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');\n        }\n\n        keys[keys.length] = '[' + key.slice(segment.index) + ']';\n    }\n\n    return keys;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n    if (!givenKey) {\n        return;\n    }\n\n    var keys = splitKeyIntoSegments(givenKey, options);\n\n    if (!keys) {\n        return;\n    }\n\n    return parseObject(keys, val, options, valuesParsed);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {\n        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {\n        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');\n    }\n\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;\n\n    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {\n        throw new TypeError('The duplicates option must be either combine, first, or last');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        duplicates: duplicates,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,\n        strictMerge: typeof opts.strictMerge === 'boolean' ? !!opts.strictMerge : defaults.strictMerge,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? { __proto__: null } : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? { __proto__: null } : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    if (options.allowSparse === true) {\n        return obj;\n    }\n\n    return utils.compact(obj);\n};\n","'use strict';\n\nvar getSideChannel = require('side-channel');\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    commaRoundTrip: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    filter: void undefined,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar sentinel = {};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    commaRoundTrip,\n    allowEmptyArrays,\n    strictNullHandling,\n    skipNulls,\n    encodeDotInKeys,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    format,\n    formatter,\n    encodeValuesOnly,\n    charset,\n    sideChannel\n) {\n    var obj = object;\n\n    var tmpSc = sideChannel;\n    var step = 0;\n    var findFlag = false;\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n        // Where object last appeared in the ref tree\n        var pos = tmpSc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            } else {\n                findFlag = true; // Break while\n            }\n        }\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = utils.maybeMap(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            return value;\n        });\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            obj = utils.maybeMap(obj, encoder);\n        }\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    } else if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;\n\n    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {\n        return adjustedPrefix + '[]';\n    }\n\n    for (var j = 0; j < objKeys.length; ++j) {\n        var key = objKeys[j];\n        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'\n            ? key.value\n            : obj[key];\n\n        if (skipNulls && value === null) {\n            continue;\n        }\n\n        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\\./g, '%2E') : String(key);\n        var keyPrefix = isArray(obj)\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix\n            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');\n\n        sideChannel.set(object, step);\n        var valueSideChannel = getSideChannel();\n        valueSideChannel.set(sentinel, sideChannel);\n        pushToArray(values, stringify(\n            value,\n            keyPrefix,\n            generateArrayPrefix,\n            commaRoundTrip,\n            allowEmptyArrays,\n            strictNullHandling,\n            skipNulls,\n            encodeDotInKeys,\n            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            format,\n            formatter,\n            encodeValuesOnly,\n            charset,\n            valueSideChannel\n        ));\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    var arrayFormat;\n    if (opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = defaults.arrayFormat;\n    }\n\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];\n    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    var sideChannel = getSideChannel();\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n        var value = obj[key];\n\n        if (options.skipNulls && value === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            value,\n            key,\n            generateArrayPrefix,\n            commaRoundTrip,\n            options.allowEmptyArrays,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encodeDotInKeys,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.format,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset,\n            sideChannel\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n","'use strict';\n\nvar formats = require('./formats');\nvar getSideChannel = require('side-channel');\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\n// Track objects created from arrayLimit overflow using side-channel\n// Stores the current max numeric index for O(1) lookup\nvar overflowChannel = getSideChannel();\n\nvar markOverflow = function markOverflow(obj, maxIndex) {\n    overflowChannel.set(obj, maxIndex);\n    return obj;\n};\n\nvar isOverflow = function isOverflow(obj) {\n    return overflowChannel.has(obj);\n};\n\nvar getMaxIndex = function getMaxIndex(obj) {\n    return overflowChannel.get(obj);\n};\n\nvar setMaxIndex = function setMaxIndex(obj, maxIndex) {\n    overflowChannel.set(obj, maxIndex);\n};\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array[array.length] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted[compacted.length] = obj[j];\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? { __proto__: null } : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object' && typeof source !== 'function') {\n        if (isArray(target)) {\n            var nextIndex = target.length;\n            if (options && typeof options.arrayLimit === 'number' && nextIndex > options.arrayLimit) {\n                return markOverflow(arrayToObject(target.concat(source), options), nextIndex);\n            }\n            target[nextIndex] = source;\n        } else if (target && typeof target === 'object') {\n            if (isOverflow(target)) {\n                // Add at next numeric index for overflow objects\n                var newIndex = getMaxIndex(target) + 1;\n                target[newIndex] = source;\n                setMaxIndex(target, newIndex);\n            } else if (options && options.strictMerge) {\n                return [target, source];\n            } else if (\n                (options && (options.plainObjects || options.allowPrototypes))\n                || !has.call(Object.prototype, source)\n            ) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        if (isOverflow(source)) {\n            // Create new object with target at 0, source values shifted by 1\n            var sourceKeys = Object.keys(source);\n            var result = options && options.plainObjects\n                ? { __proto__: null, 0: target }\n                : { 0: target };\n            for (var m = 0; m < sourceKeys.length; m++) {\n                var oldKey = parseInt(sourceKeys[m], 10);\n                result[oldKey + 1] = source[sourceKeys[m]];\n            }\n            return markOverflow(result, getMaxIndex(source) + 1);\n        }\n        var combined = [target].concat(source);\n        if (options && typeof options.arrayLimit === 'number' && combined.length > options.arrayLimit) {\n            return markOverflow(arrayToObject(combined, options), combined.length - 1);\n        }\n        return combined;\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target[target.length] = item;\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n\n        if (isOverflow(source) && !isOverflow(acc)) {\n            markOverflow(acc, getMaxIndex(source));\n        }\n        if (isOverflow(acc)) {\n            var keyNum = parseInt(key, 10);\n            if (String(keyNum) === key && keyNum >= 0 && keyNum > getMaxIndex(acc)) {\n                setMaxIndex(acc, keyNum);\n            }\n        }\n\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, defaultDecoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar limit = 1024;\n\n/* eslint operator-linebreak: [2, \"before\"] */\n\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var j = 0; j < string.length; j += limit) {\n        var segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        var arr = [];\n\n        for (var i = 0; i < segment.length; ++i) {\n            var c = segment.charCodeAt(i);\n            if (\n                c === 0x2D // -\n                || c === 0x2E // .\n                || c === 0x5F // _\n                || c === 0x7E // ~\n                || (c >= 0x30 && c <= 0x39) // 0-9\n                || (c >= 0x41 && c <= 0x5A) // a-z\n                || (c >= 0x61 && c <= 0x7A) // A-Z\n                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n\n            if (c < 0x80) {\n                arr[arr.length] = hexTable[c];\n                continue;\n            }\n\n            if (c < 0x800) {\n                arr[arr.length] = hexTable[0xC0 | (c >> 6)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            if (c < 0xD800 || c >= 0xE000) {\n                arr[arr.length] = hexTable[0xE0 | (c >> 12)]\n                    + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            i += 1;\n            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));\n\n            arr[arr.length] = hexTable[0xF0 | (c >> 18)]\n                + hexTable[0x80 | ((c >> 12) & 0x3F)]\n                + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                + hexTable[0x80 | (c & 0x3F)];\n        }\n\n        out += arr.join('');\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue[queue.length] = { obj: obj, prop: key };\n                refs[refs.length] = val;\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b, arrayLimit, plainObjects) {\n    // If 'a' is already an overflow object, add to it\n    if (isOverflow(a)) {\n        var newIndex = getMaxIndex(a) + 1;\n        a[newIndex] = b;\n        setMaxIndex(a, newIndex);\n        return a;\n    }\n\n    var result = [].concat(a, b);\n    if (result.length > arrayLimit) {\n        return markOverflow(arrayToObject(result, { plainObjects: plainObjects }), result.length - 1);\n    }\n    return result;\n};\n\nvar maybeMap = function maybeMap(val, fn) {\n    if (isArray(val)) {\n        var mapped = [];\n        for (var i = 0; i < val.length; i += 1) {\n            mapped[mapped.length] = fn(val[i]);\n        }\n        return mapped;\n    }\n    return fn(val);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isOverflow: isOverflow,\n    isRegExp: isRegExp,\n    markOverflow: markOverflow,\n    maybeMap: maybeMap,\n    merge: merge\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\nvar $Map = GetIntrinsic('%Map%', true);\n\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */\nvar $mapGet = callBound('Map.prototype.get', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */\nvar $mapSet = callBound('Map.prototype.set', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapHas = callBound('Map.prototype.has', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapDelete = callBound('Map.prototype.delete', true);\n/** @type {<K, V>(thisArg: Map<K, V>) => number} */\nvar $mapSize = callBound('Map.prototype.size', true);\n\n/** @type {import('.')} */\nmodule.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {\n\t/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {Map<K, V> | undefined} */ var $m;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tif ($m) {\n\t\t\t\tvar result = $mapDelete($m, key);\n\t\t\t\tif ($mapSize($m) === 0) {\n\t\t\t\t\t$m = void undefined;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($m) {\n\t\t\t\treturn $mapGet($m, key);\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($m) {\n\t\t\t\treturn $mapHas($m, key);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$m) {\n\t\t\t\t// @ts-expect-error TS can't handle narrowing a variable inside a closure\n\t\t\t\t$m = new $Map();\n\t\t\t}\n\t\t\t$mapSet($m, key, value);\n\t\t}\n\t};\n\n\t// @ts-expect-error TODO: figure out why TS is erroring here\n\treturn channel;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\nvar getSideChannelMap = require('side-channel-map');\n\nvar $TypeError = require('es-errors/type');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapDelete = callBound('WeakMap.prototype.delete', true);\n\n/** @type {import('.')} */\nmodule.exports = $WeakMap\n\t? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {\n\t\t/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */\n\t\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t\t/** @type {WeakMap<K & object, V> | undefined} */ var $wm;\n\t\t/** @type {Channel | undefined} */ var $m;\n\n\t\t/** @type {Channel} */\n\t\tvar channel = {\n\t\t\tassert: function (key) {\n\t\t\t\tif (!channel.has(key)) {\n\t\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t\t}\n\t\t\t},\n\t\t\t'delete': function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapDelete($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $m['delete'](key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tget: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $m && $m.get(key);\n\t\t\t},\n\t\t\thas: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!$m && $m.has(key);\n\t\t\t},\n\t\t\tset: function (key, value) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif (!$wm) {\n\t\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t\t}\n\t\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif (!$m) {\n\t\t\t\t\t\t$m = getSideChannelMap();\n\t\t\t\t\t}\n\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\t/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// @ts-expect-error TODO: figure out why this is erroring\n\t\treturn channel;\n\t}\n\t: getSideChannelMap;\n","'use strict';\n\nvar $TypeError = require('es-errors/type');\nvar inspect = require('object-inspect');\nvar getSideChannelList = require('side-channel-list');\nvar getSideChannelMap = require('side-channel-map');\nvar getSideChannelWeakMap = require('side-channel-weakmap');\n\nvar makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannel() {\n\t/** @typedef {ReturnType<typeof getSideChannel>} Channel */\n\n\t/** @type {Channel | undefined} */ var $channelData;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\treturn !!$channelData && $channelData['delete'](key);\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn $channelData && $channelData.get(key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn !!$channelData && $channelData.has(key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$channelData) {\n\t\t\t\t$channelData = makeChannel();\n\t\t\t}\n\n\t\t\t$channelData.set(key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n","/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","module.exports = require('events').EventEmitter;\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n'use strict';\n\nvar punycode = require('punycode/');\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n/*\n * define these here so at least they only have to be\n * compiled once on the first module load.\n */\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/,\n\n  /*\n   * RFC 2396: characters reserved for delimiting URLs.\n   * We actually just auto-escape these.\n   */\n  delims = [\n    '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'\n  ],\n\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [\n    '{', '}', '|', '\\\\', '^', '`'\n  ].concat(delims),\n\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  /*\n   * Characters that are never ever allowed in a hostname.\n   * Note that any invalid chars are also handled, but these\n   * are the ones that are *expected* to be seen, so we fast-path\n   * them.\n   */\n  nonHostChars = [\n    '%', '/', '?', ';', '#'\n  ].concat(autoEscape),\n  hostEndingChars = [\n    '/', '?', '#'\n  ],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = require('qs');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === 'object' && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  /*\n   * Copy chrome, IE, opera backslash-handling behavior.\n   * Back slashes before the query string get converted to forward slashes\n   * See: https://code.google.com/p/chromium/issues/detail?id=25916\n   */\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  /*\n   * trim before proceeding.\n   * This is to support parse stuff like \"  http://foo.com  \\n\"\n   */\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  /*\n   * figure out if it's got a host\n   * user@server is *always* interpreted as a hostname, and url\n   * resolution will treat //foo/bar as host=foo,path=bar because that's\n   * how the browser resolves relative URLs.\n   */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\n\n    /*\n     * there's a hostname.\n     * the first instance of /, ?, ;, or # ends the host.\n     *\n     * If there is an @ in the hostname, then non-host chars *are* allowed\n     * to the left of the last @ sign, unless some host-ending character\n     * comes *before* the @-sign.\n     * URLs are obnoxious.\n     *\n     * ex:\n     * http://a@b@c/ => user:a@b host:c\n     * http://a@b?@c => user:a host:c path:/?@c\n     */\n\n    /*\n     * v0.12 TODO(isaacs): This is not quite how Chrome does things.\n     * Review our test case against browsers more comprehensively.\n     */\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n\n    /*\n     * at this point, either we have an explicit point where the\n     * auth portion cannot go past, or the last @ char is the decider.\n     */\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      /*\n       * atSign must be in auth portion.\n       * http://a@b/c@d => host:b auth:a path:/c@d\n       */\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    /*\n     * Now we have a portion which is definitely the auth.\n     * Pull that off.\n     */\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    /*\n     * we've indicated that there is a hostname,\n     * so even if it's empty, it has to be present.\n     */\n    this.hostname = this.hostname || '';\n\n    /*\n     * if hostname begins with [ and ends with ]\n     * assume that it's an IPv6 address.\n     */\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              /*\n               * we replace non-ASCII char with a temporary placeholder\n               * we need this to make sure size of hostname is not\n               * broken by replacing non-ASCII by nothing\n               */\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      /*\n       * IDNA Support: Returns a punycoded representation of \"domain\".\n       * It only converts parts of the domain name that\n       * have non-ASCII characters, i.e. it doesn't matter if\n       * you call it with a domain that already is ASCII-only.\n       */\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    /*\n     * strip [ and ] from the hostname\n     * the host field still retains them, though\n     */\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  /*\n   * now rest is set to the post-host stuff.\n   * chop off any delim chars.\n   */\n  if (!unsafeProtocol[lowerProto]) {\n\n    /*\n     * First, make 100% sure that any \"autoEscape\" chars get\n     * escaped, even if encodeURIComponent doesn't think they\n     * need to be.\n     */\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  /*\n   * ensure it's an object, and not a string url.\n   * If it's an obj, this is a no-op.\n   * this way, you can call url_format() on strings\n   * to clean up potentially wonky urls.\n   */\n  if (typeof obj === 'string') { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query, {\n      arrayFormat: 'repeat',\n      addQueryPrefix: false\n    });\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  /*\n   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   * unless they had them to begin with.\n   */\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  /*\n   * hash is always overridden, no matter what.\n   * even href=\"\" will remove it.\n   */\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.pathname = '/';\n      result.path = result.pathname;\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    /*\n     * if it's a known url protocol, then changing\n     * the protocol does weird things\n     * first, if it's not file:, then we MUST have a host,\n     * and if there was a path\n     * to begin with, then we MUST have a path.\n     * if it is file:, then the host is dropped,\n     * because that's known to be hostless.\n     * anything else is assumed to be absolute.\n     */\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())) { }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  /*\n   * if the url is a non-slashed url, then relative\n   * links like ../.. should be able\n   * to crawl up to the hostname, as well.  This is strange.\n   * result.protocol has already been set by now.\n   * Later on, put the first path part into the host field.\n   */\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    /*\n     * it's relative\n     * throw away the existing file, and take the new path instead.\n     */\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search != null) {\n    /*\n     * just pull out the search.\n     * like href='?foo'.\n     * Put this after the other two cases because it simplifies the booleans\n     */\n    if (psychotic) {\n      result.host = srcPath.shift();\n      result.hostname = result.host;\n      /*\n       * occationaly the auth can get stuck only in host\n       * this especially happens in cases like\n       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n       */\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.hostname = authInHost.shift();\n        result.host = result.hostname;\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    /*\n     * no path at all.  easy.\n     * we've already handled the other stuff above.\n     */\n    result.pathname = null;\n    // to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  /*\n   * if a url ENDs in . or .., then it must get a trailing slash.\n   * however, if it ends in anything else non-slashy,\n   * then it must NOT get a trailing slash.\n   */\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  /*\n   * strip single dots, resolve double dots to parent dir\n   * if the path tries to go above the root, `up` ends up > 0\n   */\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    result.host = result.hostname;\n    /*\n     * occationaly the auth can get stuck only in host\n     * this especially happens in cases like\n     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n     */\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.hostname = authInHost.shift();\n      result.host = result.hostname;\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (srcPath.length > 0) {\n    result.pathname = srcPath.join('/');\n  } else {\n    result.pathname = null;\n    result.path = null;\n  }\n\n  // to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","module.exports={\n  \"name\": \"fable\",\n  \"version\": \"3.1.58\",\n  \"description\": \"A service dependency injection, configuration and logging library.\",\n  \"main\": \"source/Fable.js\",\n  \"scripts\": {\n    \"start\": \"node source/Fable.js\",\n    \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n    \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n    \"build\": \"npx quack build\",\n    \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t fable-image:local\",\n    \"docker-dev-run\": \"docker run -it -d --name fable-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/fable\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" fable-image:local\",\n    \"docker-dev-shell\": \"docker exec -it fable-dev /bin/bash\",\n    \"tests\": \"./node_modules/mocha/bin/_mocha -u tdd --exit -R spec --grep\"\n  },\n  \"mocha\": {\n    \"diff\": true,\n    \"extension\": [\n      \"js\"\n    ],\n    \"package\": \"./package.json\",\n    \"reporter\": \"spec\",\n    \"slow\": \"75\",\n    \"timeout\": \"5000\",\n    \"ui\": \"tdd\",\n    \"watch-files\": [\n      \"source/**/*.js\",\n      \"test/**/*.js\"\n    ],\n    \"watch-ignore\": [\n      \"lib/vendor\"\n    ]\n  },\n  \"browser\": {\n    \"./source/service/Fable-Service-EnvironmentData.js\": \"./source/service/Fable-Service-EnvironmentData-Web.js\",\n    \"./source/service/Fable-Service-FilePersistence.js\": \"./source/service/Fable-Service-FilePersistence-Web.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/stevenvelozo/fable.git\"\n  },\n  \"keywords\": [\n    \"entity\",\n    \"behavior\"\n  ],\n  \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stevenvelozo/fable/issues\"\n  },\n  \"homepage\": \"https://github.com/stevenvelozo/fable\",\n  \"devDependencies\": {\n    \"quackage\": \"^1.0.51\"\n  },\n  \"dependencies\": {\n    \"async.eachlimit\": \"^0.5.2\",\n    \"async.waterfall\": \"^0.5.2\",\n    \"big.js\": \"^7.0.1\",\n    \"cachetrax\": \"^1.0.5\",\n    \"cookie\": \"^1.1.1\",\n    \"data-arithmatic\": \"^1.0.7\",\n    \"dayjs\": \"^1.11.19\",\n    \"fable-log\": \"^3.0.17\",\n    \"fable-serviceproviderbase\": \"^3.0.18\",\n    \"fable-settings\": \"^3.0.15\",\n    \"fable-uuid\": \"^3.0.12\",\n    \"manyfest\": \"^1.0.46\",\n    \"simple-get\": \"^4.0.1\"\n  }\n}\n","/**\n* Fable Application Services Support Library\n* @author <steven@velozo.com>\n*/\n// Pre-init services\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libPackage = require('../package.json');\n\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nclass Fable extends libFableServiceBase.CoreServiceProviderBase\n{\n\tconstructor(pSettings)\n\t{\n\t\tsuper(pSettings);\n\n\t\t// Initialization Phase 0: Set up the lowest level state (fable is a utility service manager at heart)\n\t\tthis.serviceType = 'ServiceManager';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\n\t\t// An array of the types of services available\n\t\tthis.serviceTypes = [];\n\t\t// A map of instantiated services\n\t\tthis.servicesMap = {};\n\t\t// A map of the default instantiated service by type\n\t\tthis.services = {};\n\n\t\t// A map of class constructors for services\n\t\tthis.serviceClasses = {};\n\n\t\t// If we need extra service initialization capabilities\n\t\tthis.extraServiceInitialization = false;\n\n\t\t// Set how noisy the system is about signaling complexity\n\t\tthis.LogNoisiness = 0;\n\n\t\t// Initialization Phase 1: Set up the core utility services\n\t\t// These are things like power, water, and sewage.  They are required for fable to run (e.g. logging, settings, etc)\n\n\t\t// Instantiate the default Settings Manager\n\t\tthis.SettingsManager = new libFableSettings(pSettings);\n\t\tthis.SettingsManager = this.SettingsManager;\n\t\t// Instantiate the UUID generator\n\t\tthis.UUID = new libFableUUID(this.SettingsManager.settings);\n\t\t// Instantiate the logging system\n\t\tthis.Logging = new libFableLog(this.SettingsManager.settings);\n\t\tthis.Logging.initialize();\n\n\t\t// Initialization Phase 1.5: Instantiate the service manager\n\t\t// This is the start actual bootstrapping point for fable.\n\t\t// For consistency fable is treated as a service.\n\t\tthis.ServiceManager = this;\n\t\t// TODO: Remove this when Orator and meadow-endpoints are shifted to this new pattern\n\t\tthis.serviceManager = this;\n\t\t// END TODO\n\t\tthis.connectFable(this);\n\t\t// --> Bootstrapping of fable into the Service Manager is complete\n\n\t\t// Initialization Phase 2: Map in the default services.\n\t\t// They will then be available in the Default service provider set as well.\n\t\tthis.connectPreinitServiceProviderInstance(this.UUID);\n\t\tthis.connectPreinitServiceProviderInstance(this.Logging);\n\t\tthis.connectPreinitServiceProviderInstance(this.SettingsManager);\n\n\t\t// Initialize and instantiate the default baked-in Data Arithmatic service\n\t\tthis.addAndInstantiateServiceType('EnvironmentData', require('./services/Fable-Service-EnvironmentData.js'));\n\t\tthis.addServiceType('Template', require('./services/Fable-Service-Template.js'));\n\t\tthis.addServiceType('MetaTemplate', require('./services/Fable-Service-MetaTemplate.js'));\n\t\tthis.addServiceType('Anticipate', require('./services/Fable-Service-Anticipate.js'));\n\t\tthis.addAndInstantiateServiceType('Dates', require('./services/Fable-Service-DateManipulation.js'));\n\t\tthis.addAndInstantiateServiceType('DataFormat', require('./services/Fable-Service-DataFormat.js'));\n\t\tthis.addAndInstantiateServiceType('DataGeneration', require('./services/Fable-Service-DataGeneration.js'));\n\t\tthis.addAndInstantiateServiceType('Utility', require('./services/Fable-Service-Utility.js'));\n\t\tthis.addAndInstantiateServiceType('Logic', require('./services/Fable-Service-Logic.js'));\n\t\tthis.addAndInstantiateServiceType('Math', require('./services/Fable-Service-Math.js'));\n\t\tthis.addServiceType('ExpressionParser', require('./services/Fable-Service-ExpressionParser.js'));\n\t\tthis.addServiceType('RestClient', require('./services/Fable-Service-RestClient.js'));\n\t\tthis.addServiceType('Manifest', require('manyfest'));\n\t\tthis.addServiceType('ObjectCache', require('cachetrax'));\n\t\tthis.addAndInstantiateServiceType('ProgressTime', require('./services/Fable-Service-ProgressTime.js'));\n\t\tthis.addServiceType('ProgressTrackerSet', require('./services/Fable-Service-ProgressTrackerSet.js'));\n\t\tthis.addServiceType('Operation', require('./services/Fable-Service-Operation.js'));\n\t\tthis.addServiceType('CSVParser', require('./services/Fable-Service-CSVParser.js'));\n\t\tthis.addServiceType('FilePersistence', require('./services/Fable-Service-FilePersistence.js'));\n\t}\n\n\t/* State Accessors */\n\tget isFable()\n\t{\n\t\treturn true;\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.SettingsManager.settings;\n\t}\n\n\tget settingsManager()\n\t{\n\t\treturn this.SettingsManager;\n\t}\n\n\t// For backwards compatibility\n\tgetUUID()\n\t{\n\t\treturn this.UUID.getUUID();\n\t}\n\n\tnewAnticipate()\n\t{\n\t\treturn this.instantiateServiceProviderWithoutRegistration('Anticipate');\n\t}\n\n\tnewManyfest(pManifestDefinition)\n\t{\n\t\treturn this.instantiateServiceProviderWithoutRegistration('Manifest', pManifestDefinition);\n\t}\n\n\t/* Service Manager Methods */\n\taddServiceType(pServiceType, pServiceClass)\n\t{\n\t\tif (pServiceType in this.servicesMap)\n\t\t{\n\t\t\t//this.log.warn(`Adding a service type [${pServiceType}] that already exists.  This will change the default class prototype for this service.`);\n\t\t\t// This broke command-line utilities that overrode services and wanted to strictly control log output\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the container for instantiated services to go in\n\t\t\tthis.servicesMap[pServiceType] = {};\n\n\t\t\t// Add the type to the list of types\n\t\t\tthis.serviceTypes.push(pServiceType);\n\t\t}\n\n\t\t// Using the static member of the class is a much more reliable way to check if it is a service class than instanceof\n\t\tif ((typeof(pServiceClass) == 'function') && (pServiceClass.isFableService))\n\t\t{\n\t\t\t// Add the class to the list of classes\n\t\t\tthis.serviceClasses[pServiceType] = pServiceClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Add the base class to the list of classes\n\t\t\tthis.log.error(`Attempted to add service type [${pServiceType}] with an invalid class.  Using base service class, which will not crash but won't provide meaningful services.`);\n\t\t\tthis.serviceClasses[pServiceType] = libFableServiceBase;\n\t\t}\n\n\t\treturn this.serviceClasses[pServiceType];\n\t}\n\n\taddServiceTypeIfNotExists(pServiceType, pServiceClass)\n\t{\n\t\tif (!(pServiceType in this.servicesMap))\n\t\t{\n\t\t\treturn this.addServiceType(pServiceType, pServiceClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.serviceClasses[pServiceType];\n\t\t}\n\t}\n\n\t// This is for the services that are meant to run mostly single-instance so need a default at initialization\n\taddAndInstantiateServiceType(pServiceType, pServiceClass)\n\t{\n\t\tthis.addServiceType(pServiceType, pServiceClass);\n\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t}\n\n\taddAndInstantiateServiceTypeIfNotExists(pServiceType, pServiceClass)\n\t{\n\t\tthis.addServiceTypeIfNotExists(pServiceType, pServiceClass);\n\n\t\tif ((!(pServiceType in this.servicesMap)) || (!(pServiceType in this.fable)))\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this[pServiceType];\n\t\t}\n\t}\n\n\taddAndInstantiateSingletonService(pServiceType, pOptions, pServiceClass)\n\t{\n\t\tthis.addServiceTypeIfNotExists(pServiceType, pServiceClass);\n\n\t\tif ((!(pServiceType in this.servicesMap)) || (!(pServiceType in this.fable)))\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, {}, `${pServiceType}-Default`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this[pServiceType];\n\t\t}\n\t}\n\n\t// Some services expect to be overloaded / customized class.\n\tinstantiateServiceProviderFromPrototype(pServiceType, pOptions, pCustomServiceHash, pServicePrototype)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new pServicePrototype(this, pOptions, pCustomServiceHash);\n\n\t\tif (this.extraServiceInitialization)\n\t\t{\n\t\t\ttmpService = this.extraServiceInitialization(tmpService);\n\t\t}\n\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(pServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(pServiceType, tmpService.Hash)\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\tinstantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = this.instantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash);\n\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[pServiceType][tmpService.Hash] = tmpService;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(pServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(pServiceType, tmpService.Hash)\n\t\t}\n\n\t\treturn tmpService;\n\t}\n\n\tinstantiateServiceProviderIfNotExists(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\tif (pServiceType in this.services)\n\t\t{\n\t\t\treturn this.services[pServiceType];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.instantiateServiceProvider(pServiceType, pOptions, pCustomServiceHash);\n\t\t}\n\t}\n\n\t// Create a service provider but don't register it to live forever in fable.services\n\tinstantiateServiceProviderWithoutRegistration(pServiceType, pOptions, pCustomServiceHash)\n\t{\n\t\t// Instantiate the service\n\t\tlet tmpService = new this.serviceClasses[pServiceType](this, pOptions, pCustomServiceHash);\n\t\tif (this.extraServiceInitialization)\n\t\t{\n\t\t\ttmpService = this.extraServiceInitialization(tmpService);\n\t\t}\n\t\treturn tmpService;\n\t}\n\n\t// Connect an initialized service provider that came before Fable was initialized\n\tconnectPreinitServiceProviderInstance(pServiceInstance)\n\t{\n\t\tlet tmpServiceType = pServiceInstance.serviceType;\n\t\tlet tmpServiceHash = pServiceInstance.Hash;\n\n\t\t// The service should already be instantiated, so just connect it to fable\n\t\tpServiceInstance.connectFable(this);\n\n\t\t// Add the service type to the map if it isn't there yet\n\t\tif (!(tmpServiceType in this.servicesMap))\n\t\t{\n\t\t\t// If the core service hasn't registered itself yet, create the service container for it.\n\t\t\t// This means you couldn't register another with this type unless it was later registered with a constructor class.\n\t\t\tthis.servicesMap[tmpServiceType] = {};\n\t\t}\n\t\t// Add the service to the service map\n\t\tthis.servicesMap[tmpServiceType][tmpServiceHash] = pServiceInstance;\n\n\t\t// If this is the first service of this type, make it the default\n\t\tif (!(tmpServiceType in this.services))\n\t\t{\n\t\t\tthis.setDefaultServiceInstantiation(tmpServiceType, tmpServiceHash, false);\n\t\t}\n\n\t\treturn pServiceInstance;\n\t}\n\n\tsetDefaultServiceInstantiation(pServiceType, pServiceHash, pOverwriteService)\n\t{\n\t\t// Overwrite services by default, unless told not to\n\t\tlet tmpOverwriteService = (typeof(pOverwriteService) === 'undefined') ? true : pOverwriteService;\n\t\t// Make sure the service exists\n\t\tif (pServiceHash in this.servicesMap[pServiceType])\n\t\t{\n\t\t\tif (!(pServiceType in this) || tmpOverwriteService)\n\t\t\t{\n\t\t\t\tthis[pServiceType] = this.servicesMap[pServiceType][pServiceHash];\n\t\t\t}\n\t\t\tif (!(pServiceType in this.services) || tmpOverwriteService)\n\t\t\t{\n\t\t\t\tthis.services[pServiceType] = this.servicesMap[pServiceType][pServiceHash];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate a safe string to use in filenames for a date.  Useful for log file uniqueness and temporary outputs.\n\t *\n\t * @static\n\t * @param {Date} pDate - An optional javascript Date object to generate a datestamp for.\n\t * @returns {string} - A string formatted as YYYY-MM-DD-HH-MM-SS\n\t */\n\tstatic generateFileNameDateStamp(pDate)\n\t{\n\t\tconst tmpDate = pDate || new Date();\n\t\tconst tmpYear = tmpDate.getFullYear();\n\t\tconst tmpMonth = String(tmpDate.getMonth() + 1).padStart(2, '0');\n\t\tconst tmpDay = String(tmpDate.getDate()).padStart(2, '0');\n\t\tconst tmpHour = String(tmpDate.getHours()).padStart(2, '0');\n\t\tconst tmpMinute = String(tmpDate.getMinutes()).padStart(2, '0');\n\t\tconst tmpSecond = String(tmpDate.getSeconds()).padStart(2, '0');\n\t\treturn `${tmpYear}-${tmpMonth}-${tmpDay}-${tmpHour}-${tmpMinute}-${tmpSecond}`;\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\nmodule.exports.ServiceProviderBase = libFableServiceBase;\nmodule.exports.CoreServiceProviderBase = libFableServiceBase.CoreServiceProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceAnticipate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'AsyncAnticipate';\n\n\t\t// The queue of operations waiting to run.\n\t\tthis.operationQueue = [];\n\t\tthis.erroredOperations = [];\n\n\t\tthis.executingOperationCount = 0;\n\t\tthis.completedOperationCount = 0;\n\n\t\tthis.callDepth = 0;\n\n\t\tthis.maxOperations = 1;\n\n\t\tthis.lastError = undefined;\n\t\tthis.waitingFunctions = [];\n\t}\n\n\tcheckQueue()\n\t{\n\t\t// This could be combined with the last else if stanza but the logic for errors and non-errors would be blended and more complex to follow so keeping it unrolled.\n\t\tif (this.lastError)\n\t\t{\n\t\t\t// If there are no operations left, and we have waiting functions, call them.\n\t\t\tfor (let i = 0; i < this.waitingFunctions.length; i++)\n\t\t\t{\n\t\t\t\t//this.log.trace('Calling waiting function.')\n\t\t\t\tthis.waitingFunctions[i](this.lastError);\n\t\t\t}\n\t\t\t// Reset our state\n\t\t\tthis.lastError = undefined;\n\t\t\tthis.waitingFunctions = [];\n\t\t}\n\t\t// This checks to see if we need to start any operations.\n\t\telse if (this.operationQueue.length > 0 && this.executingOperationCount < this.maxOperations)\n\t\t{\n\t\t\tlet tmpOperation = this.operationQueue.shift();\n\t\t\tthis.executingOperationCount += 1;\n\t\t\ttmpOperation(this.buildAnticipatorCallback());\n\t\t}\n\t\telse if (this.waitingFunctions.length > 0 && this.executingOperationCount < 1)\n\t\t{\n\t\t\t// If there are no operations left, and we have waiting functions, call them.\n\t\t\tfor (let i = 0; i < this.waitingFunctions.length; i++)\n\t\t\t{\n\t\t\t\t//this.log.trace('Calling waiting function.')\n\t\t\t\tthis.waitingFunctions[i](this.lastError);\n\t\t\t}\n\t\t\t// Reset our state\n\t\t\tthis.lastError = undefined;\n\t\t\tthis.waitingFunctions = [];\n\t\t}\n\t}\n\n\t// Expects a function fAsynchronousFunction(fCallback)\n\tanticipate(fAsynchronousFunction)\n\t{\n\t\t//this.log.trace('Adding a function...')\n\t\tthis.operationQueue.push(fAsynchronousFunction);\n\t\tthis.checkQueue();\n\t}\n\n\tbuildAnticipatorCallback()\n\t{\n\t\t// This uses closure-scoped state to track the callback state\n\t\tlet tmpCallbackState = (\n\t\t\t{\n\t\t\t\tCalled: false,\n\t\t\t\tError: undefined,\n\t\t\t\tOperationSet: this\n\t\t\t});\n\t\treturn hoistedCallback.bind(this);\n\t\tfunction hoistedCallback(pError)\n\t\t{\n\t\t\tif (tmpCallbackState.Called)\n\t\t\t{\n\t\t\t\t// If they call the callback twice, throw an error\n\t\t\t\tthrow new Error(\"Anticipation async callback called twice...\");\n\t\t\t}\n\t\t\ttmpCallbackState.Called = true;\n\t\t\tthis.lastError = pError;\n\n\t\t\ttmpCallbackState.OperationSet.executingOperationCount -= 1;\n\t\t\ttmpCallbackState.OperationSet.completedOperationCount += 1;\n\n\t\t\ttmpCallbackState.OperationSet.callDepth++;\n\n\t\t\t// TODO: Figure out a better pattern for chaining templates so the call stack doesn't get abused.\n\t\t\tif (tmpCallbackState.OperationSet.callDepth > 400)\n\t\t\t{\n\t\t\t\ttmpCallbackState.OperationSet.callDepth = 0;\n\t\t\t\tsetTimeout(tmpCallbackState.OperationSet.checkQueue.bind(this), 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpCallbackState.OperationSet.checkQueue();\n\t\t\t}\n\t\t}\n\t}\n\n\twait(fCallback)\n\t{\n\t\tthis.waitingFunctions.push(fCallback);\n\t\tthis.checkQueue();\n\t}\n}\n\nmodule.exports = FableServiceAnticipate;","const libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Parsing CSVs.  Why?  Because it's a thing that needs to be done.\n*\n* 1. And the other node CSV parsers had issues with the really messy files we had.\n*\n*\n* 2. None of the CSV parsers dealt with and multi-line quoted string columns\n*\twhich are apparently a-ok according to the official spec.\n* Plus a lot of them are asynchronous because apparently that's the best way to\n* do anything; unfortunately some files have a sequence issue with that.\n*\n* @class CSVParser\n*/\nclass CSVParser extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'CSVParser';\n\n\t\tthis.Header = [];\n\t\tthis.HeaderFieldNames = [];\n\n\t\tthis.Delimiter = ',';\n\t\tthis.QuoteCharacter = '\"';\n\n\t\tthis.CleanCharacters = ['\\r'];\n\n\t\tthis.HeaderLineIndex = 0;\n\t\tthis.HasHeader = true;\n\t\tthis.HasSetHeader = false;\n\t\tthis.EmitHeader = false;\n\n\t\tthis.EmitJSON = true;\n\n\t\tthis.EscapedQuoteString = '&quot;';\n\n\t\t// Current Line Parsing State\n\t\tthis.CurrentLine = '';\n\t\tthis.CurrentRecord = [];\n\n\t\tthis.InQuote = false;\n\t\tthis.InEscapedQuote = false;\n\n\t\tthis.LinesParsed = 0;\n\t\tthis.RowsEmitted = 0;\n\t}\n\n\tmarshalRowToJSON(pRowArray)\n\t{\n\t\tif (!Array.isArray(pRowArray))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = this.HeaderFieldNames.length; i < pRowArray.length; i++)\n\t\t{\n\t\t\tthis.HeaderFieldNames[i] = `${i}`;\n\t\t}\n\n\t\tlet tmpObject = {};\n\n\t\tfor (let i = 0; i < pRowArray.length; i++)\n\t\t{\n\t\t\ttmpObject[this.HeaderFieldNames[i]] = pRowArray[i];\n\t\t}\n\n\t\treturn tmpObject;\n\t}\n\n\t// Set the header data, for use in marshalling to JSON.\n\tsetHeader (pHeaderArray)\n\t{\n\t\tthis.Header = pHeaderArray;\n\n\t\tfor (let i = 0; i < this.Header.length; i++)\n\t\t{\n\t\t\tif (typeof(this.Header[i]) == 'undefined')\n\t\t\t{\n\t\t\t\tthis.HeaderFieldNames[i] = `${i}`;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.HeaderFieldNames[i] = this.Header[i].toString().trim();\n\t\t\t}\n\t\t}\n\t}\n\n\tresetRowState()\n\t{\n\t\tthis.CurrentRecord = [];\n\t}\n\n\tpushLine()\n\t{\n\t\tfor (let i = 0; i < this.CleanCharacters.length; i++)\n\t\t{\n\t\t\tthis.CurrentLine = this.CurrentLine.replace(this.CleanCharacters[i],'');\n\t\t}\n\t\tthis.CurrentRecord.push(this.CurrentLine);\n\t\tthis.CurrentLine = '';\n\t}\n\n\temitRow(pFormatAsJSON)\n\t{\n\t\tlet tmpFormatAsJSON = (typeof(pFormatAsJSON) == 'undefined') ? this.EmitJSON : pFormatAsJSON;\n\n\t\tthis.RowsEmitted++;\n\t\tlet tmpCompletedRecord = this.CurrentRecord;\n\t\tthis.CurrentRecord = [];\n\n\t\tif (tmpFormatAsJSON)\n\t\t{\n\t\t\treturn this.marshalRowToJSON(tmpCompletedRecord);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpCompletedRecord;\n\t\t}\n\t}\n\n\tparseCSVLine (pLineString)\n\t{\n\t\tthis.LinesParsed++;\n\n\t\tfor (let i = 0; i < pLineString.length; i++)\n\t\t{\n\t\t\tif ((!this.InQuote) && (pLineString[i] == this.Delimiter))\n\t\t\t{\n\t\t\t\tthis.pushLine();\n\t\t\t}\n\t\t\telse if (pLineString[i] == this.QuoteCharacter)\n\t\t\t{\n\t\t\t\t// If we are in the second part of an escaped quote, ignore it.\n\t\t\t\tif (this.InEscapedQuote)\n\t\t\t\t{\n\t\t\t\t\tthis.InEscapedQuote = false;\n\t\t\t\t}\n\t\t\t\t// If we aren't in a quote, enter quote\n\t\t\t\telse if (!this.InQuote)\n\t\t\t\t{\n\t\t\t\t\tthis.InQuote = true;\n\t\t\t\t}\n\t\t\t\t// We are in a quote, so peek forward to see if this is an \"escaped\" quote pair\n\t\t\t\telse if ((i < pLineString.length) && (pLineString[i+1] == this.QuoteCharacter))\n\t\t\t\t{\n\t\t\t\t\tthis.CurrentLine += this.EscapedQuoteString;\n\t\t\t\t\tthis.InEscapedQuote = true;\n\t\t\t\t}\n\t\t\t\t// We are in a quote, this isn't an \"escaped\" quote pair, so go out of quote mode\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.InQuote = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.CurrentLine += pLineString[i];\n\t\t\t}\n\t\t}\n\n\t\t// See if we are in a multiline quoted entry -- if not, emit the row.\n\t\tif (!this.InQuote)\n\t\t{\n\t\t\t// Push the last remaining column from the buffer to the current line.\n\t\t\tthis.pushLine();\n\n\t\t\t// Check to see if there is a header -- and if so, if this is the header row\n\t\t\tif (this.HasHeader && !this.HasSetHeader && (this.RowsEmitted == this.HeaderLineIndex))\n\t\t\t{\n\t\t\t\tthis.HasSetHeader = true;\n\t\t\t\t// Override the format as json bit\n\t\t\t\tthis.setHeader(this.emitRow(false));\n\n\t\t\t\t// No matter what, formatting this as JSON is silly and we don't want to go there anyway.\n\t\t\t\tif (this.EmitHeader)\n\t\t\t\t{\n\t\t\t\t\treturn this.Header;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.emitRow();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nmodule.exports = CSVParser;\n","const libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Data Formatting and Translation Functions\n*\n* @class DataFormat\n*/\nclass DataFormat extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'DataArithmatic';\n\n\t\t// Regular Expressions (so they don't have to be recompiled every time)\n\t\t// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.\n\t\tthis._Regex_formatterInsertCommas = /.{1,3}/g;\n\t\t// Match Function:\n\t\t// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t\t// Thoughts about below:   /^([+-]?)(0*)(\\d+)(\\.(\\d+))?$/;\n\t\tthis._Regex_formatterAddCommasToNumber = /^([-+]?)(0?)(\\d+)(.?)(\\d+)$/g;\n\t\tthis._Regex_formatterDollarsRemoveCommas = /,/gi;\n\t\tthis._Regex_formatterCleanNonAlphaChar = /[^a-zA-Z]/gi;\n\t\tthis._Regex_formatterCapitalizeEachWord = /([a-zA-Z]+)/g;\n\t\tthis._Regex_matcherHTMLEntities = /&(#?[a-zA-Z0-9]+);/g;\n\n\t\t// TODO: Potentially pull these in from a configuration.\n\t\t// TODO: Use locale data for this if it's defaults all the way down.\n\t\tthis._Value_MoneySign_Currency = '$';\n\t\tthis._Value_NaN_Currency = '--';\n\t\tthis._Value_GroupSeparator_Number = ',';\n\n\t\tthis._Value_Prefix_StringHash = 'HSH';\n\t\tthis._Value_Clean_formatterCleanNonAlpha = '';\n\n\t\tthis._UseEngineStringStartsWith = (typeof(String.prototype.startsWith) === 'function');\n\t\tthis._UseEngineStringEndsWith = (typeof(String.prototype.endsWith) === 'function');\n\n\t\tthis._SanitizeObjectKeyRegex = /[^a-zA-Z0-9_]/gi;\n\t\tthis._SanitizeObjectKeyReplacement = '_';\n\t\tthis._SanitizeObjectKeyInvalid = 'INVALID';\n\t}\n\n\t/*************************************************************************\n\t * String Manipulation and Comparison Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Reverse a string\n\t *\n\t * @param {string} pString - The string to reverse\n\t * @returns {string}\n\t */\n\tstringReverse (pString)\n\t{\n\t\t// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff\n\t\t//       ... and if it will work with browserify in a clean way.\n\t\treturn pString.split('').reverse().join('');\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pStartIndex\n\t * @returns {boolean}\n\t */\n\tstringStartsWith (pString, pSearchString, pStartIndex)\n\t{\n\t\tif (this._UseEngineStringStartsWith)\n\t\t{\n\t\t\treturn pString.startsWith(pSearchString, pStartIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringStartsWith_Polyfill.call(pString, pSearchString, pStartIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pStartIndex - The index to start the search at\n\t * @returns {boolean}\n\t */\n\tstringStartsWith_Polyfill (pSearchString, pStartIndex)\n\t{\n\t\treturn this.slice(pStartIndex || 0, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Test if a string starts with a given substring.\n\t *\n\t * @param {*} pString\n\t * @param {*} pSearchString\n\t * @param {*} pEndIndex\n\t * @returns {*}\n\t */\n\tstringEndsWith (pString, pSearchString, pEndIndex)\n\t{\n\t\tif (this._UseEngineStringEndsWith)\n\t\t{\n\t\t\treturn pString.endsWith(pSearchString, pEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.stringEndsWith_Polyfill.call(pString, pSearchString, pEndIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.\n\t *\n\t * @param {*} pSearchString - The string to search for\n\t * @param {*} pEndIndex - The index to end the search at\n\t * @returns {boolean}\n\t */\n\tstringEndsWith_Polyfill (pSearchString, pEndIndex)\n\t{\n\t\t// This works much better than >= because\n\t\t// it compensates for NaN:\n\t\tif (!(pEndIndex < this.length))\n\t\t{\n\t\t\tpEndIndex = this.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpEndIndex |= 0; // round position\n\t\t}\n\t\treturn this.substr(pEndIndex - pSearchString.length, pSearchString.length) === pSearchString;\n\t}\n\n\t/**\n\t * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!\n\t *\n\t * @param {string} pString\n\t * @returns {string}\n\t */\n\tinsecureStringHash (pString)\n\t{\n\t\tlet tmpHash = 0;\n\t\tlet tmpStringLength = pString.length;\n\t\tlet tmpCharacterIndex = 0;\n\n\t\twhile (tmpCharacterIndex < tmpStringLength)\n\t\t{\n\t\t\ttmpHash = (tmpHash << 5) - tmpHash + pString.charCodeAt(tmpCharacterIndex++) | 0;\n\t\t}\n\n\t\treturn `${this._Value_Prefix_StringHash}${tmpHash}`;\n\t}\n\n\tcapitalizeEachWord (pString)\n\t{\n\t\treturn pString.replace(this._Regex_formatterCapitalizeEachWord,\n\t\t\t(pMatch) =>\n\t\t\t{\n\t\t\t\treturn pMatch.charAt(0).toUpperCase() + pMatch.substr(1);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} pString - The string to resolve\n\t * @return {string} - The input string with all HTML entities resolved to their character counterparts\n\t */\n\tresolveHtmlEntities(pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn pString.replace(this._Regex_matcherHTMLEntities, (pMatch, pEntity) =>\n\t\t{\n\t\t\tswitch (pEntity)\n\t\t\t{\n\t\t\t\tcase 'comma':\n\t\t\t\t\treturn ',';\n\t\t\t\tcase 'amp':\n\t\t\t\t\treturn '&';\n\t\t\t\tcase 'lt':\n\t\t\t\t\treturn '<';\n\t\t\t\tcase 'gt':\n\t\t\t\t\treturn '>';\n\t\t\t\tcase 'times':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'divide':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'plus':\n\t\t\t\t\treturn '+';\n\t\t\t\tcase 'minus':\n\t\t\t\t\treturn '-';\n\t\t\t\tcase 'infin':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'ang':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'quot':\n\t\t\t\t\treturn '\"';\n\t\t\t\tcase 'apos':\n\t\t\t\t\treturn '\\'';\n\t\t\t\tcase 'nbsp':\n\t\t\t\t\treturn ' ';\n\t\t\t\tcase 'copy':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'reg':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'trade':\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'euro':\n\t\t\t\t\treturn '';\n\t\t\t\tdefault:\n\t\t\t\t\tif (!pEntity.startsWith('#'))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn pMatch;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tconst tmpNumericalValue = parseInt(pEntity.substring(1), 10);\n\t\t\treturn String.fromCharCode(tmpNumericalValue);\n\t\t});\n\t}\n\n\t/**\n\t * Concatenate a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {...string} pStrings - The strings to concatenate\n\t * @return {string}\n\t */\n\tconcatenateStrings (...pStrings)\n\t{\n\t\treturn this.joinStrings('', ...pStrings);\n\t}\n\n\t/**\n\t * Concatenate a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tconcatenateStringsInternal ()\n\t{\n\t\tconst pParams = [ ...arguments ];\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.concatenateStrings(...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Join a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...string} pStrings - The strings to join\n\t * @return {string}\n\t */\n\tjoinStrings (pJoin, ...pStrings)\n\t{\n\t\treturn pStrings.filter((v) => typeof v === 'string' || typeof v === 'number').join(pJoin);\n\t}\n\n\t/**\n\t * Joins a list of strings together. Non-strings are excluded.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tjoinStringsInternal()\n\t{\n\t\tconst [ pJoinOn, ...pParams ] = arguments;\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.joinStrings(pJoinOn, ...tmpFlattenedArrays);\n\t}\n\n\n\t/**\n\t * Concatenate a list of values together into a string.\n\t *\n\t * @param {...any} pValues - The strings to concatenate\n\t * @return {string}\n\t */\n\tconcatenateStringsRaw (...pValues)\n\t{\n\t\treturn this.joinStringsRaw('', ...pValues);\n\t}\n\n\t/**\n\t * Concatenate a list of values together into a string.\n\t *\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tconcatenateStringsRawInternal (pValueObjectSetAddress)\n\t{\n\t\tconst pParams = [ ...arguments ];\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.concatenateStringsRaw(...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Join a list of values together into a string.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pValues - The strings to join\n\t * @return {string}\n\t */\n\tjoinStringsRaw (pJoin, ...pValues)\n\t{\n\t\treturn pValues.map(String).join(pJoin);\n\t}\n\n\t/**\n\t * Joins a list of values together into a string.\n\t *\n\t * @param {string} pJoin - The string to join with\n\t * @param {...any} pParams - Any number of parameters\n\t * @return {string}\n\t */\n\tjoinStringsRawInternal ()\n\t{\n\t\tconst [ pJoinOn, ...pParams ] = arguments;\n\t\tconst tmpFlattenedArrays = this.fable.Utility.flattenArrayOfSolverInputs(pParams);\n\n\t\treturn this.joinStringsRaw(pJoinOn, ...tmpFlattenedArrays);\n\t}\n\n\t/**\n\t * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.\n\t *\n\t * @param {string} pWrapCharacter - The character expected as the wrapping character\n\t * @param {string} pString - the string to clean\n\t * @returns {string}\n\t */\n\tcleanEnclosureWrapCharacters (pWrapCharacter, pString)\n\t{\n\t\t// # Use case from ManyFest DSL:\n\t\t//\n\t\t// When a boxed property is passed in, it should have quotes of some\n\t\t// kind around it.\n\t\t//\n\t\t// For instance:\n\t\t// \t\tMyValues['Name']\n\t\t// \t\tMyValues[\"Age\"]\n\t\t// \t\tMyValues[`Cost`]\n\t\t//\n\t\t// This function is necessary to remove the wrapping quotes before object\n\t\t// resolution can occur.\n\t\tif (pString.startsWith(pWrapCharacter) && pString.endsWith(pWrapCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t/**\n\t * Clean a string of any non-alpha characters (including numbers)\n\t *\n\t * @param {*} pString\n\t * @returns\n\t */\n\tcleanNonAlphaCharacters (pString)\n\t{\n\t\tif ((typeof(pString) == 'string') && (pString != ''))\n\t\t{\n\t\t\treturn pString.replace(this._Regex_formatterCleanNonAlphaChar, this._Value_Clean_formatterCleanNonAlpha);\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Clean a string of any characters to create a consistent object key.\n\t *\n\t * @param {string} pString  The string to clean.\n\t * @return {string} the cleaned string, or a placeholder if the input is invalid\n\t */\n\tsanitizeObjectKey(pString)\n\t{\n\t\tif (typeof pString !== 'string' || pString.length < 1)\n\t\t{\n\t\t\treturn this._SanitizeObjectKeyInvalid;\n\t\t}\n\t\treturn pString.replace(this._SanitizeObjectKeyRegex, this._SanitizeObjectKeyReplacement);\n\t}\n\n\n\t/*************************************************************************\n\t * Number Formatting Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().\n\t *\n\t * @param {*} pString\n\t * @returns {*}\n\t */\n\tformatterInsertCommas (pString)\n\t{\n\t\t// Reverse, because it's easier to do things from the left, given arbitrary digit counts\n\t\tlet tmpReversed = this.stringReverse(pString);\n\t\t// Add commas every three characters\n\t\tlet tmpReversedWithCommas = tmpReversed.match(this._Regex_formatterInsertCommas).join(',');\n\t\t// Reverse again (back to normal direction)\n\t\treturn this.stringReverse(tmpReversedWithCommas);\n\t}\n\n\tprocessAddCommasToNumberRegex(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)\n\t{\n\t\t// If there was no decimal, the last capture grabs the final digit, so\n\t\t// we have to put it back together with the 'before' substring\n\t\treturn pSign + (pDecimal ? this.formatterInsertCommas(pBefore) + pDecimal + pAfter : this.formatterInsertCommas(pBefore + pAfter));\n\t}\n\n\t/**\n\t * Add Commas to a Number for readability.\n\t *\n\t * @param {*} pNumber\n\t * @returns {string}\n\t */\n\tformatterAddCommasToNumber (pNumber)\n\t{\n\t\t// If the regex doesn't match, `replace` returns the string unmodified\n\t\treturn (pNumber.toString()).replace\n\t\t(\n\t\t\tthis._Regex_formatterAddCommasToNumber,\n\t\t\tthis.processAddCommasToNumberRegex.bind(this)\n\t\t);\n\t}\n\n\t/**\n\t * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.\n\t *\n\t * @param {*} pValue\n\t * @returns {string}\n\t */\n\tformatterDollars (pValue, pPrecision, pRoundingMethod)\n\t{\n\t\tif (isNaN(pValue))\n\t\t{\n\t\t\treturn this._Value_NaN_Currency;\n\t\t}\n\n\t\tif (pValue === null || pValue === undefined)\n\t\t{\n\t\t\treturn this._Value_NaN_Currency;\n\t\t}\n\n\t\tlet tmpDollarAmountArbitrary = this.fable.Math.parsePrecise(pValue);\n\t\tlet tmpPrecision = (typeof(pPrecision) == 'undefined') ? 2 : pPrecision;\n\t\tlet tmpDollarAmount = this.fable.Math.toFixedPrecise(tmpDollarAmountArbitrary, tmpPrecision, pRoundingMethod);\n\n\t\t// TODO: Get locale data and use that for this stuff.\n\t\treturn `$${this.formatterAddCommasToNumber(tmpDollarAmount)}`;\n\t}\n\n\t/**\n\t * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.\n\t *\n\t * @param {*} pValue\n\t * @param {number} pDigits\n\t * @returns {string}\n\t */\n\tformatterRoundNumber (pValue, pDigits)\n\t{\n\t\tlet tmpDigits = (typeof(pDigits) == 'undefined') ? 2 : pDigits;\n\n\t\tif (isNaN(pValue))\n\t\t{\n\t\t\tlet tmpZed = 0;\n\t\t\treturn tmpZed.toFixed(tmpDigits);\n\t\t}\n\n\t\tif (pValue === null || pValue === undefined)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpAmountArbitrary = this.fable.Utility.bigNumber(pValue);\n\t\tlet tmpValue = tmpAmountArbitrary.toFixed(tmpDigits);\n\n\t\tif (isNaN(tmpValue))\n\t\t{\n\t\t\tlet tmpZed = 0;\n\t\t\treturn tmpZed.toFixed(tmpDigits);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpValue;\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate a reapeating padding string to be appended before or after depending on\n\t * which padding function it uses.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringGeneratePaddingString(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpTargetLength = pTargetLength >> 0;\n\t\tlet tmpPadString = String((typeof pPadString !== 'undefined' ? pPadString : ' '));\n\t\tif (pString.length > pTargetLength)\n\t\t{\n\t\t\t// No padding string if the source string is already longer than the target length, return an empty string\n\t\t\treturn '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpPadLength = pTargetLength - pString.length;\n\t\t\tif (tmpPadLength > tmpPadString.length)\n\t\t\t{\n\t\t\t\ttmpPadString += tmpPadString.repeat(tmpTargetLength / tmpPadString.length);\n\t\t\t}\n\t\t\treturn tmpPadString.slice(0, tmpPadLength);\n\t\t}\n\t}\n\n\t/**\n\t * Pad the start of a string.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringPadStart = function(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpString = pString.toString();\n\t\treturn this.stringGeneratePaddingString(tmpString, pTargetLength, pPadString) + tmpString;\n\t}\n\n\t/**\n\t * Pad the end of a string.\n\t *\n\t * @param {*} pString\n\t * @param {number} pTargetLength\n\t * @returns {string} pPadString\n\t */\n\tstringPadEnd = function(pString, pTargetLength, pPadString)\n\t{\n\t\tlet tmpString = pString.toString();\n\t\treturn tmpString + this.stringGeneratePaddingString(tmpString, pTargetLength, pPadString);\n\t}\n\n\t/*************************************************************************\n\t * Time Formatting Functions (milliseconds)\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Format a time length in milliseconds into a human readable string.\n\t * @param {number} pTimeSpan\n\t * @returns {string} - HH:MM:SS.mmm\n\t */\n\tformatTimeSpan(pTimeSpan)\n\t{\n\t\tif (typeof(pTimeSpan) != 'number')\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet tmpMs = parseInt(pTimeSpan%1000);\n\t\tlet tmpSeconds = parseInt((pTimeSpan/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeSpan/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeSpan/(1000*60*60));\n\n\t\treturn `${this.stringPadStart(tmpHours,2,'0')}:${this.stringPadStart(tmpMinutes,2,'0')}:${this.stringPadStart(tmpSeconds,2,'0')}.${this.stringPadStart(tmpMs,3,'0')}`;\n\t}\n\n\t/**\n\t * Format the time delta between two times in milliseconds into a human readable string.\n\t *\n\t * @param {number} pTimeStart\n\t * @param {number} pTimeEnd\n\t * @returns {string} - HH:MM:SS.mmm\n\t */\n\tformatTimeDelta(pTimeStart, pTimeEnd)\n\t{\n\t\tif ((typeof(pTimeStart) != 'number') || (typeof(pTimeEnd) != 'number'))\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.formatTimeSpan(pTimeEnd-pTimeStart);\n\t}\n\n\t// THE FOLLOWING TERRIBLE FUNCTIONS ARE FOR QT / WKHTMLTOPDF when luxon and moment don't work so well\n\tgetMonthFromDate (pJavascriptDate)\n\t{\n\t\tvar tmpMonths = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\t\treturn tmpMonths[pJavascriptDate.getMonth()];\n\t}\n\n\tgetMonthAbbreviatedFromDate (pJavascriptDate)\n\t{\n\t\tvar tmpMonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\t\treturn tmpMonths[pJavascriptDate.getMonth()];\n\t}\n\n\tformatMonthDayYearFromDate (pJavascriptDate, pStrict)\n\t{\n\t\tlet tmpStrict = (typeof(pStrict) !== 'undefined') ? pStrict : false;\n\n\t\tlet tmpMonth = pJavascriptDate.getMonth() + 1;\n\t\tlet tmpDay = pJavascriptDate.getDate();\n\t\tlet tmpYear = pJavascriptDate.getFullYear();\n\n\t\tif (tmpStrict)\n\t\t{\n\t\t\ttmpMonth = this.stringPadStart(tmpMonth, 2, '0');\n\t\t\ttmpDay = this.stringPadStart(tmpDay, 2, '0');\n\t\t\ttmpYear = this.stringPadStart(tmpYear, 4, '0');\n\t\t}\n\n\t\treturn `${tmpMonth}/${tmpDay}/${tmpYear}`;\n\t}\n\n\tformatSortableStringFromDate (pDate)\n\t{\n\t\treturn pDate.getFullYear()+this.stringPadStart(pDate.getMonth(),2,'0')+this.stringPadStart(pDate.getDate(),2,'0');\n\t}\n\n\t/*************************************************************************\n\t * String Tokenization Functions\n\t *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n\n\t/**\n\t * Return the string before the matched substring.\n\t *\n\t * If the substring is not found, the entire string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringBeforeMatch (pString, pMatch)\n\t{\n\t\treturn pString.split(pMatch)[0];\n\t}\n\n\t/**\n\t * Return the string after the matched substring.\n\t *\n\t * If the substring is not found, an empty string is returned.  This only deals with the *first* match.\n\t *\n\t * @param {string} pString\n\t * @param {string} pMatch\n\t * @returns {string}\n\t */\n\tstringAfterMatch (pString, pMatch)\n\t{\n\t\tlet tmpStringSplitLocation = pString.indexOf(pMatch);\n\n\t\tif ((tmpStringSplitLocation < 0) || ((tmpStringSplitLocation + pMatch.length) >= pString.length))\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\treturn pString.substring(tmpStringSplitLocation + pMatch.length);\n\t}\n\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the count of segments in the string as a number\n\t */\n\tstringCountSegments(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t}\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetSegments(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2, '\"':3, \"'\":4 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2, '\"':3, \"'\":4 };\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t}\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t *\n\t * @param {string} pString\n\t * @param {string} pSeparator\n\t * @param {object} pEnclosureStartSymbolMap\n\t * @param {object} pEnclosureEndSymbolMap\n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetFirstSegment(pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t}\n\n\t/**\n\t * Encodes a string using encodeURIComponent, returning the encoded string.\n\t * If the input is not a string, returns the input unchanged.\n\t *\n\t * @param {string} pString - The string to encode.\n\t * @returns {string|*} The encoded string, or the original input if it is not a string.\n\t */\n\tstringEncodeURIComponent (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn encodeURIComponent(pString);\n\t}\n\n\t/**\n\t * Safely decodes a URI component string using decodeURIComponent.\n\t * If the input is not a string or decoding fails, returns the original input.\n\t *\n\t * @param {string} pString - The string to decode.\n\t * @returns {string} The decoded string, or the original input if decoding fails.\n\t */\n\tstringDecodeURIComponent (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\treturn decodeURIComponent(pString);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tthis.fable.Log.error(`Failed to decode URI component: ${pString}`, e);\n\t\t\treturn pString; // Return the original string if decoding fails\n\t\t}\n\t}\n\n\t/**\n\t * Encodes a string so that it can be safely embedded in JavaScript code.\n\t * Escapes special characters such as quotes, backslashes, and newlines.\n\t *\n\t * @param {string} pString - The input string to encode.\n\t * @returns {string} The encoded string with special characters escaped.\n\t */\n\tstringEncodeForJavascript (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\t//FIXME: missing regexp\n\t\treturn pString.replace(this._Regex_matcherJavascriptEncode, (pMatch) =>\n\t\t{\n\t\t\tswitch (pMatch)\n\t\t\t{\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn '\\\\\"';\n\t\t\t\tcase '\\'':\n\t\t\t\t\treturn '\\\\\\'';\n\t\t\t\tcase '\\\\':\n\t\t\t\t\treturn '\\\\\\\\';\n\t\t\t\tcase '\\n':\n\t\t\t\t\treturn '\\\\n';\n\t\t\t\tcase '\\r':\n\t\t\t\t\treturn '\\\\r';\n\t\t\t\tdefault:\n\t\t\t\t\treturn pMatch; // Return the original character if no encoding is needed\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a JavaScript-escaped string by replacing common escape sequences\n\t * (such as \\\" \\\\n \\\\r \\\\' and \\\\\\\\) with their actual character representations.\n\t *\n\t * @param {string} pString - The string to decode. If not a string, the input is returned as-is.\n\t * @returns {string} The decoded string with escape sequences replaced, or the original input if not a string.\n\t */\n\tstringDecodeForJavascript (pString)\n\t{\n\t\tif (typeof(pString) !== 'string')\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\n\t\treturn pString.replace(this._Regex_matcherJavascriptDecode, (pMatch) =>\n\t\t{\n\t\t\tswitch (pMatch)\n\t\t\t{\n\t\t\t\tcase '\\\\\"':\n\t\t\t\t\treturn '\"';\n\t\t\t\tcase '\\\\\\'':\n\t\t\t\t\treturn '\\'';\n\t\t\t\tcase '\\\\\\\\':\n\t\t\t\t\treturn '\\\\';\n\t\t\t\tcase '\\\\n':\n\t\t\t\t\treturn '\\n';\n\t\t\t\tcase '\\\\r':\n\t\t\t\t\treturn '\\r';\n\t\t\t\tdefault:\n\t\t\t\t\treturn pMatch; // Return the original character if no decoding is needed\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures (pString, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t}\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove an enclosure from a string based on the index of the enclosure.\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToRemove\n\t * @param {number} pEnclosureStart\n\t * @param {number} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringRemoveEnclosureByIndex (pString, pEnclosureIndexToRemove, pEnclosureStart, pEnclosureEnd)\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToRemove = (typeof(pEnclosureIndexToRemove) == 'number') ? pEnclosureIndexToRemove : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosureStartIndex = 0;\n\t\tlet tmpEnclosureEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToRemove == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosureStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosureEndIndex <= tmpEnclosureStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToRemove)\n\t\t{\n\t\t\treturn tmpString;\n\t\t}\n\n\t\tlet tmpReturnString = '';\n\n\t\tif (tmpEnclosureStartIndex > 1)\n\t\t{\n\t\t\ttmpReturnString = tmpString.substring(0, tmpEnclosureStartIndex);\n\t\t}\n\n\t\tif ((tmpString.length > (tmpEnclosureEndIndex + 1)) && (tmpEnclosureEndIndex > tmpEnclosureStartIndex))\n\t\t{\n\t\t\ttmpReturnString += tmpString.substring(tmpEnclosureEndIndex+1);\n\t\t}\n\n\t\treturn tmpReturnString;\n\t}\n}\n\nmodule.exports = DataFormat;\n","module.exports={\n\t\"DefaultIntegerMinimum\": 0,\n\t\"DefaultIntegerMaximum\": 9999999,\n\n\t\"DefaultNumericStringLength\": 10,\n\n\t\"MonthSet\": [\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\n\n\t\"WeekDaySet\":[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],\n\n\t\"ColorSet\": \n\t\t[\n\t\t\t\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\", \"Pink\", \"Purple\", \"Turquoise\", \"Gold\",\n\t\t\t\"Lime\", \"Maroon\", \"Navy\", \"Coral\", \"Teal\", \"Brown\", \"White\", \"Black\", \"Sky\", \"Berry\",\n\t\t\t\"Grey\", \"Straw\", \"Silver\", \"Sapphire\"\n\t\t],\n\n\t\"SurNameSet\":\n\t\t[\n\t\t\t\"Smith\", \"Johnson\", \"Williams\", \"Brown\", \"Jones\", \"Miller\", \"Davis\", \"Garcia\", \"Rodriguez\", \"Wilson\",\n\t\t\t\"Martinez\", \"Anderson\", \"Taylor\", \"Thomas\", \"Hernandez\", \"Moore\", \"Martin\", \"Jackson\", \"Thompson\", \"White\",\n\t\t\t\"Lopez\", \"Lee\", \"Gonzalez\", \"Harris\", \"Clark\", \"Lewis\", \"Robinson\", \"Walker\", \"Perez\", \"Hall\",\n\t\t\t\"Young\", \"Allen\", \"Sanchez\", \"Wright\", \"King\", \"Scott\", \"Green\", \"Baker\", \"Adams\", \"Nelson\",\n\t\t\t\"Hill\", \"Ramirez\", \"Campbell\", \"Mitchell\", \"Roberts\", \"Carter\", \"Phillips\", \"Evans\", \"Turner\", \"Torres\",\n\t\t\t\"Parker\", \"Collins\", \"Edwards\", \"Stewart\", \"Flores\", \"Morris\", \"Nguyen\", \"Murphy\", \"Rivera\", \"Cook\",\n\t\t\t\"Rogers\", \"Morgan\", \"Peterson\", \"Cooper\", \"Reed\", \"Bailey\", \"Bell\", \"Gomez\", \"Kelly\", \"Howard\",\n\t\t\t\"Ward\", \"Cox\", \"Diaz\", \"Richardson\", \"Wood\", \"Watson\", \"Brooks\", \"Bennett\", \"Gray\", \"James\",\n\t\t\t\"Reyes\", \"Cruz\", \"Hughes\", \"Price\", \"Myers\", \"Long\", \"Foster\", \"Sanders\", \"Ross\", \"Morales\",\n\t\t\t\"Powell\", \"Sullivan\", \"Russell\", \"Ortiz\", \"Jenkins\", \"Gutierrez\", \"Perry\", \"Butler\", \"Barnes\", \"Fisher\"\n\t\t],\n\n\t\"NameSet\":\n\t\t[\n\t\t\t\"Mary\", \"Patricia\", \"Jennifer\", \"Linda\", \"Elizabeth\", \"Barbara\", \"Susan\", \"Jessica\", \"Sarah\", \"Karen\",\n\t\t\t\"Lisa\", \"Nancy\", \"Betty\", \"Sandra\", \"Margaret\", \"Ashley\", \"Kimberly\", \"Emily\", \"Donna\", \"Michelle\",\n\t\t\t\"Carol\", \"Amanda\", \"Melissa\", \"Deborah\", \"Stephanie\", \"Dorothy\", \"Rebecca\", \"Sharon\", \"Laura\", \"Cynthia\",\n\t\t\t\"Amy\", \"Kathleen\", \"Angela\", \"Shirley\", \"Brenda\", \"Emma\", \"Anna\", \"Pamela\", \"Nicole\", \"Samantha\",\n\t\t\t\"Katherine\", \"Christine\", \"Helen\", \"Debra\", \"Rachel\", \"Carolyn\", \"Janet\", \"Maria\", \"Catherine\", \"Heather\",\n\t\t\t\"Diane\", \"Olivia\", \"Julie\", \"Joyce\", \"Victoria\", \"Ruth\", \"Virginia\", \"Lauren\", \"Kelly\", \"Christina\",\n\t\t\t\"Joan\", \"Evelyn\", \"Judith\", \"Andrea\", \"Hannah\", \"Megan\", \"Cheryl\", \"Jacqueline\", \"Martha\", \"Madison\",\n\t\t\t\"Teresa\", \"Gloria\", \"Sara\", \"Janice\", \"Ann\", \"Kathryn\", \"Abigail\", \"Sophia\", \"Frances\", \"Jean\",\n\t\t\t\"Alice\", \"Judy\", \"Isabella\", \"Julia\", \"Grace\", \"Amber\", \"Denise\", \"Danielle\", \"Marilyn\", \"Beverly\",\n\t\t\t\"Charlotte\", \"Natalie\", \"Theresa\", \"Diana\", \"Brittany\", \"Doris\", \"Kayla\", \"Alexis\", \"Lori\", \"Marie\",\n\t\t\t\"James\", \"Robert\", \"John\", \"Michael\", \"David\", \"William\", \"Richard\", \"Joseph\", \"Thomas\", \"Christopher\",\n\t\t\t\"Charles\", \"Daniel\", \"Matthew\", \"Anthony\", \"Mark\", \"Donald\", \"Steven\", \"Andrew\", \"Paul\", \"Joshua\",\n\t\t\t\"Kenneth\", \"Kevin\", \"Brian\", \"George\", \"Timothy\", \"Ronald\", \"Jason\", \"Edward\", \"Jeffrey\", \"Ryan\",\n\t\t\t\"Jacob\", \"Gary\", \"Nicholas\", \"Eric\", \"Jonathan\", \"Stephen\", \"Larry\", \"Justin\", \"Scott\", \"Brandon\",\n\t\t\t\"Benjamin\", \"Samuel\", \"Gregory\", \"Alexander\", \"Patrick\", \"Frank\", \"Raymond\", \"Jack\", \"Dennis\", \"Jerry\",\n\t\t\t\"Tyler\", \"Aaron\", \"Jose\", \"Adam\", \"Nathan\", \"Henry\", \"Zachary\", \"Douglas\", \"Peter\", \"Kyle\",\n\t\t\t\"Noah\", \"Ethan\", \"Jeremy\", \"Walter\", \"Christian\", \"Keith\", \"Roger\", \"Terry\", \"Austin\", \"Sean\",\n\t\t\t\"Gerald\", \"Carl\", \"Harold\", \"Dylan\", \"Arthur\", \"Lawrence\", \"Jordan\", \"Jesse\", \"Bryan\", \"Billy\",\n\t\t\t\"Bruce\", \"Gabriel\", \"Joe\", \"Logan\", \"Alan\", \"Juan\", \"Albert\", \"Willie\", \"Elijah\", \"Wayne\",\n\t\t\t\"Randy\", \"Vincent\", \"Mason\", \"Roy\", \"Ralph\", \"Bobby\", \"Russell\", \"Bradley\", \"Philip\", \"Eugene\"\n\t\t]\n}","const libFableServiceBase = require('fable-serviceproviderbase');\n\n/**\n * FableServiceDataGeneration class provides various methods for generating random data.\n *\n * @extends libFableServiceBase\n */\nclass FableServiceDataGeneration extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'DataGeneration';\n\n\t\tthis.defaultData = require('./Fable-Service-DataGeneration-DefaultValues.json');\n\t}\n\n\t/**\n\t * Generates a random integer between the specified minimum and maximum values.\n\t *\n\t * @param {number} pMinimum - The minimum value (inclusive).\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random integer between pMinimum and pMaximum.\n\t */\n\trandomIntegerBetween(pMinimum, pMaximum)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpMinimum = parseInt(pMinimum, 10);\n\t\t\tlet tmpMaximum = parseInt(pMaximum, 10);\n\t\t\treturn Math.floor(Math.random() * (tmpMaximum - tmpMinimum)) + tmpMinimum;\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\tthis.fable.log.error('Error in randomIntegerBetween', pError, { 'Minimum': pMinimum, 'Maximum': pMaximum });\n\t\t\treturn NaN;\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random integer between 0 (inclusive) and the specified maximum value (exclusive).\n\t *\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random integer between 0 and pMaximum.\n\t */\n\trandomIntegerUpTo(pMaximum)\n\t{\n\t\treturn this.randomIntegerBetween(0, pMaximum);\n\t}\n\n\t/**\n\t * Generates a random integer between 0 (inclusive) and the default maximum value.\n\t *\n\t * @returns {number} A random integer between 0 and the default maximum value.\n\t */\n\trandomInteger()\n\t{\n\t\treturn Math.floor(Math.random() * this.defaultData.DefaultIntegerMaximum);\n\t}\n\n\t/**\n\t * Generates a random float between the specified minimum and maximum values.\n\t *\n\t * @param {number} pMinimum - The minimum value (inclusive).\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random float between pMinimum and pMaximum.\n\t */\n\trandomFloatBetween(pMinimum, pMaximum)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpMinimum = parseFloat(pMinimum);\n\t\t\tlet tmpMaximum = parseFloat(pMaximum);\n\t\t\treturn this.fable.Math.addPrecise(this.fable.Math.multiplyPrecise(Math.random(), this.fable.Math.subtractPrecise(tmpMaximum, tmpMinimum)), tmpMinimum);\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\tthis.fable.log.error('Error in randomFloatBetween', pError, { 'Minimum': pMinimum, 'Maximum': pMaximum });\n\t\t\treturn NaN;\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random float between 0 (inclusive) and the specified maximum value (exclusive).\n\t *\n\t * @param {number} pMaximum - The maximum value (exclusive).\n\t * @returns {number} A random float between 0 and pMaximum.\n\t */\n\trandomFloatUpTo(pMaximum)\n\t{\n\t\treturn this.randomFloatBetween(0, pMaximum);\n\t}\n\n\t/**\n\t * Generates a random float between 0 (inclusive) and 1 (exclusive).\n\t *\n\t * @returns {number} A random float between 0 and 1.\n\t */\n\trandomFloat()\n\t{\n\t\treturn Math.random();\n\t}\n\n\t/**\n\t * Generates a random numeric string of the specified length.\n\t *\n\t * @param {number} pLength - The length of the numeric string.\n\t * @param {number} pMaxNumber - The maximum number to generate.\n\t * @returns {string} A random numeric string of the specified length.\n\t */\n\trandomNumericString(pLength, pMaxNumber)\n\t{\n\t\tlet tmpLength = (typeof(pLength) === 'undefined') ? 10 : pLength;\n\t\tlet tmpMaxNumber = (typeof(pMaxNumber) === 'undefined') ? 9999999999 : pMaxNumber;\n\n\t\treturn this.services.DataFormat.stringPadStart(this.randomIntegerUpTo(tmpMaxNumber), pLength, '0');\n\t}\n\n\t/**\n\t * Generates a random month from the default month set.\n\t *\n\t * @returns {string} A random month.\n\t */\n\trandomMonth()\n\t{\n\t\treturn this.defaultData.MonthSet[this.randomIntegerUpTo(this.defaultData.MonthSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random day of the week from the default week day set.\n\t *\n\t * @returns {string} A random day of the week.\n\t */\n\trandomDayOfWeek()\n\t{\n\t\treturn this.defaultData.WeekDaySet[this.randomIntegerUpTo(this.defaultData.WeekDaySet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random color from the default color set.\n\t *\n\t * @returns {string} A random color.\n\t */\n\trandomColor()\n\t{\n\t\treturn this.defaultData.ColorSet[this.randomIntegerUpTo(this.defaultData.ColorSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random name from the default name set.\n\t *\n\t * @returns {string} A random name.\n\t */\n\trandomName()\n\t{\n\t\treturn this.defaultData.NameSet[this.randomIntegerUpTo(this.defaultData.NameSet.length - 1)];\n\t}\n\n\t/**\n\t * Generates a random surname from the default surname set.\n\t *\n\t * @returns {string} A random surname.\n\t */\n\trandomSurname()\n\t{\n\t\treturn this.defaultData.SurNameSet[this.randomIntegerUpTo(this.defaultData.SurNameSet.length - 1)];\n\t}\n}\n\nmodule.exports = FableServiceDataGeneration;\n","const libFableServiceProviderBase = require('fable-serviceproviderbase');\n/**\n* Date management a la Moment using days.js\n*\n* @class DateManipulation\n*/\nclass DateManipulation extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash)\n\n\t\tthis.serviceType = 'Dates';\n\n\t\tthis.dayJS = require('dayjs');\n\n\t\t// Include the `weekOfYear` plugin\n\t\tthis.plugin_weekOfYear = require('dayjs/plugin/weekOfYear');\n\t\tthis.dayJS.extend(this.plugin_weekOfYear);\n\t\t// Include the `weekday` plugin\n\t\tthis.plugin_weekday = require('dayjs/plugin/weekday');\n\t\tthis.dayJS.extend(this.plugin_weekday);\n\t\t// Include the `isoWeek` plugin\n\t\tthis.plugin_isoWeek = require('dayjs/plugin/isoWeek');\n\t\tthis.dayJS.extend(this.plugin_isoWeek);\n\t\t// Include the `timezone` plugin\n\t\tthis.plugin_timezone = require('dayjs/plugin/timezone');\n\t\tthis.dayJS.extend(this.plugin_timezone);\n\t\t// Include the `relativetime` plugin\n\t\tthis.plugin_relativetime = require('dayjs/plugin/relativeTime');\n\t\tthis.dayJS.extend(this.plugin_relativetime);\n\t\t// Include the `utc` plugin\n\t\tthis.plugin_utc = require('dayjs/plugin/utc');\n\t\tthis.dayJS.extend(this.plugin_utc);\n\t\t// Include the `advancedFormat` plugin\n\t\tthis.plugin_advancedFormat = require('dayjs/plugin/advancedFormat');\n\t\tthis.dayJS.extend(this.plugin_advancedFormat);\n\n\t\t// A developer can include locales if they want\n\t\t// You would do the following:\n\t\t// const localeDE = require('dayjs/locale/de');\n\t\t// _Fable.Dates.dayJS.locale('de');\n\t}\n\n\t/**\n\t * Calculates the difference in milliseconds between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in milliseconds between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMillisecondDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'millisecond');\n\t}\n\n\t/**\n\t * Calculates the difference in seconds between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in seconds between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateSecondDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'second');\n\t}\n\n\t/**\n\t * Calculates the difference in minutes between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in minutes between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMinuteDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'minute');\n\t}\n\n\t/**\n\t * Calculates the difference in hours between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in hours between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateHourDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'hour');\n\t}\n\n\t/**\n\t * Calculates the difference in days between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in days between the start and end dates. Returns NaN if the start date is invalid.\n\t */\n\tdateDayDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'day');\n\t}\n\n\t/**\n\t * Calculates the difference in weeks between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in weeks between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateWeekDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'week');\n\t}\n\n\t/**\n\t * Calculates the difference in months between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in months between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateMonthDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'month');\n\t}\n\n\t/**\n\t * Calculates the difference in years between two dates.\n\t *\n\t * @param {string|Date|number} pDateStart - The start date. Can be a string, Date object, or timestamp.\n\t * @param {string|Date|number} pDateEnd - The end date. Can be a string, Date object, or timestamp. Defaults to the current date if not provided.\n\t * @param {boolean} pRequireEndDate - If true, the end date must be provided; otherwise, it defaults to the current date.\n\t * @returns {number} The difference in years between the two dates. Returns NaN if the start date is invalid.\n\t */\n\tdateYearDifference(pDateStart, pDateEnd, pRequireEndDate = false)\n\t{\n\t\tif ((pDateStart === undefined) || (pDateStart === null) || (pDateStart === ''))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((pRequireEndDate || (pRequireEndDate == 1) || (pRequireEndDate == '1')) && ((pDateEnd === undefined) || (pDateEnd === null) || (pDateEnd === '')))\n\t\t{\n\t\t\treturn NaN;\n\t\t}\n\t\tlet tmpStartDate = this.dayJS(pDateStart);\n\t\tlet tmpEndDate = this.dayJS(pDateEnd);\n\t\treturn tmpEndDate.diff(tmpStartDate, 'year');\n\t}\n\n\tdateAddMilliseconds(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'millisecond', 'add');\n\t}\n\n\tdateAddSeconds(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'second', 'add');\n\t}\n\n\tdateAddMinutes(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'minute', 'add');\n\t}\n\n\tdateAddHours(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'hour', 'add');\n\t}\n\n\tdateAddDays(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'day', 'add');\n\t}\n\n\tdateAddWeeks(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'week', 'add');\n\t}\n\n\tdateAddMonths(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'month', 'add');\n\t}\n\n\tdateAddYears(pDate, pAmount)\n\t{\n\t\treturn this.dateMath(pDate, pAmount, 'year', 'add');\n\t}\n\n\tdateMath(pDate, pAmount, pUnit, pOperation)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpDate = this.dayJS.utc(pDate);\n\n\t\t\tif (pOperation === 'add')\n\t\t\t{\n\t\t\t\ttmpDate = tmpDate.add(pAmount, pUnit);\n\t\t\t}\n\t\t\telse if (pOperation === 'subtract')\n\t\t\t{\n\t\t\t\ttmpDate = tmpDate.subtract(pAmount, pUnit);\n\t\t\t}\n\t\t\treturn this.dayJS.utc(tmpDate).toISOString();\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tdateFromParts(pYear, pMonth, pDay, pHour = 0, pMinute = 0, pSecond = 0, pMillisecond = 0)\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet tmpDate = this.dayJS.utc().year(pYear).month(pMonth - 1).date(pDay).hour(pHour).minute(pMinute).second(pSecond).millisecond(pMillisecond);\n\t\t\treturn tmpDate.toISOString();\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = DateManipulation;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceEnvironmentData extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'EnvironmentData';\n\n\t\tthis.Environment = `node.js`;\n\t}\n}\n\nmodule.exports = FableServiceEnvironmentData;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\n/* Trying a different pattern for this service ...\n *\n * This service is a simple expression parser that can handle math expressions, with magic(tm) lookup of addresses with a manifest.\n *\n * Each method works multiple ways.\n *\n * 1. You can pass in a results object, and, it will put the state for that step outcome into the results object.\n * 2. It always returns the state, and works without the results object.\n *\n *\n * Learned a lot from this npm package: https://www.npmjs.com/package/math-expression-evaluator\n * And its related code at github: https://github.com/bugwheels94/math-expression-evaluator\n *\n * There were two problems with the codebase above...\n *\n * First, the code was very unreadable and determining it was correct or extending it\n * was out of the question.\n *\n * Second, and this is a larger issue, is that we need the expressions to be parsed as\n * arbitrary precision.  When I determined that extending the library to use string-based\n * numbers and an arbitrary precision library as the back-end would have taken a significantly\n * longer amount of time than just writing the parser from scratch... et voila.\n */\n\nclass FableServiceExpressionParser extends libFableServiceBase\n{\n\t/**\n\t * Constructs a new instance of the ExpressionParser service.\n\t * @param {Object} pFable - The Fable object.\n\t * @param {Object} pOptions - The options for the service.\n\t * @param {string} pServiceHash - The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t/** @type {import('../Fable.js') & { Math: import('./Fable-Service-Math.js') }} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.log;\n\n\t\t// The configuration for tokens that the solver recognizes, with precedence and friendly names.\n\t\tthis.tokenMap = require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json');\n\n\t\t// Keep track of maximum token precedence\n\t\tthis.tokenMaxPrecedence = 4;\n\t\t// This isn't exactly a radix tree but close enough.  It's a map of the first character of the token to the token.\n\t\tthis.tokenRadix = {};\n\t\tlet tmpTokenKeys = Object.keys(this.tokenMap);\n\t\tfor (let i = 0; i < tmpTokenKeys.length; i++)\n\t\t{\n\t\t\tlet tmpTokenKey = tmpTokenKeys[i];\n\t\t\tlet tmpToken = this.tokenMap[tmpTokenKey];\n\n\t\t\ttmpToken.Token = tmpTokenKey;\n\t\t\ttmpToken.Length = tmpTokenKey.length;\n\n\t\t\tlet tmpTokenStartCharacter = tmpToken.Token[0];\n\t\t\tif (!(tmpTokenStartCharacter in this.tokenRadix))\n\t\t\t{\n\t\t\t\t// With a token count of 1 and a literal of true, we can assume it being in the radix is the token.\n\t\t\t\tthis.tokenRadix[tmpTokenStartCharacter] = (\n\t\t\t\t\t{\n\t\t\t\t\t\tTokenCount: 0,\n\t\t\t\t\t\tLiteral: false,\n\t\t\t\t\t\tTokenKeys: [],\n\t\t\t\t\t\tTokenMap: {}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenCount++;\n\t\t\tif (tmpTokenKey == tmpTokenStartCharacter)\n\t\t\t{\n\t\t\t\tthis.tokenRadix[tmpTokenStartCharacter].Literal = true;\n\t\t\t}\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenMap[tmpToken.Token] = tmpToken;\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenKeys.push(tmpTokenKey);\n\t\t\tthis.tokenRadix[tmpTokenStartCharacter].TokenKeys.sort((pLeft, pRight) => pRight.length - pLeft.length);\n\n\t\t\tif (this.tokenMaxPrecedence < tmpToken.Precedence)\n\t\t\t{\n\t\t\t\tthis.tokenMaxPrecedence = tmpToken.Precedence;\n\t\t\t}\n\t\t}\n\n\t\t// The configuration for which functions are available to the solver.\n\t\tthis.functionMap = require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json');\n\n\t\tthis.serviceType = 'ExpressionParser';\n\n\t\t// These are sub-services for the tokenizer, linter, compiler, marshaler and solver.\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Tokenizer', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-TokenizerDirectiveMutation', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer-DirectiveMutation.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Linter', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Postfix', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-ValueMarshal', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js'));\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Solver', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js'));\n\t\t// And the sub-service for the friendly user messaging\n\t\tthis.fable.addServiceTypeIfNotExists('ExpressionParser-Messaging', require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js'));\n\n\n\t\t// This code instantitates these fable services to child objects of this service, but does not pollute the main fable with them.\n\t\tthis.Tokenizer = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Tokenizer');\n\t\tthis.Tokenizer.TokenizerDirectiveMutation = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-TokenizerDirectiveMutation');\n\t\tthis.Linter = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Linter');\n\t\tthis.Postfix = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Postfix');\n\t\tthis.ValueMarshal = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-ValueMarshal');\n\t\tthis.Solver = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Solver');\n\t\tthis.Messaging = this.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Messaging');\n\n\t\t// Wire each sub service into this instance of the solver.\n\t\tthis.Tokenizer.connectExpressionParser(this);\n\t\tthis.Linter.connectExpressionParser(this);\n\t\tthis.Postfix.connectExpressionParser(this);\n\t\tthis.ValueMarshal.connectExpressionParser(this);\n\t\tthis.Solver.connectExpressionParser(this);\n\t\tthis.Messaging.connectExpressionParser(this);\n\n\t\tthis.GenericManifest = this.fable.newManyfest();\n\n\t\t// This will look for a LogNoisiness on fable (or one that falls in from pict) and if it doesn't exist, set one for this service.\n\t\tthis.LogNoisiness = ('LogNoisiness' in this.fable) ? this.fable.LogNoisiness : 0;\n\t}\n\n\t/**\n\t * Tokenizes the given mathematical expression string.\n\t *\n\t * @param {string} pExpression - The expression to tokenize.\n\t * @param {object} pResultObject - The result object to store the tokenized expression.\n\t * @returns {object} - The tokenized expression.\n\t */\n\ttokenize(pExpression, pResultObject)\n\t{\n\t\treturn this.Tokenizer.tokenize(pExpression, pResultObject);\n\t}\n\n\t/**\n\t * Lints a tokenized expression.\n\t *\n\t * @param {Array} pTokenizedExpression - The tokenized expression to lint.\n\t * @param {Object} pResultObject - The result object where we store the linting result.\n\t * @returns {Object} - The linting result object.\n\t */\n\tlintTokenizedExpression(pTokenizedExpression, pResultObject)\n\t{\n\t\treturn this.Linter.lintTokenizedExpression(pTokenizedExpression, pResultObject);\n\t}\n\n\t/**\n\t * Builds a postfix solve list for the given tokenized expression and result object.\n\t *\n\t * @param {Array} pTokenizedExpression - The tokenized expression.\n\t * @param {Object} pResultObject - The result object where the algorithm \"shows its work\".\n\t * @returns {Array} The postfix solve list.\n\t */\n\tbuildPostfixedSolveList(pTokenizedExpression, pResultObject)\n\t{\n\t\treturn this.Postfix.buildPostfixedSolveList(pTokenizedExpression, pResultObject);\n\t}\n\n\t/**\n\t * Substitutes values in tokenized objects.\n\t *\n\t * This means marshaling data from pDataSource into the array of objects with the passed in Manifest (or a generic manifest) to prepare for solving.\n\t *\n\t * @param {Array} pTokenizedObjects - The array of tokenized objects.\n\t * @param {Object} pDataSource - The data source object.\n\t * @param {Object} pResultObject - The result object.\n\t * @param {Object} pManifest - The manifest object.\n\t * @returns {Object} - The updated result object.\n\t */\n\tsubstituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest)\n\t{\n\t\treturn this.ValueMarshal.substituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest);\n\t}\n\n\t/**\n\t * Solves a postfixed expression Array.\n\t *\n\t * @param {Array} pPostfixedExpression - The postfixed expression to solve.\n\t * @param {object} pDataDestinationObject - The data destination object where data gets marshaled to after solving.\n\t * @param {object} pResultObject - The result object where the algorithm \"shows its work\".\n\t * @param {object} pManifest - The manifest object.\n\t * @returns {any} The result of the solved expression.\n\t */\n\tsolvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest)\n\t{\n\t\treturn this.Solver.solvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest);\n\t}\n\n\t/**\n\t * Add a function to the solver.\n\t *\n\t * @param {string} pFunctionName \n\t * @param {string} pFunctionAddress \n\t * @param {string} pFunctionComment \n\t */\n\taddSolverFunction(pFunctionName, pFunctionAddress, pFunctionComment)\n\t{\n\t\tlet tmpFunctionName = (pFunctionName || '').trim().toLowerCase();\n\t\tif (this.functionMap.hasOwnProperty(tmpFunctionName))\n\t\t{\n\t\t\tthis.log.warn(`PictDynamicFormsInformary: Function ${tmpFunctionName} already exists in the solver, overwriting with address [${pFunctionAddress}].`);\n\t\t\t//return false;\n\t\t}\n\t\tthis.functionMap[tmpFunctionName] = (\n\t\t{\n\t\t\tName: pFunctionComment || `Autogenerated function ${tmpFunctionName}`,\n\t\t\tAddress: pFunctionAddress,\n\t\t});\n\t}\n\n\t/**\n\t * Prepares the parameters for a SERIES directive by substituting values and applying defaults.\n\t *\n\t * @param {Array} pParameters\n\t * @param {Array} pDefaults\n\t * @param {Object} pResultObject\n\t * @param {Object} pDataSourceObject\n\t * @param {import('manyfest')} [pManifest]\n\t */\n\t_prepareDirectiveParameters(pParameters, pDefaults, pResultObject, pDataSourceObject, pManifest)\n\t{\n\t\tconst tmpResults = [];\n\t\tfor (let i = 0; i < pParameters.length; i++)\n\t\t{\n\t\t\tconst tmpParameter = pParameters[i];\n\t\t\tlet tmpValue = this.fable.Math.parsePrecise(tmpParameter, NaN);\n\t\t\tif (isNaN(tmpValue) && typeof tmpParameter === 'string' && tmpParameter.length > 0)\n\t\t\t{\n\t\t\t\tconst tmpToken = this.fable.ExpressionParser.Postfix.getTokenContainerObject(tmpParameter, 'Token.Symbol');\n\t\t\t\tthis.substituteValuesInTokenizedObjects([tmpToken], pDataSourceObject, pResultObject, pManifest);\n\t\t\t\tif (tmpToken.Resolved)\n\t\t\t\t{\n\t\t\t\t\ttmpValue = tmpToken.Value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isNaN(tmpValue) && pDefaults.length > i)\n\t\t\t{\n\t\t\t\ttmpValue = pDefaults[i];\n\t\t\t}\n\t\t\ttmpResults.push(tmpValue);\n\t\t}\n\t\treturn tmpResults;\n\t}\n\n\t/**\n\t * Solves the given expression using the provided data and manifest.\n\t *\n\t * @param {string} pExpression - The expression to solve.\n\t * @param {Record<string, any>} [pDataSourceObject] - (optional) The data source object (e.g. AppData).\n\t * @param {Record<string, any>} [pResultObject] - (optional) The result object containing the full postfix expression list, internal variables and solver history.\n\t * @param {import('manyfest')} [pManifest] - (optional) The manifest object for dereferencing variables.\n\t * @param {Record<string, any>} [pDataDestinationObject] - (optional) The data destination object for where to marshal the result into.\n\t * @returns {any} - The result of solving the expression.\n\t */\n\tsolve(pExpression, pDataSourceObject, pResultObject, pManifest, pDataDestinationObject)\n\t{\n\t\tlet tmpResultsObject = (typeof(pResultObject) === 'object') ? pResultObject : {};\n\t\tlet tmpDataSourceObject = (typeof(pDataSourceObject) === 'object') ? pDataSourceObject : {};\n\t\tlet tmpDataDestinationObject = (typeof(pDataDestinationObject) === 'object') ? pDataDestinationObject : {};\n\n\t\t// This is technically a \"pre-compile\" and we can keep this Results Object around to reuse for better performance.  Not required.\n\t\tthis.tokenize(pExpression, tmpResultsObject);\n\n\t\t// Lint the tokenized expression to make sure it's valid\n\t\tthis.lintTokenizedExpression(tmpResultsObject.RawTokens, tmpResultsObject);\n\t\tthis.buildPostfixedSolveList(tmpResultsObject.RawTokens, tmpResultsObject);\n\n\t\tconst tmpManifest = (typeof(pManifest) === 'object') ? pManifest : this.fable.newManyfest();\n\t\tif (tmpResultsObject.SolverDirectives.Code == 'SERIES')\n\t\t{\n\t\t\tconst [ tmpStep , tmpFrom, tmpTo] = this._prepareDirectiveParameters([\n\t\t\t\ttmpResultsObject.SolverDirectives.Step,\n\t\t\t\ttmpResultsObject.SolverDirectives.From,\n\t\t\t\ttmpResultsObject.SolverDirectives.To,\n\t\t\t], [ '1' ], tmpResultsObject, tmpDataSourceObject, tmpManifest);\n\n\t\t\tif (isNaN(tmpFrom) || isNaN(tmpTo))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  FROM, TO must be numeric.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Make sure from/to are not equal\n\t\t\tif (this.fable.Math.comparePrecise(tmpFrom, tmpTo) == 0)\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  FROM and TO cannot be equal.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Make sure that Step is the correct positive/negative based on From and To\n\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') == 0)\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP cannot be zero.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (this.fable.Math.comparePrecise(tmpFrom, tmpTo) < 0)\n\t\t\t{\n\t\t\t\t// From < To so Step must be positive\n\t\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP must be positive when FROM < TO.`);\n\t\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// From >= To so Step must be negative\n\t\t\t\tif (this.fable.Math.comparePrecise(tmpStep, '0') > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid SERIES directive parameters.  STEP must be negative when FROM >= TO.`);\n\t\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get the number of iterations we need to perform\n\t\t\tlet tmpIterations = parseInt(this.fable.Math.floorPrecise(this.fable.Math.dividePrecise(this.fable.Math.subtractPrecise(tmpTo, tmpFrom), tmpStep)));\n\n\t\t\tlet tmpValueArray = [];\n\n\t\t\tfor (let i = 0; i <= tmpIterations; i++)\n\t\t\t{\n\t\t\t\tconst tmpCurrentValueOfN = this.fable.Math.addPrecise(tmpFrom, this.fable.Math.multiplyPrecise(tmpStep, i.toString()));\n\t\t\t\tconst tmpPreviousValueOfN = (i == 0) ? 'false' : this.fable.Math.addPrecise(tmpFrom, this.fable.Math.multiplyPrecise(tmpStep, (i - 1).toString()));\n\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.n = tmpCurrentValueOfN;\n\t\t\t\ttmpSeriesStepDataSourceObject.prev_n = tmpPreviousValueOfN;\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\n\t\t\t\ttmpValueArray.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpValueArray);\n\n\t\t\treturn tmpValueArray;\n\t\t}\n\t\telse if (tmpResultsObject.SolverDirectives.Code == 'MAP')\n\t\t{\n\t\t\t// The values to pull in -- this could be a map but affords better flexibility broken out like this.\n\t\t\tconst tmpDirectiveValues = tmpResultsObject.SolverDirectives.Values;\n\t\t\tconst tmpDirectiveValueKeys = tmpResultsObject.SolverDirectives.ValueKeys;\n\t\t\tlet tmpValueArray = [];\n\n\t\t\tfor (let i = 0; i < tmpDirectiveValueKeys.length; i++)\n\t\t\t{\n\t\t\t\tconst tmpVariableKey = tmpDirectiveValueKeys[i];\n\t\t\t\tconst tmpVariableDescription = tmpDirectiveValues[tmpVariableKey];\n\n\t\t\t\t// Get the actual value for this variable's address\n\t\t\t\ttmpVariableDescription.Value = tmpManifest.getValueByHash(tmpDataSourceObject, tmpVariableDescription.Address);\n\t\t\t}\n\n\t\t\t// If the first value doesn't have keys, don't do the map.\n\t\t\tif ((tmpDirectiveValueKeys.length < 1) || (tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value == null) || (!Array.isArray(tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value)))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid MAP directive parameters.  The first variable's address must resolve to an array.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tlet tmpControllingSet = tmpDirectiveValues[tmpDirectiveValueKeys[0]].Value;\n\n\t\t\tfor (let i = 0; i < tmpControllingSet.length; i++)\n\t\t\t{\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\tfor (let j = 0; j < tmpDirectiveValueKeys.length; j++)\n\t\t\t\t{\n\t\t\t\t\tconst tmpVariableKey = tmpDirectiveValueKeys[j];\n\t\t\t\t\tif (!Array.isArray(tmpDirectiveValues[tmpVariableKey].Value) || (tmpDirectiveValues[tmpVariableKey].Value.length <= i))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKey] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKey] = tmpDirectiveValues[tmpVariableKey].Value[i];\n\t\t\t\t\t}\n\t\t\t\t\tconst tmpPreviousValueKey = `prev_${tmpVariableKey}`;\n\t\t\t\t\tif (!Array.isArray(tmpDirectiveValues[tmpVariableKey].Value) || (tmpDirectiveValues[tmpVariableKey].Value.length <= i))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = 'false';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpPreviousValueKey] = tmpDirectiveValues[tmpVariableKey].Value[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\n\t\t\t\ttmpValueArray.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpValueArray);\n\n\t\t\treturn tmpValueArray;\n\t\t}\n\t\telse if (tmpResultsObject.SolverDirectives.Code == 'MONTECARLO')\n\t\t{\n\t\t\tconst [ tmpSampleCount ] = this._prepareDirectiveParameters([\n\t\t\t\ttmpResultsObject.SolverDirectives.SampleCount\n\t\t\t], [ '1' ], tmpResultsObject, tmpDataSourceObject, tmpManifest);\n\n\t\t\tif (isNaN(tmpSampleCount))\n\t\t\t{\n\t\t\t\ttmpResultsObject.ExpressionParserLog.push(`ExpressionParser.solve detected invalid MONTECARLO directive parameters.  SAMPLECOUNT must be numeric.`);\n\t\t\t\tthis.log.warn(tmpResultsObject.ExpressionParserLog[tmpResultsObject.ExpressionParserLog.length-1]);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet tmpMonteCarloOutput = JSON.parse(JSON.stringify(tmpResultsObject.SolverDirectives));\n\t\t\ttmpMonteCarloOutput.Samples = [];\n\n\t\t\t// Now go through each variable and prepare its object of values\n\t\t\tlet tmpVariableKeys = Object.keys(tmpMonteCarloOutput.Values);\n\t\t\tfor (let i = 0; i < tmpVariableKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpVariableKey = tmpVariableKeys[i];\n\t\t\t\tlet tmpVariableDescription = tmpMonteCarloOutput.Values[tmpVariableKey];\n\n\t\t\t\t// For each variable, generate its array of sampled values\n\t\t\t\ttmpVariableDescription.Distribution = {};\n\t\t\t\ttmpVariableDescription.ValueSequence = [];\n\n\t\t\t\t// Resolve the points if they are tokenized expressions\n\t\t\t\tconst tmpResolvedPoints = [];\n\t\t\t\tfor (let j = 0; j < tmpVariableDescription.Points.length; j++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPointToken = tmpVariableDescription.Points[j];\n\t\t\t\t\tlet tmpPointValue = this.fable.Math.parsePrecise(tmpPointToken, NaN);\n\t\t\t\t\tif (isNaN(tmpPointValue) && typeof tmpPointToken === 'string' && tmpPointToken.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPointValue = tmpManifest.getValueByHash(tmpDataSourceObject, tmpPointToken);\n\t\t\t\t\t\tif (!tmpPointValue || (tmpPointValue == null))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//TODO: Warn?\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResolvedPoints.push(tmpPointValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResolvedPoints.push(tmpPointToken);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now sort the resolved points\n\t\t\t\ttmpResolvedPoints.sort((a, b) => this.fable.Math.comparePrecise(a, b));\n\t\t\t\ttmpVariableDescription.ResolvedPoints = tmpResolvedPoints;\n\n\t\t\t\t// Just simple linear until we add more easing types in a separate library (refactoring the below out)\n\t\t\t\ttmpVariableDescription.FirstPoint = tmpVariableDescription.ResolvedPoints[0];\n\t\t\t\ttmpVariableDescription.DomainRangeStart = tmpVariableDescription.FirstPoint;\n\t\t\t\tif (tmpVariableDescription.ResolvedPoints.length < 2)\n\t\t\t\t{\n\t\t\t\t\ttmpVariableDescription.LastPoint = tmpVariableDescription.FirstPoint;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpVariableDescription.LastPoint = this.fable.Math.parsePrecise(tmpVariableDescription.ResolvedPoints[tmpVariableDescription.ResolvedPoints.length - 1], NaN);\n\t\t\t\t\tif (isNaN(tmpVariableDescription.LastPoint))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpVariableDescription.LastPoint = tmpVariableDescription.FirstPoint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpVariableDescription.DomainLength = this.fable.Math.subtractPrecise(tmpVariableDescription.LastPoint, tmpVariableDescription.FirstPoint);\n\t\t\t\t//this.fable.log.trace(`Monte Carlo variable ${tmpVariableKey} has first point ${tmpVariableDescription.FirstPoint}, last point ${tmpVariableDescription.LastPoint}, domain length ${tmpVariableDescription.DomainLength}`);\n\n\t\t\t\t// // This generation of data based on the resolved points (and easing type) should be abstracted.  Most require the same rules.\n\t\t\t\t// tmpVariableDescription.ResolvedPointDomainStarts = [];\n\t\t\t\t// tmpVariableDescription.DomainTranslationAmount = [];\n\n\t\t\t\t// // Get the length of each domain segment and the multiplier for them\n\t\t\t\t// tmpVariableDescription.DomainLength = this.fable.Math.subtractPrecise(tmpVariableDescription.ResolvedPoints[tmpVariableDescription.ResolvedPoints.length - 1], tmpVariableDescription.ResolvedPoints[0]);\n\t\t\t\t// tmpVariableDescription.DomainChunkCount = tmpVariableDescription.ResolvedPoints.length;\n\t\t\t\t// tmpVariableDescription.DomainStart = tmpVariableDescription.ResolvedPoints[0];\n\n\t\t\t\t// let tmpCurrentDomainPosition = tmpVariableDescription.DomainStart;\n\t\t\t\t// let tmpPreviousDomainTranslationAmount = '0';\n\t\t\t\t// for (let j = 0; j < tmpVariableDescription.ResolvedPoints.length; j++)\n\t\t\t\t// {\n\t\t\t\t// \tlet tmpResolvedPointValue = tmpVariableDescription.ResolvedPoints[j];\n\t\t\t\t// \t// Set the resolved point domain start\n\t\t\t\t// \ttmpVariableDescription.DomainTranslationAmount.push(this.fable.Math.dividePrecise(tmpResolvedPointValue, tmpVariableDescription.DomainLength));\n\t\t\t\t// \t// Push the previous translation amount as the start of this domain\n\t\t\t\t// \ttmpVariableDescription.ResolvedPointDomainStarts.push(tmpPreviousDomainTranslationAmount);\n\t\t\t\t// \t// Calculate the translation amount, for the start of the next domain\n\t\t\t\t// \ttmpPreviousDomainTranslationAmount = this.fable.Math.addPrecise(tmpPreviousDomainTranslationAmount, tmpVariableDescription.DomainLength);\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tfor (let i = 0; i <= Number(tmpSampleCount) - 1; i++)\n\t\t\t{\n\t\t\t\t// Jimmy up the data source with the current N value, stepIndex and all the other data from the source object\n\t\t\t\t// This generates a data source object every time on purpose so we can remarshal in values that changed in the destination\n\t\t\t\tlet tmpSeriesStepDataSourceObject = Object.assign({}, tmpDataSourceObject);\n\t\t\t\ttmpSeriesStepDataSourceObject.stepIndex = i;\n\n\t\t\t\t// Generate each value from the array of values\n\t\t\t\tfor (let j = 0; j < tmpVariableKeys.length; j++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPointManifestHash = tmpVariableKeys[j];\n\t\t\t\t\tlet tmpPointManifest = tmpMonteCarloOutput.Values[tmpPointManifestHash];\n\n\t\t\t\t\t// Generate the value for this sample variable\n\t\t\t\t\tlet tmpPointValue = this.fable.Math.generateValueFromEasingDescription(tmpPointManifest);\n\t\t\t\t\ttmpSeriesStepDataSourceObject[tmpVariableKeys[j]] = tmpPointValue;\n\t\t\t\t\ttmpPointManifest.ValueSequence.push(tmpPointValue);\n\n\t\t\t\t\t// We keep track of a distribution of generated values here for analysis later\n\t\t\t\t\tlet tmpDistributionRoundPrecision = tmpPointManifest.DistributionRoundPrecision || 0;\n\t\t\t\t\t// Log the value out\n\t\t\t\t\t//this.fable.log.info(`Monte Carlo variable ${tmpPointManifestHash} generated value ${tmpPointValue}`);\n\t\t\t\t\tlet tmpDistributionPointValue = this.fable.Math.roundPrecise(tmpPointValue, tmpDistributionRoundPrecision);\n\t\t\t\t\tif (!(tmpDistributionPointValue in tmpPointManifest.Distribution))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPointManifest.Distribution[tmpDistributionPointValue] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttmpPointManifest.Distribution[tmpDistributionPointValue] = tmpPointManifest.Distribution[tmpDistributionPointValue] + 1;\n\t\t\t\t}\n\n\t\t\t\tlet tmpMutatedValues = this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpSeriesStepDataSourceObject, tmpResultsObject, tmpManifest);\n\t\t\t\ttmpMonteCarloOutput.Samples.push( this.solvePostfixedExpression( tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, tmpManifest ) );\n\n\t\t\t\tfor (let j = 0; j < tmpMutatedValues.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMutatedValues[j].Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the assignment\n\t\t\tlet tmpAssignmentManifestHash = tmpResultsObject.PostfixedAssignmentAddress;\n\t\t\tif ((tmpResultsObject.OriginalRawTokens[1] === '=') && (typeof(tmpResultsObject.OriginalRawTokens[0]) === 'string') && (tmpResultsObject.OriginalRawTokens[0].length > 0))\n\t\t\t{\n\t\t\t\ttmpAssignmentManifestHash = tmpResultsObject.OriginalRawTokens[0];\n\t\t\t}\n\n\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, tmpAssignmentManifestHash, tmpMonteCarloOutput);\n\n\t\t\treturn tmpMonteCarloOutput;\n\t\t}\n\t\telse // For 'SOLVE' or anything else that didn't work\n\t\t{\n\t\t\t// This is where the data from variables gets marshaled into their symbols (from AppData or the like)\n\t\t\tthis.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects, tmpDataSourceObject, tmpResultsObject, pManifest);\n\t\t\t// Finally this is the expr solving method, which returns a string and also marshals it into tmpDataDestinationObject\n\t\t\treturn this.solvePostfixedExpression(tmpResultsObject.PostfixSolveList, tmpDataDestinationObject, tmpResultsObject, pManifest);\n\t\t}\n\t}\n}\n\nmodule.exports = FableServiceExpressionParser;\n","const libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nclass ExpressionParserOperationBase extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ExpressionParserOperationBase';\n\n\t\tthis.numberTest = /^-{0,1}\\d*\\.{0,1}\\d+$/;\n\n\t\tthis.ExpressionParser = false;\n\t}\n\n\tconnectExpressionParser(pExpressionParser)\n\t{\n\t\tthis.ExpressionParser = pExpressionParser;\n\t}\n\n\tgetTokenType(pToken)\n\t{\n\t\tif (pToken in this.ExpressionParser.tokenMap)\n\t\t{\n\t\t\treturn `Token.${this.ExpressionParser.tokenMap[pToken].Type}`;\n\t\t}\n\t\telse if ((pToken.length > 2) && (pToken[0] === '{') && (pToken[pToken.length-1] === '}'))\n\t\t{\n\t\t\treturn 'Token.StateAddress';\n\t\t}\n\t\telse if ((pToken.length > 1) && (pToken[0] === '\"') && (pToken[pToken.length-1] === '\"'))\n\t\t{\n\t\t\treturn 'Token.String';\n\t\t}\n\t\telse if (this.numberTest.test(pToken))\n\t\t{\n\t\t\treturn 'Token.Constant';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'Token.Symbol';\n\t\t}\n\t\t// Just for documentation sake:\n\t\t// There is a fifth token type, VirtualSymbol\n\t\t// This is a value that's added during solve and looked up by address in the VirtualSymbol object.\n\t}\n\n\tgetTokenContainerObject(pToken, pTokenType)\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tToken: pToken,\n\t\t\t\tType: (typeof(pTokenType) === 'undefined') ? this.getTokenType(pToken) : pTokenType,\n\t\t\t\tDescriptor: (pToken in this.ExpressionParser.tokenMap) ? this.ExpressionParser.tokenMap[pToken] : false\n\t\t\t});\n\t}\n}\n\nmodule.exports = ExpressionParserOperationBase;","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionTokenizerDirectiveMutation extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-TokenizerDirectiveMutation';\n\n\t\tthis.directiveTypes = (\n\t\t\t{\n\t\t\t\t'SOLVE': { Name: 'Solve Expression', Code: 'SOLVE' },\n\t\t\t\t'SERIES': { Name: 'Series', Code: 'SERIES', From: null, To: null, Step: null },\n\t\t\t\t'MONTECARLO': { Name: 'Monte Carlo Simulation', SampleCount: '1', Code: 'MONTECARLO', Values: {} },\n\t\t\t\t'MAP': { Name: 'Map', Code: 'MAP', Values: {}, ValueKeys: [] },\n\t\t\t});\n\n\t\tthis.defaultDirective = this.directiveTypes.SOLVE;\n\t}\n\n\tparseSeriesDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewSeriesDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.SERIES));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'FROM':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.From = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TO':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.To = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'STEP':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewSeriesDirectiveDescription.Step = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewSeriesDirectiveDescription;\n\t}\n\n\tparseMonteCarloDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewMonteCarloDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.MONTECARLO));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'SAMPLECOUNT':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.SampleCount = pTokens[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VARIABLE':\n\t\t\t\tcase 'VAR':\n\t\t\t\tcase 'V':\n\t\t\t\t\tif ((i + 1) < pTokens.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\t\tif (typeof(tmpVariableToken) === 'string' && (tmpVariableToken.length > 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken] = \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tToken: tmpVariableToken,\n\t\t\t\t\t\t\t\tEasing: 'Linear', // could be parametric, logarithmic, bezier, uniform, normal, etc.\n\t\t\t\t\t\t\t\tPoints: [] // array of values for points to generate between.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'POINT':\n\t\t\t\tcase 'PT':\n\t\t\t\tcase 'P':\n\t\t\t\t\tif (pTokens.length < i + 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpTokenIndexSkip = 2;\n\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\tif (tmpVariableToken in tmpNewMonteCarloDirectiveDescription.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableValueString = pTokens[i + 2];\n\t\t\t\t\t\tif ((tmpVariableValueString == '-') || (tmpVariableValueString == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pTokens.length < i + 3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpVariableValueString = tmpVariableValueString + pTokens[i + 3];\n\t\t\t\t\t\t\ttmpTokenIndexSkip = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet tmpVariableValue = this.fable.Math.parsePrecise(tmpVariableValueString, NaN);\n\t\t\t\t\t\tif (!isNaN(tmpVariableValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken].Points.push(tmpVariableValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = i + tmpTokenIndexSkip;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EASING':\n\t\t\t\t\tif (pTokens.length < i + 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpVariableToken = pTokens[i + 1];\n\t\t\t\t\tlet tmpEasingType = pTokens[i + 2].toUpperCase();\n\t\t\t\t\tif (tmpVariableToken in tmpNewMonteCarloDirectiveDescription.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpNewMonteCarloDirectiveDescription.Values[tmpVariableToken].Easing = tmpEasingType;\n\t\t\t\t\t}\n\t\t\t\t\ti = i + 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewMonteCarloDirectiveDescription;\n\t}\n\n\tparseMapDirective(pTokens)\n\t{\n\t\t// This isn't a fancy real parse it's just taking words and stealing values after them.\n\t\tlet tmpNewMapDirectiveDescription = JSON.parse(JSON.stringify(this.directiveTypes.MAP));\n\n\t\tfor (let i = 0; i < pTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pTokens[i].toUpperCase();\n\t\t\tswitch(tmpToken)\n\t\t\t{\n\t\t\t\tcase 'VARIABLE':\n\t\t\t\tcase 'VAR':\n\t\t\t\tcase 'V':\n\t\t\t\t\tif (((i + 3) < pTokens.length) && (pTokens[i+2].toUpperCase() == 'FROM'))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpVariableToken = pTokens[i + 1];\n\t\t\t\t\t\tif (typeof(tmpVariableToken) === 'string' && (tmpVariableToken.length > 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpNewMapDirectiveDescription.ValueKeys.push(tmpVariableToken);\n\t\t\t\t\t\t\ttmpNewMapDirectiveDescription.Values[tmpVariableToken] = \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tToken: tmpVariableToken,\n\t\t\t\t\t\t\t\tAddress: pTokens[i + 3],\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti = i + 3;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Ignore other tokens\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpNewMapDirectiveDescription;\n\t}\n\n\tparseDirectives(pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.SolverDirectives = this.defaultDirective;\n\t\ttmpResults.SolverDirectiveTokens = [];\n\n\t\tif (tmpResults.RawTokens.length < 2)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation postprocessor received insufficient tokens to process directives.`);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn tmpResults.SolverDirectives;\n\t\t}\n\n\t\t// Enumerate each of the tmpResults.RawTokens to see if one of the values in the directiveTypeMap exists and is either at the beginning or after the assignment (= or ?=) operator\n\t\tfor (let i = 0; i < tmpResults.RawTokens.length; i++)\n\t\t{\n\t\t\tlet tmpToken = tmpResults.RawTokens[i].toUpperCase();\n\t\t\tif (tmpToken in this.directiveTypes)\n\t\t\t{\n\t\t\t\t// Check if it's at the beginning or after an assignment operator\n\t\t\t\t// FIXME: This is hard coded assignment operators which is bad juju\n\t\t\t\tif ((i === 0) || (tmpResults.RawTokens[i-1] === '=') || (tmpResults.RawTokens[i-1] === '?='))\n\t\t\t\t{\n\t\t\t\t\t// We have a directive!\n\t\t\t\t\ttmpResults.SolverDirectives.Type = this.directiveTypes[tmpToken];\n\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation identified solver directive: ${tmpToken}`);\n\t\t\t\t\t//this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\n\t\t\t\t\t// Extract the Directive name and everything else from it up until the : token\n\t\t\t\t\tlet tmpDirectiveTokenStartIndex = i;\n\t\t\t\t\tlet tmpDirectiveTokenEndIndex = -1;\n\t\t\t\t\tfor (let j = tmpDirectiveTokenStartIndex + 1; j < tmpResults.RawTokens.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpResults.RawTokens[j] === ':')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDirectiveTokenEndIndex = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the directive token end is not in the expression we don't know what to do\n\t\t\t\t\tif (tmpDirectiveTokenEndIndex === -1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenizeDirectiveMutation could not find the end of the directive token set for directive: ${tmpToken}`);\n\t\t\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the tmpResults.SolverDirectiveTokens to the slice of tokens that represent the directive\n\t\t\t\t\ttmpResults.SolverDirectiveTokens = tmpResults.RawTokens.slice(tmpDirectiveTokenStartIndex, tmpDirectiveTokenEndIndex);\n\n\t\t\t\t\t// Remove the directive tokens and the assignment to the left of it from the array of raw tokens\n\t\t\t\t\t// the colonoscopy if you will\n\t\t\t\t\ttmpResults.RawTokens.splice(0, tmpDirectiveTokenEndIndex + 1);\n\n\t\t\t\t\t// Further parsing based on directive type could go here\n\t\t\t\t\t// e.g. parseSeriesDirective for SERIES, etc.\n\t\t\t\t\tswitch(tmpToken)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'SERIES':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseSeriesDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MONTECARLO':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseMonteCarloDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MAP':\n\t\t\t\t\t\t\ttmpResults.SolverDirectives = this.parseMapDirective(tmpResults.SolverDirectiveTokens);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// No further parsing needed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResults.SolverDirectives;\n\t}\n}\n\nmodule.exports = ExpressionTokenizerDirectiveMutation;\n","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionTokenizer extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Tokenizer';\n\t}\n\n\ttokenize(pExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.RawExpression = pExpression;\n\t\ttmpResults.SolverDirectives = {};\n\t\ttmpResults.RawTokens = [];\n\t\ttmpResults.ExpressionParserLog = [];\n\n\t\tif (typeof(pExpression) !== 'string')\n\t\t{\n\t\t\tthis.log.warn('ExpressionParser.tokenize was passed a non-string expression.');\n\t\t\treturn tmpResults.RawTokens;\n\t\t}\n\n\t\t/* Tokenize the expression\n\t\t *\n\t\t * Current token types:\n\t\t * \t- Value\n\t\t *    : could be a symbol representation e.g. \"x\", \"depth\", \"Cost\", etc. --- symbol representations are looked up first as manifest hashes\n\t\t *    : could be a number e.g. \"5\", \"3.14159\", etc.\n\t\t *    : could be a function name e.g. sin(x), sqrt(3+5) where sin or sqrt are known function names\n\t\t *  - StateAddress\n\t\t *    : these are always wrapped in squiggly brackets\n\t\t *    : e.g. {Moisture.Percentage}, {Ending.Temperature.Fahrenheit}, {AppData.Download.Size}, etc.\n\t\t *  - Token\n\t\t *    : could be an operator e.g. \"+\", \"-\", \"*\", \"/\"\n\t\t *    : could be a parenthesis e.g. \"(\", \")\"\n\t\t *  - String\n\t\t *    : Wrapped in double quotes e.g. \"Hello World\", \"This is a test\", etc.\n\t\t */\n\t\t/** @type {any} */\n\t\tlet tmpCurrentTokenType = false;\n\t\tlet tmpCurrentToken = '';\n\t\tfor (let i = 0; i < pExpression.length; i++)\n\t\t{\n\t\t\tlet tmpCharacter = pExpression[i];\n\n\t\t\t// [ WHITESPACE ]\n\t\t\t// 1. Space breaks tokens except when we're in an address that's been scoped by a {} or \"\"\n\t\t\tif ((tmpCharacter === ' ' || tmpCharacter === '\\t') && ((tmpCurrentTokenType !== 'StateAddress') && (tmpCurrentTokenType !== 'String')))\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// [ STATE ADDRESS AND STRING BLOCKS ]\n\t\t\t// 2. If we're in an address, we keep going until we hit the closing brace\n\t\t\tif ((tmpCurrentTokenType === 'StateAddress') && (tmpCharacter !== '}'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType === 'String') && (tmpCharacter !== '\"'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 3. If we're in an address and we hit the closing brace, we close the token, push it and reset\n\t\t\tif ((tmpCurrentTokenType === 'StateAddress') && (tmpCharacter === '}'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType === 'String') && (tmpCharacter === '\"'))\n\t\t\t{\n\t\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 4. If we're not in an address and we hit a closing brace it's a problem\n\t\t\t//    TODO: Should we just ignore it?  We do at the moment.\n\t\t\tif (tmpCharacter == '}')\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ExpressionParser.tokenize found a closing brace without an opening brace in the expression: ${pExpression} at character index ${i}`);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 5. If we're not in an address and we hit an opening brace, we start an address\n\t\t\tif (tmpCharacter == '{')\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = 'StateAddress';\n\t\t\t\ttmpCurrentToken = tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((tmpCurrentTokenType !== 'String') && (tmpCharacter == '\"'))\n\t\t\t{\n\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t}\n\t\t\t\ttmpCurrentToken = '';\n\t\t\t\ttmpCurrentTokenType = 'String';\n\t\t\t\ttmpCurrentToken = tmpCharacter;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// [ TOKENS ]\n\t\t\tif (tmpCharacter in this.ExpressionParser.tokenRadix)\n\t\t\t{\n\t\t\t\tlet tmpTokenRadix = this.ExpressionParser.tokenRadix[tmpCharacter];\n\t\t\t\t// If the token is a literal and has only one entry, it is a single character token and we can just safely add it.\n\t\t\t\tif (tmpTokenRadix.TokenCount == 1 && tmpTokenRadix.Literal)\n\t\t\t\t{\n\t\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t\t\t\t}\n\t\t\t\t\ttmpCurrentToken = '';\n\t\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\t\ttmpResults.RawTokens.push(tmpCharacter);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// This one has multiple options, so literals don't matter.  We need to check the token map.\n\t\t\t\t\t// The token radix TokenKeys array is sorted longest to shortest\n\t\t\t\t\tfor (let j = 0; j < tmpTokenRadix.TokenKeys.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpTokenKey = tmpTokenRadix.TokenKeys[j];\n\t\t\t\t\t\tif (pExpression.substr(i, tmpTokenKey.length) == tmpTokenKey)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpCurrentToken.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpResults.RawTokens.push(tmpTokenKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpCurrentToken = '';\n\t\t\t\t\t\t\ttmpCurrentTokenType = false;\n\t\t\t\t\t\t\ttmpResults.RawTokens.push(tmpTokenKey);\n\t\t\t\t\t\t\ti += tmpTokenKey.length - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If it's not an operator, it's a number or address.\n\t\t\t// At the moment we aren't going to gate it on whether it's a valid address or not\n\t\t\t// Just treat anything not a known token on its own as a value identifier\n\n\t\t\t/* Per this stack overflow article: https://stackoverflow.com/questions/4434076/best-way-to-alphanumeric-check-in-javascript\n\t\t\t * We could use a regex but it is slower than the charCodeAt method.\n\t\t\t * This also doesn't solve the problem of unicode characters, but we won't support those for now.\n\t\t\t */\n\t\t\t// if (pExpression.charAt(i) == '.')\n\t\t\t// {\n\t\t\t// \tconsole.log('Found a period')\n\t\t\t// }\n\t\t\t// let tmpCharCode = pExpression.charCodeAt(i);\n\t\t\t// // Match that the character code is any of...\n\t\t\t// if (\n\t\t\t// \t// Number [0-9]\n\t\t\t// \t(tmpCharCode > 47 && tmpCharCode < 58)\n\t\t\t// \t// Upper Case\n\t\t\t// \t|| (tmpCharCode > 64 && tmpCharCode < 91)\n\t\t\t// \t// LOWER CASE\n\t\t\t// \t|| (tmpCharCode > 96 && tmpCharCode < 123)\n\t\t\t// \t)\n\t\t\t// {\n\n\t\t\t\t// NOTE: Not having this guard makes a lot of interesting things possible.\n\t\t\ttmpCurrentTokenType = 'Value';\n\t\t\ttmpCurrentToken += tmpCharacter;\n\t\t\t// \tcontinue;\n\t\t\t// }\n\n\t\t\t// tmpResults.ExpressionParserLog.push(`ExpressionParser.tokenize found an unknown character code ${tmpCharCode} character ${tmpCharacter} in the expression: ${pExpression} at index ${i}`);\n\t\t\t// this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\tif ((tmpCurrentTokenType) && (tmpCurrentToken.length > 0))\n\t\t{\n\t\t\ttmpResults.RawTokens.push(tmpCurrentToken);\n\t\t}\n\n\t\ttmpResults.OriginalRawTokens = Array.from(tmpResults.RawTokens);\n\n\t\t// Potentially mutate the tokens based on directives in the tokenized expression\n\t\tthis.TokenizerDirectiveMutation.parseDirectives(tmpResults);\n\n\t\treturn tmpResults.RawTokens;\n\t}\n}\n\nmodule.exports = ExpressionTokenizer;\n","module.exports={\n\t\"sqrt\": {\n\t\t\"Name\": \"Square Root\",\n\t\t\"Address\": \"fable.Math.sqrtPrecise\"\n\t},\n\n\t\"percent\": {\n\t\t\"Name\": \"Compute Percent (in IS over OF format)\",\n\t\t\"Address\": \"fable.Math.percentagePrecise\"\n\t},\n\n\t\"compare\": {\n\t\t\"Name\": \"Compare\",\n\t\t\"Address\": \"fable.Math.comparePrecise\"\n\t},\n\n\t\"abs\": {\n\t\t\"Name\": \"Absolute Value\",\n\t\t\"Address\": \"fable.Math.absPrecise\"\n\t},\n\t\"floor\": {\n\t\t\"Name\": \"Floor Value\",\n\t\t\"Address\": \"fable.Math.floorPrecise\"\n\t},\n\t\"ceil\": {\n\t\t\"Name\": \"Ceiling Value\",\n\t\t\"Address\": \"fable.Math.ceilPrecise\"\n\t},\n\n\t\"rad\": {\n\t\t\"Name\": \"Degrees to Radians\",\n\t\t\"Address\": \"fable.Math.radPrecise\"\n\t},\n\n\t\"pi\": {\n\t\t\"Name\": \"Pi\",\n\t\t\"Address\": \"fable.Math.piPrecise\"\n\t},\n\t\"euler\": {\n\t\t\"Name\": \"Euler\",\n\t\t\"Address\": \"fable.Math.eulerPrecise\"\n\t},\n\n\t\"log\": {\n\t\t\"Name\": \"Logarithm\",\n\t\t\"Address\": \"fable.Math.logPrecise\"\n\t},\n\t\"exp\": {\n\t\t\"Name\": \"Eulers Number to the Power Of N\",\n\t\t\"Address\": \"fable.Math.expPrecise\"\n\t},\n\n\n\t\"sin\": {\n\t\t\"Name\": \"Sine\",\n\t\t\"Address\": \"fable.Math.sin\"\n\t},\n\t\"cos\": {\n\t\t\"Name\": \"Cosine\",\n\t\t\"Address\": \"fable.Math.cos\"\n\t},\n\t\"tan\": {\n\t\t\"Name\": \"Tangent\",\n\t\t\"Address\": \"fable.Math.tan\"\n\t},\n\n\t\"count\": {\n\t\t\"Name\": \"Count Set Elements\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\t\"countset\": {\n\t\t\"Name\": \"Count Set Elements\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\t\"sortset\": {\n\t\t\"Name\": \"Sort Set\",\n\t\t\"Address\": \"fable.Math.sortSetPrecise\"\n\t},\n\t\"bucketset\": {\n\t\t\"Name\": \"Bucket Set\",\n\t\t\"Address\": \"fable.Math.bucketSetPrecise\"\n\t},\n\t\"sorthistogram\": {\n\t\t\"Name\": \"Sort Histogram\",\n\t\t\"Address\": \"fable.Math.sortHistogramPrecise\"\n\t},\n\t\"sorthistogrambykeys\": {\n\t\t\"Name\": \"Sort Histogram by Keys\",\n\t\t\"Address\": \"fable.Math.sortHistogramByKeys\"\n\t},\n\n\t\"max\": {\n\t\t\"Name\": \"Maximum\",\n\t\t\"Address\": \"fable.Math.maxPrecise\"\n\t},\n\t\"min\": {\n\t\t\"Name\": \"Minimum\",\n\t\t\"Address\": \"fable.Math.minPrecise\"\n\t},\n\n\t\"sum\": {\n\t\t\"Name\": \"Sum\",\n\t\t\"Address\": \"fable.Math.sumPrecise\"\n\t},\n\n\t\"avg\": {\n\t\t\"Name\": \"Average\",\n\t\t\"Address\": \"fable.Math.averagePrecise\"\n\t},\n\t\"mean\": {\n\t\t\"Name\": \"Mean\",\n\t\t\"Address\": \"fable.Math.meanPrecise\"\n\t},\n\t\"median\": {\n\t\t\"Name\": \"Median\",\n\t\t\"Address\": \"fable.Math.medianPrecise\"\n\t},\n\t\"mode\": {\n\t\t\"Name\": \"Mode\",\n\t\t\"Address\": \"fable.Math.modePrecise\"\n\t},\n\t\"var\": {\n\t\t\"Name\": \"Variance (Sample)\",\n\t\t\"Address\": \"fable.Math.variancePrecise\"\n\t},\n\t\"vara\": {\n\t\t\"Name\": \"Variance (Sample)\",\n\t\t\"Address\": \"fable.Math.variancePrecise\"\n\t},\n\t\"varp\": {\n\t\t\"Name\": \"Variance (Population)\",\n\t\t\"Address\": \"fable.Math.populationVariancePrecise\"\n\t},\n\t\"stdev\": {\n\t\t\"Name\": \"Standard Deviation (Sample)\",\n\t\t\"Address\": \"fable.Math.standardDeviationPrecise\"\n\t},\n\t\"stdeva\": {\n\t\t\"Name\": \"Standard Deviation (Sample)\",\n\t\t\"Address\": \"fable.Math.standardDeviationPrecise\"\n\t},\n\t\"stdevp\": {\n\t\t\"Name\": \"Standard Deviation (Population)\",\n\t\t\"Address\": \"fable.Math.populationStandardDeviationPrecise\"\n\t},\n\t\"round\": {\n\t\t\"Name\": \"Round\",\n\t\t\"Address\": \"fable.Math.roundPrecise\"\n\t},\n\t\"tofixed\": {\n\t\t\"Name\": \"To Fixed\",\n\t\t\"Address\": \"fable.Math.toFixedPrecise\"\n\t},\n\n\t\"cumulativesummation\": {\n\t\t\"Name\": \"Sum each value in a Histogram or Value Map cumulatively, creating or setting a property with the result on each row\",\n\t\t\"Address\": \"fable.Math.cumulativeSummation\"\n\t},\n\n\t\"subtractingsummation\": {\n\t\t\"Name\": \"Subtract each subsequent value in a Histogram or Value Map cumulatively (by default from the first row), creating or setting a property with the result on each row.\",\n\t\t\"Address\": \"fable.Math.subtractingSummation\"\n\t},\n\n\t\"iterativeseries\": {\n\t\t\"Name\": \"Perform an Iterative Series of Mathematical Operations on Set Elements\",\n\t\t\"Address\": \"fable.Math.iterativeSeries\"\n\t},\n\n\t\"countsetelements\": {\n\t\t\"Name\": \"Count Set Elements in a Histogram or Value Map\",\n\t\t\"Address\": \"fable.Math.countSetElements\"\n\t},\n\n\t\"getvalue\": {\n\t\t\"Name\": \"Get Value from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.getInternalValueByHash\"\n\t},\n\n\t\"setvalue\": {\n\t\t\"Name\": \"Set Value to Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.setInternalValueByHash\"\n\t},\n\n\t\"objectkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"objectvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\t\"generatearrayofobjectsfromsets\": {\n\t\t\"Name\": \"Generate Array of Objects from Sets\",\n\t\t\"Address\": \"fable.Utility.generateArrayOfObjectsFromSets\"\n\t},\n\t\"objectvaluessortbyexternalobjectarray\": {\n\t\t\"Name\": \"Get Array of an Object's values sorted by an external array\",\n\t\t\"Address\": \"fable.Utility.objectValuesSortByExternalArray\"\n\t},\n\t\"setkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"setvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\t\"histogramkeystoarray\": {\n\t\t\"Name\": \"Get Array of an Object's keys\",\n\t\t\"Address\": \"fable.Utility.objectKeysToArray\"\n\t},\n\t\"histogramvaluestoarray\": {\n\t\t\"Name\": \"Get Array of an Object's values\",\n\t\t\"Address\": \"fable.Utility.objectValuesToArray\"\n\t},\n\n\t\"createarrayfromabsolutevalues\": {\n\t\t\"Name\": \"Create Array from Absolute Values\",\n\t\t\"Address\": \"fable.Utility.createArrayFromAbsoluteValues\"\n\t},\n\n\t\"flatten\": {\n\t\t\"Name\": \"flatten an array of values\",\n\t\t\"Address\": \"fable.Utility.flattenArrayOfSolverInputs\"\n\t},\n\n\t\"findfirstvaluebyexactmatch\": {\n\t\t\"Name\": \"find + map on array of objects\",\n\t\t\"Address\": \"fable.Utility.findFirstValueByExactMatchInternal\"\n\t},\n\n\t\"findfirstvaluebystringincludes\": {\n\t\t\"Name\": \"find + map on array of objects\",\n\t\t\"Address\": \"fable.Utility.findFirstValueByStringIncludesInternal\"\n\t},\n\n\t\"match\": {\n\t\t\"Name\": \"Implementation of sheets MATCH() function\",\n\t\t\"Address\": \"fable.Utility.findIndexInternal\"\n\t},\n\n\t\"resolvehtmlentities\": {\n\t\t\"Name\": \"resolve HTML entities\",\n\t\t\"Address\": \"fable.DataFormat.resolveHtmlEntities\"\n\t},\n\n\t\"concat\": {\n\t\t\"Name\": \"concatenate an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.concatenateStringsInternal\"\n\t},\n\n\t\"concatraw\": {\n\t\t\"Name\": \"concatenate an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.concatenateStringsRawInternal\"\n\t},\n\n\t\"arrayconcat\": {\n\t\t\"Name\": \"concatenate two or more arrays generating a single output array\",\n\t\t\"Address\": \"fable.Utility.concatenateArrays\"\n\t},\n\n\t\"join\": {\n\t\t\"Name\": \"join an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.joinStringsInternal\"\n\t},\n\n\t\"joinraw\": {\n\t\t\"Name\": \"join an array of values and output a string\",\n\t\t\"Address\": \"fable.DataFormat.joinStringsRawInternal\"\n\t},\n\n\t\"if\": {\n\t\t\"Name\": \"perform a conditional operator on two values, and choose one of two outcomes based on the result\",\n\t\t\"Address\": \"fable.Logic.checkIf\"\n\t},\n\n\t\"when\": {\n\t\t\"Name\": \"perform a 'truthy' check on one value, and return one of two outcomes based on the result\",\n\t\t\"Address\": \"fable.Logic.when\"\n\t},\n\n\t\"entryinset\": {\n\t\t\"Name\": \"Entry in Set\",\n\t\t\"Address\": \"fable.Math.entryInSet\"\n\t},\n\t\"smallestinset\": {\n\t\t\"Name\": \"Smallest in Set\",\n\t\t\"Address\": \"fable.Math.smallestInSet\"\n\t},\n\t\"largestinset\": {\n\t\t\"Name\": \"Largest in Set\",\n\t\t\"Address\": \"fable.Math.largestInSet\"\n\t},\n\n\t\"aggregationhistogram\": {\n\t\t\"Name\": \"Generate a Histogram by Exact Value Aggregation\",\n\t\t\"Address\": \"fable.Math.histogramAggregationByExactValueFromInternalState\"\n\t},\n\t\"aggregationhistogrambyobject\": {\n\t\t\"Name\": \"Generate a Histogram by Exact Value Aggregation from Object Property\",\n\t\t\"Address\": \"fable.Math.histogramAggregationByExactValue\"\n\t},\n\t\"distributionhistogram\": {\n\t\t\"Name\": \"Generate a Histogram Based on Value Distribution\",\n\t\t\"Address\": \"fable.Math.histogramDistributionByExactValueFromInternalState\"\n\t},\n\t\"distributionhistogrambyobject\": {\n\t\t\"Name\": \"Generate a Histogram Based on Value Distribution from Object Property\",\n\t\t\"Address\": \"fable.Math.histogramDistributionByExactValue\"\n\t},\n\n\t\"setconcatenate\": {\n\t\t\"Name\": \"Set Concatenate\",\n\t\t\"Address\": \"fable.Math.setConcatenate\"\n\t},\n\n\t\"getvaluearray\": {\n\t\t\"Name\": \"Get Value Array from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.createValueArrayByHashParametersFromInternal\"\n\t},\n\t\"getvalueobject\": {\n\t\t\"Name\": \"Get Value Object from Application State or Services (AppData, etc.)\",\n\t\t\"Address\": \"fable.Utility.createValueObjectByHashParametersFromInternal\"\n\t},\n\n\t\"cleanvaluearray\": {\n\t\t\"Name\": \"Clean Value Array\",\n\t\t\"Address\": \"fable.Math.cleanValueArray\"\n\t},\n\t\"cleanvalueobject\": {\n\t\t\"Name\": \"Clean Value Object\",\n\t\t\"Address\": \"fable.Math.cleanValueObject\"\n\t},\n\n\t\"polynomialregression\": {\n\t\t\"Name\": \"Perform an nth degree Polynomial Regression on a Set of X and Y Values\",\n\t\t\"Address\": \"fable.Math.polynomialRegression\"\n\t},\n\n\t\"randominteger\": {\n\t\t\"Name\": \"Random Integer\",\n\t\t\"Address\": \"fable.DataGeneration.randomInteger\"\n\t},\n\t\"randomintegerbetween\": {\n\t\t\"Name\": \"Random Integer Between Two Numbers\",\n\t\t\"Address\": \"fable.DataGeneration.randomIntegerBetween\"\n\t},\n\t\"randomintegerupto\": {\n\t\t\"Name\": \"Random Integer\",\n\t\t\"Address\": \"fable.DataGeneration.randomIntegerUpTo\"\n\t},\n\t\"randomfloat\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloat\"\n\t},\n\t\"randomfloatbetween\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloatBetween\"\n\t},\n\t\"randomfloatupto\": {\n\t\t\"Name\": \"Random Float\",\n\t\t\"Address\": \"fable.DataGeneration.randomFloatUpTo\"\n\t},\n\n\t\"datemilliseconddifference\": {\n\t\t\"Name\": \"Date Difference in Milliseconds\",\n\t\t\"Address\": \"fable.Dates.dateMillisecondDifference\"\n\t},\n\t\"dateseconddifference\": {\n\t\t\"Name\": \"Date Difference in Seconds\",\n\t\t\"Address\": \"fable.Dates.dateSecondDifference\"\n\t},\n\t\"dateminutedifference\": {\n\t\t\"Name\": \"Date Difference in Minutes\",\n\t\t\"Address\": \"fable.Dates.dateMinuteDifference\"\n\t},\n\t\"datehourdifference\": {\n\t\t\"Name\": \"Date Difference in Hours\",\n\t\t\"Address\": \"fable.Dates.dateHourDifference\"\n\t},\n\t\"datedaydifference\": {\n\t\t\"Name\": \"Date Difference in Days\",\n\t\t\"Address\": \"fable.Dates.dateDayDifference\"\n\t},\n\t\"dateweekdifference\": {\n\t\t\"Name\": \"Date Difference in Weeks\",\n\t\t\"Address\": \"fable.Dates.dateWeekDifference\"\n\t},\n\t\"datemonthdifference\": {\n\t\t\"Name\": \"Date Difference in Months\",\n\t\t\"Address\": \"fable.Dates.dateMonthDifference\"\n\t},\n\t\"dateyeardifference\": {\n\t\t\"Name\": \"Date Difference in Years\",\n\t\t\"Address\": \"fable.Dates.dateYearDifference\"\n\t},\n\n\t\"datemathadd\": {\n\t\t\"Name\": \"Date Math Add\",\n\t\t\"Address\": \"fable.Dates.dateMath\"\n\t},\n\t\"dateaddmilliseconds\": {\n\t\t\"Name\": \"Date Add Milliseconds\",\n\t\t\"Address\": \"fable.Dates.dateAddMilliseconds\"\n\t},\n\t\"dateaddseconds\": {\n\t\t\"Name\": \"Date Add Seconds\",\n\t\t\"Address\": \"fable.Dates.dateAddSeconds\"\n\t},\n\t\"dateaddminutes\": {\n\t\t\"Name\": \"Date Add Minutes\",\n\t\t\"Address\": \"fable.Dates.dateAddMinutes\"\n\t},\n\t\"dateaddhours\": {\n\t\t\"Name\": \"Date Add Hours\",\n\t\t\"Address\": \"fable.Dates.dateAddHours\"\n\t},\n\t\"dateadddays\": {\n\t\t\"Name\": \"Date Add Days\",\n\t\t\"Address\": \"fable.Dates.dateAddDays\"\n\t},\n\t\"dateaddweeks\": {\n\t\t\"Name\": \"Date Add Weeks\",\n\t\t\"Address\": \"fable.Dates.dateAddWeeks\"\n\t},\n\t\"dateaddmonths\": {\n\t\t\"Name\": \"Date Add Months\",\n\t\t\"Address\": \"fable.Dates.dateAddMonths\"\n\t},\n\t\"dateaddyears\": {\n\t\t\"Name\": \"Date Add Years\",\n\t\t\"Address\": \"fable.Dates.dateAddYears\"\n\t},\n\n\t\"datefromparts\": {\n\t\t\"Name\": \"Date From Parts\",\n\t\t\"Address\": \"fable.Dates.dateFromParts\"\n\t},\n\n\t\"slice\": {\n\t\t\"Name\": \"Slice Array\",\n\t\t\"Address\": \"fable.Utility.slice\"\n\t},\n\n\t\"createvalueobjectbyhashes\": {\n\t\t\"Name\": \"Create Value Object by Hashes\",\n\t\t\"Address\": \"fable.Utility.createValueObjectByHashes\"\n\t},\n\n\t\"polynomialregression\": {\n\t\t\"Name\": \"Perform an nth degree Polynomial Regression on a Set of X and Y Values\",\n\t\t\"Address\": \"fable.Math.polynomialRegression\"\n\t},\n\t\"leastsquares\": {\n\t\t\"Name\": \"Perform a Least Squares Regression on a Set of Independent Variable Vectors and a Dependent Variable Vector\",\n\t\t\"Address\": \"fable.Math.leastSquares\"\n\t},\n\t\"linest\": {\n\t\t\"Name\": \"Perform a Least Squares Regression on a Set of Independent Variable Vectors and a Dependent Variable Vector\",\n\t\t\"Address\": \"fable.Math.leastSquares\"\n\t},\n\n\t\"matrixtranspose\": {\n\t\t\"Name\": \"Transpose a Matrix\",\n\t\t\"Address\": \"fable.Math.matrixTranspose\"\n\t},\n\t\"matrixmultiply\": {\n\t\t\"Name\": \"Multiply Two Matrices\",\n\t\t\"Address\": \"fable.Math.matrixMultiply\"\n\t},\n\t\"matrixvectormultiply\": {\n\t\t\"Name\": \"Multiply a Matrix by a Vector\",\n\t\t\"Address\": \"fable.Math.matrixVectorMultiply\"\n\t},\n\t\"matrixinverse\": {\n\t\t\"Name\": \"Inverse a Matrix\",\n\t\t\"Address\": \"fable.Math.matrixInverse\"\n\t},\n\t\"gaussianelimination\": {\n\t\t\"Name\": \"Solve a System of Linear Equations using Gaussian Elimination\",\n\t\t\"Address\": \"fable.Math.gaussianElimination\"\n\t},\n\t\"predict\": {\n\t\t\"Name\": \"Predict Y Values from X Values using a Regression Model\",\n\t\t\"Address\": \"fable.Math.predictFromRegressionModel\"\n\t},\n\n\t\"stringcountsegments\": {\n\t\t\"Name\": \"Count Segments in a String\",\n\t\t\"Address\": \"fable.DataFormat.stringCountSegments\"\n\t},\n\t\"stringgetsegments\": {\n\t\t\"Name\": \"Get Segments from a String\",\n\t\t\"Address\": \"fable.DataFormat.stringGetSegments\"\n\t},\n\n\t\"bezierpoint\": {\n\t\t\"Name\": \"Evaluate a Point on a Cubic Bezier Curve at Parameter t\",\n\t\t\"Address\": \"fable.Math.bezierPoint\"\n\t},\n\t\"beziercurvefit\": {\n\t\t\"Name\": \"Fit a Cubic Bezier Curve to a Set of Data Points\",\n\t\t\"Address\": \"fable.Math.bezierCurveFit\"\n\t}\n}\n","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserLinter extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Linter';\n\t}\n\n\tlintTokenizedExpression(pTokenizedExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.LinterResults = [];\n\n\t\t// Guard against bad data being passed in\n\t\tif (!Array.isArray(pTokenizedExpression))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression was passed a non-array tokenized expression.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedExpression;\n\t\t}\n\t\tif (pTokenizedExpression.length < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression was passed an empty tokenized expression.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedExpression;\n\t\t}\n\n\t\t// 1. Check for balanced parenthesis\n\t\tlet tmpParenthesisDepth = 0;\n\t\t// If it is in a state address, we don't care about the parenthesis\n\t\t// State addresses are between squiggly brackets\n\t\tlet tmpInStateAddress = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((pTokenizedExpression[i] === '(') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpParenthesisDepth++;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === ')') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpParenthesisDepth--;\n\t\t\t}\n\n\t\t\tif (pTokenizedExpression[i] === '{')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = true;\n\t\t\t}\n\t\t\tif (pTokenizedExpression[i] === '}')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = false;\n\t\t\t}\n\n\t\t\tif (tmpParenthesisDepth < 0)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression at token index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\t\t}\n\t\tif (tmpParenthesisDepth > 0)\n\t\t{\n\t\t\t// TODO: Should we add the closing parenthesis?\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression (ended without closing last set of parenthesis) -- appropriate closing parenthesis will be added.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\t// 2. Check for balanced squiggly braces\n\t\ttmpInStateAddress = false;\n\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif (pTokenizedExpression[i] === '{')\n\t\t\t{\n\t\t\t\ttmpInStateAddress = true;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === '}') && (tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpInStateAddress = false;\n\t\t\t}\n\t\t\tif ((pTokenizedExpression[i] === '}') && (!tmpInStateAddress))\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced closing squiggly brace \"}\" in the tokenized expression at token index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\n\t\t\tif (tmpInStateAddress)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found an open squiggly brace in the tokenized expression at index ${i}`);\n\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t}\n\t\t}\n\n\t\t// 3. Check for an equality assignment\n\t\tlet tmpEqualityAssignmentCount = 0;\n\t\tlet tmpEqualityAssignmentIndex = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((this.ExpressionParser.tokenMap[pTokenizedExpression[i]]) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type === 'Assignment'))\n\t\t\t{\n\t\t\t\ttmpEqualityAssignmentCount++;\n\t\t\t\ttmpEqualityAssignmentIndex = i;\n\n\t\t\t\tif (tmpEqualityAssignmentCount > 1)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found multiple equality assignments in the tokenized expression; equality assignment #${tmpEqualityAssignmentCount} operator '${pTokenizedExpression[i]}' at token index ${i}.`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tmpEqualityAssignmentCount < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found no equality assignment in the tokenized expression.  One called Result will be added automatically.`);\n\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\n\t\t// 4. Make sure the equality assignment only has a single value on the other side of it\n\t\t//    (no, this is not a magical algebraic solver, do your own simplification)\n\t\t//    IF there is only one equality assignment (otherwise we don't even lint this because it's syntax errors all the way down)\n\t\tif (tmpEqualityAssignmentCount === 1)\n\t\t{\n\t\t\t// If there are exactly three tokens, make sure at least one is an assignable-ish address\n\t\t\t// This can still fail, but we aren't linting all the way into the manifest here; just the expression\n\t\t\tif (pTokenizedExpression.length === 3)\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\t// The first token in our expression is a potentially assignable symbol\n\t\t\t\t\t(this.getTokenType(pTokenizedExpression[0]) === 'Token.StateAddress') || (this.getTokenType(pTokenizedExpression[2]) === 'Token.Symbol')\n\t\t\t\t\t// NOTE: For now we are only going to support assignment to the first symbol in the expression, which seems okay.\n\t\t\t\t\t// OR the last token in our expression is a potentially assignable symbol\n\t\t\t\t\t//|| (this.getTokenType(pTokenizedExpression[2]) === 'Token.StateAddress') || (this.getTokenType(pTokenizedExpression[0]) === 'Token.Symbol')\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.lintTokenizedExpression found a single equality assignment in the tokenized expression with no assignable address on the left side of the assignment.`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5. Check that there are no operators adjacent to each other\n\t\t//    This is a simple lint check, not a full-blown syntax check\n\t\tlet tmpTokenPrevious = false;\n\t\tfor (let i = 0; i < pTokenizedExpression.length - 1; i++)\n\t\t{\n\t\t\tif ((pTokenizedExpression[i] in this.ExpressionParser.tokenMap) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type != 'Parenthesis') && !tmpTokenPrevious)\n\t\t\t{\n\t\t\t\ttmpTokenPrevious = true;\n\t\t\t}\n\t\t\telse if ((pTokenizedExpression[i] in this.ExpressionParser.tokenMap) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type != 'Parenthesis'))\n\t\t\t{\n\t\t\t\t// If this isn't a + or - positivity/negativity multiplier, it's an error.\n\t\t\t\tif ((pTokenizedExpression[i] !== '+') && (pTokenizedExpression[i] !== '-'))\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.lintTokenizedExpression found an ${pTokenizedExpression[i]} operator adjacent to another operator in the tokenized expression at token index ${i}`);\n\t\t\t\t\ttmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpTokenPrevious = false;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResults.LinterResults;\n\t}\n}\n\nmodule.exports = ExpressionParserLinter;\n","const { PE } = require('big.js');\nconst libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\n/**\n * Represents a user-friendly messaging service for the ExpressionParser compiler output.\n * @class ExpressionParserMessaging\n * @extends libExpressionParserOperationBase\n */\nclass ExpressionParserMessaging extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Messaging';\n\t}\n\n\tgetOperationVirtualSymbolName(pOperationToken)\n\t{\n\t\treturn (pOperationToken && ('VirtualSymbolName' in pOperationToken)) ? pOperationToken.VirtualSymbolName \n\t\t\t: (pOperationToken.Type === 'Token.VirtualSymbol') ? pOperationToken.Token\n\t\t\t: 'NO_VIRTUAL_SYMBOL_NAME_FOUND';\n\t}\n\n\tgetVirtualTokenValue(pToken, pOperationResults)\n\t{\n\t\tlet tmpVirtualSymbol = this.getOperationVirtualSymbolName(pToken);\n\n\t\tif ((pToken.Type == 'Token.Symbol' || pToken.Type == 'Token.Constant') && (pToken.Value))\n\t\t{\n\t\t\treturn pToken.Value.toString();\n\t\t}\n\n\t\tlet tmpVirtualSymbolData = ('VirtualSymbols' in pOperationResults) ? pOperationResults.VirtualSymbols : {};\n\n\t\tif (this.ExpressionParser.GenericManifest.checkAddressExists(tmpVirtualSymbolData, tmpVirtualSymbol))\n\t\t{\n\t\t\tlet tmpValue = this.ExpressionParser.GenericManifest.getValueAtAddress(tmpVirtualSymbolData, tmpVirtualSymbol);\n\n\t\t\tif (typeof(tmpValue) === 'object')\n\t\t\t{\n\t\t\t\treturn `{${Object.keys(tmpValue).length} values}`;\n\t\t\t}\n\t\t\tif (Array.isArray(tmpValue))\n\t\t\t{\n\t\t\t\treturn `[${Object.keys(tmpValue).length} values]`;\n\t\t\t}\n\t\t\treturn tmpValue;\n\t\t}\n\n\t\treturn 'NO_VALUE_FOUND';\n\t}\n\n\tgetTokenAddressString(pToken)\n\t{\n\t\treturn pExpression.Token;\n\t}\n\n\tgetTokenSymbolString(pExpressionToken)\n\t{\n\t\treturn pExpressionToken.Token;\n\t}\n\n\tgetOperationSymbolMessage(pOperation)\n\t{\n\t\tif (!pOperation)\n\t\t{\n\t\t\treturn 'INVALID_OPERATION';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pOperation);\n\t\tlet tmpOperationLeftValue = this.getTokenSymbolString(pOperation.LeftValue);\n\t\tlet tmpOperationSymbol = this.getTokenSymbolString(pOperation.Operation);\n\t\tlet tmpOperationRightValue = this.getTokenSymbolString(pOperation.RightValue);\n\n\t\tlet tmpVirtualSymbolPrefix = tmpOperationVirtualSymbol.substring(0, 3);\n\n\t\tif (tmpOperationSymbol === '=')\n\t\t{\n\t\t\t// Assignment operators are special\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue}`;\n\t\t}\n\n\t\tif (tmpVirtualSymbolPrefix === 'VFE')\n\t\t{\n\t\t\t// Virtual Function Expression\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationSymbol}(${tmpOperationLeftValue})`;\n\t\t}\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue} ${tmpOperationSymbol} ${tmpOperationRightValue}`;\n\t}\n\n\tgetOperationValueMessage(pOperation, pResultObject)\n\t{\n\t\tif (!pOperation)\n\t\t{\n\t\t\treturn 'INVALID_OPERATION';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pOperation);\n\t\tlet tmpOperationLeftValue = this.getVirtualTokenValue(pOperation.LeftValue, pResultObject);\n\t\tlet tmpOperationSymbol = this.getTokenSymbolString(pOperation.Operation);\n\t\tlet tmpOperationRightValue = this.getVirtualTokenValue(pOperation.RightValue, pResultObject);\n\n\t\tlet tmpVirtualSymbolPrefix = tmpOperationVirtualSymbol.substring(0, 3);\n\n\t\tif (tmpOperationSymbol === '=')\n\t\t{\n\t\t\t// Assignment operators are special\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue}`;\n\t\t}\n\n\t\tif (tmpVirtualSymbolPrefix === 'VFE')\n\t\t{\n\t\t\t// Virtual Function Expression\n\t\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationSymbol}(${tmpOperationLeftValue})`;\n\t\t}\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationLeftValue} ${tmpOperationSymbol} ${tmpOperationRightValue}`;\n\t}\n\n\tgetOperationOutcomeMessage(pToken, pOperationResults)\n\t{\n\t\tif (!pToken)\n\t\t{\n\t\t\treturn 'INVALID_TOKEN';\n\t\t}\n\t\tlet tmpOperationVirtualSymbol = this.getOperationVirtualSymbolName(pToken);\n\t\tlet tmpOperationOutcomeValue = this.getVirtualTokenValue(pToken, pOperationResults);\n\n\t\treturn `${tmpOperationVirtualSymbol} = ${tmpOperationOutcomeValue}`;\n\t}\n\n\tlogFunctionOutcome(pResultObject)\n\t{\n\t\tif (typeof(pResultObject) !== 'object')\n\t\t{\n\t\t\tthis.log.error(`Solver results object was not an object.  Cannot log outcome.`);\n\t\t\treturn;\n\t\t}\n\t\tlet tmpAssignmentAddress = ('PostfixedAssignmentAddress' in pResultObject) ? pResultObject.PostfixedAssignmentAddress : 'NO_ASSIGNMENT_ADDRESS_FOUND';\n\t\tlet tmpRawExpression = ('RawExpression' in pResultObject) ? pResultObject.RawExpression : 'NO_EXPRESSION_FOUND';\n\t\tlet tmpRawResult = ('RawResult' in pResultObject) ? pResultObject.RawResult : 'NO_RESULT_FOUND';\n\n\t\tthis.log.info(`Solved f(${tmpAssignmentAddress}) = {${tmpRawExpression}}`);\n\t\tfor (let i = 0; i < pResultObject.PostfixSolveList.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pResultObject.PostfixSolveList[i];\n\t\t\tlet tmpTokenSymbolMessage = this.getOperationSymbolMessage(tmpToken);\n\t\t\tthis.log.info(`${i} Symbols: ${tmpTokenSymbolMessage}`);\n\t\t\tlet tmpTokenValueMessage = this.getOperationValueMessage(tmpToken, pResultObject);\n\t\t\tthis.log.info(`${i}  Values: ${tmpTokenValueMessage}`);\n\t\t\tlet tmpTokenOutcome = this.getOperationOutcomeMessage(tmpToken, pResultObject);\n\t\t\tthis.log.info(`${i} Outcome: ${tmpTokenOutcome}`);\n\t\t}\n\t\tthis.log.info(`{${tmpRawExpression}} = ${tmpRawResult}`);\n\t}\n\n\tlogFunctionSolve(pResultObject)\n\t{\n\t\tif (typeof(pResultObject) !== 'object')\n\t\t{\n\t\t\tthis.log.error(`Solver results object was not an object.  Cannot log the solve.`);\n\t\t\treturn;\n\t\t}\n\t\tif (!('PostfixSolveList' in pResultObject) || !Array.isArray(pResultObject.PostfixSolveList))\n\t\t{\n\t\t\tthis.log.error(`Solver results object did not contain a PostfixSolveList array.  Cannot log the solve.`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < pResultObject.PostfixSolveList.length; i++)\n\t\t{\n\t\t\tlet tmpToken = pResultObject.PostfixSolveList[i];\n\t\t\tconsole.log(`${i}: ${tmpToken.VirtualSymbolName} = (${tmpToken.LeftValue.Token}::${tmpToken.LeftValue.Value})  ${tmpToken.Operation.Token}  (${tmpToken.RightValue.Token}::${tmpToken.RightValue.Value}) `)\n\t\t}\n\n\t\tthis.logFunctionOutcome(pResultObject);\n\t}\n}\n\nmodule.exports = ExpressionParserMessaging;\n","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserPostfix extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Postfix';\n\t}\n\n\tgetPosfixSolveListOperation(pOperation, pLeftValue, pRightValue, pDepthSolveList, pDepthSolveIndex)\n\t{\n\t\tlet tmpOperation = ({\n\t\t\tVirtualSymbolName: pOperation.VirtualSymbolName,\n\t\t\tOperation: pOperation,\n\t\t\tLeftValue: pLeftValue,\n\t\t\tRightValue: pRightValue\n\t\t});\n\n\t\tlet tmpDepthSolveList = Array.isArray(pDepthSolveList) ? pDepthSolveList : false;\n\n\t\t/* These two if blocks are very complex -- they basically provide a\n\t\t * way to deal with recursion that can be expressed to the user in\n\t\t * a meaningful way.\n\t\t * \n\t\t * The reason we are doing it as such is to show exactly how the\n\t\t * solver resolves the passed-in tokens into a solvable expression.\n\t\t */\n\t\tif (!tmpOperation.LeftValue.VirtualSymbolName)\n\t\t{\n\t\t\ttmpOperation.LeftValue.VirtualSymbolName = tmpOperation.VirtualSymbolName;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We need to set the left value to a virtual symbol instead of the looked up value if it's already used in another operation\n\t\t\tif ('LeftVirtualSymbolName' in tmpOperation.Operation)\n\t\t\t{\n\t\t\t\ttmpOperation.LeftValue = this.getTokenContainerObject(tmpOperation.Operation.LeftVirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpOperation.LeftValue = this.getTokenContainerObject(tmpOperation.LeftValue.VirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t}\n\t\tif (!tmpOperation.RightValue.VirtualSymbolName)\n\t\t{\n\t\t\ttmpOperation.RightValue.VirtualSymbolName = tmpOperation.VirtualSymbolName;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We need to set the right value to a virtual symbol instead of the looked up value if it's already used in another operation\n\t\t\t//if ('LeftVirtualSymbolName' in tmpOperation.RightValue)\n\t\t\tif ('RightVirtualSymbolName' in tmpOperation.Operation)\n\t\t\t{\n\t\t\t\ttmpOperation.RightValue = this.getTokenContainerObject(tmpOperation.Operation.RightVirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpOperation.RightValue = this.getTokenContainerObject(tmpOperation.RightValue.VirtualSymbolName, 'Token.VirtualSymbol');\n\t\t\t}\n\t\t}\n\n\t\ttmpOperation.Operation.Parsed = true;\n\n\t\treturn tmpOperation;\n\t}\n\n\tbuildPostfixedSolveList(pTokenizedExpression, pResultObject)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\ttmpResults.PostfixedAssignmentAddress = 'Result'\n\t\ttmpResults.PostfixedAssignmentOperator = this.ExpressionParser.tokenMap['=']; // This is the default assignment operator\n\t\ttmpResults.PostfixTokenObjects = [];\n\t\ttmpResults.PostfixSolveList = [];\n\n\t\tif (pTokenizedExpression.length < 3)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList was passed a tokenized expression with less than three tokens.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn tmpResults.PostfixTokenObjects;\n\t\t}\n\n\t\t// 1. Figure out the Equality Assignment\n\t\tlet tmpEqualsIndex = -1;\n\t\tfor (let i = 0; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\tif ((this.ExpressionParser.tokenMap[pTokenizedExpression[i]]) && (this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type === 'Assignment'))\n\t\t\t{\n\t\t\t\tif (tmpEqualsIndex < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEqualsIndex = i;\n\t\t\t\t\ttmpResults.PostfixedAssignmentOperator = this.ExpressionParser.tokenMap[pTokenizedExpression[i]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found multiple assignment operators in the tokenized expression; assignment operator '${pTokenizedExpression[i]}' #${tmpEqualsIndex} at token index ${i}.`);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\treturn tmpResults.PostfixTokenObjects;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEqualsIndex == -1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.buildPostfixedSolveList found no equality assignment in the tokenized expression; defaulting to Result`);\n\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\t\telse if (tmpEqualsIndex > 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.buildPostfixedSolveList found an equality assignment in the tokenized expression at an unexpected location (token index ${tmpEqualsIndex}); the expression cannot be parsed.`);\n\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t}\n\t\telse if (tmpEqualsIndex === 0)\n\t\t{\n\t\t\t// This is an implicit function -- just go to result and return the value.\n\t\t\t// That is... the user entered something like \"= 5 + 3\" so we should just return 8, and use the default Result quietly.\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpResults.PostfixedAssignmentAddress = pTokenizedExpression[0];\n\t\t}\n\n\t\t// 2. Categorize tokens in the expression, put them in the \"expression list\" as a token object\n\t\tfor (let i = tmpEqualsIndex + 1; i < pTokenizedExpression.length; i++)\n\t\t{\n\t\t\ttmpResults.PostfixTokenObjects.push(this.getTokenContainerObject(pTokenizedExpression[i]));\n\t\t}\n\n\t\t// 3. Decorate mathematical parsing depth and detect functions at the same time\n\t\t//    Having written this a few times now, it's easier to detect functions *while* parsing depth.\n\t\t//    Especially if we want our system to be able to communicate with the user when there is an issue.\n\t\tlet tmpDepth = 0;\n\t\t// The virtual symbol index is used for the abstract interim values that are generated at each step of the solve\n\t\tlet tmpVirtualParenthesisIndex = 0;\n\t\tlet tmpSolveLayerStack = [];\n\t\t// Kick off the solve layer stack with the first solve set identifier\n\t\ttmpSolveLayerStack.push(`SolveSet_${tmpVirtualParenthesisIndex}_D_${tmpDepth}`);\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\t// 1. If it's an open parenthesis, set the parenthesis at the current depth and increment the depth\n\t\t\tif (tmpResults.PostfixTokenObjects[i].Token === '(')\n\t\t\t{\n\t\t\t\t// Set the depth of the open parenthesis to the current solution depth\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\t\t\t\t// Generate the virtual symbol name for user output\n\t\t\t\ttmpResults.PostfixTokenObjects[i].VirtualSymbolName = `Pr_${tmpVirtualParenthesisIndex}_D_${tmpDepth}`;\n\n\t\t\t\t// 1a. Detect if this parenthesis is signaling a function\n\t\t\t\t//     If the previous token is a Symbol (e.g. it say sin(x) or sqrt(3+5) or something) then the parser will interpret it as a function\n\t\t\t\tif (i > 0)\n\t\t\t\t{\n\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i-1].Type === 'Token.Symbol')\n\t\t\t\t\t{\n\t\t\t\t\t\t// Set the type of this to be a function\n\t\t\t\t\t\ttmpResults.PostfixTokenObjects[i-1].Type = 'Token.Function';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Parenthesis manage the solve layer stack\n\t\t\t\t// For adding a new parenthesis solve layer, we put the parenthesis in the stack we are in and then make all the contained tokens be within the stack of the parenthesis\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t\ttmpSolveLayerStack.push(tmpResults.PostfixTokenObjects[i].VirtualSymbolName);\n\n\t\t\t\ttmpVirtualParenthesisIndex++;\n\t\t\t\ttmpDepth++;\n\t\t\t}\n\n\t\t\t// 2. If it's a closed parenthesis, decrease the depth\n\t\t\telse if (tmpResults.PostfixTokenObjects[i].Token === ')')\n\t\t\t{\n\t\t\t\ttmpDepth--;\n\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\n\t\t\t\t// Check to see that the depth of the closed parenthesis is greater than 0\n\t\t\t\tif (tmpDepth < 0)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t}\n\n\t\t\t\t// Parenthesis manage the solve layer stack\n\t\t\t\t// For closing parenthesis solve layer with a close paren, we put it in the same stack as the opening parenthesis.\n\t\t\t\t// Give the closing parenthesis the same virtual symbol name as the opening parenthesis\n\t\t\t\t// (do the both above at the same time)\n\t\t\t\ttmpResults.PostfixTokenObjects[i].VirtualSymbolName = tmpSolveLayerStack.pop();\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpResults.PostfixTokenObjects[i].Depth = tmpDepth;\n\t\t\t\ttmpResults.PostfixTokenObjects[i].SolveLayerStack = tmpSolveLayerStack[tmpSolveLayerStack.length-1];\n\t\t\t}\n\t\t}\n\n\t\t// 4. Walk through the decorated symbols and generate the postfix solve list\n\t\t//    We are going to start by creating a map of the solve layers:\n\t\tlet tmpSolveLayerMap = {};\n\t\tlet tmpSolveLayerMaxDepth = 0;\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\tif (!(tmpResults.PostfixTokenObjects[i].SolveLayerStack in tmpSolveLayerMap))\n\t\t\t{\n\t\t\t\ttmpSolveLayerMap[tmpResults.PostfixTokenObjects[i].SolveLayerStack] = [];\n\t\t\t}\n\t\t\ttmpSolveLayerMap[tmpResults.PostfixTokenObjects[i].SolveLayerStack].push(tmpResults.PostfixTokenObjects[i]);\n\n\t\t\t// See what our max depth is.  This is super important to the postfix operation\n\t\t\t// The programmer in me thinks it would be funny to not track this and just use the map key length as the max size, which would work (logically impossible to have a depth > key length) but it would be quite a bit more confusing to grok the algorithm.\n\t\t\tif (tmpResults.PostfixTokenObjects[i].Depth > tmpSolveLayerMaxDepth)\n\t\t\t{\n\t\t\t\ttmpSolveLayerMaxDepth = tmpResults.PostfixTokenObjects[i].Depth;\n\t\t\t}\n\t\t}\n\n\t\tlet tmpSolveLayerKeys = Object.keys(tmpSolveLayerMap);\n\t\t// Reset the virtual symbol index -- it was used above for uniquenes when creating abstract symbols for parenthesis and layer stacks.\n\t\tlet tmpVirtualSymbolIndex = 0;\n\t\ttmpSolveLayerKeys.sort(\n\t\t\t// Sort the solve layers by depth.\n\t\t\t(pLeftLayer, pRightLayer)=>\n\t\t\t{\n\t\t\t\t// It is impossible to have a layer with no entries in it.  \n\t\t\t\t// If that ever happens, the bug is actually above and we actively want this to blow up.\n\t\t\t\tif (tmpSolveLayerMap[pLeftLayer][0].Depth < tmpSolveLayerMap[pRightLayer][0].Depth)\n\t\t\t\t{\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (tmpSolveLayerMap[pLeftLayer][0].Depth > tmpSolveLayerMap[pRightLayer][0].Depth)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t// 5. Generate the postfix solve list\n\t\t//    The most important thing is going backwards in the depth order (a la reverse polish).\n\t\t//    Specifically not using shunting yard to provide in-depth \"show your work\" notes\n\t\t//    Yes it is possible to do a somewhat similar thing with shunting yard but the code is almost unreadable\n\n\t\t// 5.1 Build the Virtual Symbol Names\n\t\t// This maps layer stack addresses (which match parenthesis virtual symbol names) to the resultant value for that layer stack.\n\t\t// These values change as it solves but the last assignment is the proper assignment because math only reads forward in a line\n\t\ttmpResults.PostfixLayerstackMap = {};\n\t\t//FIXME: vet these - do we need a suffix version?\n\t\tconst unaryEligibleOperationTokens = [ '+', '-' ];\n\t\tconst unaryOperationPrefixTriggerTypes = [ 'Token.Operator', 'Token.Assignment' ];\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\t\t\t// For each precedence (this isn't strictly required here but makes the outcome for the user more readable)\n\t\t\tfor (let tmpPrecedence = 0; tmpPrecedence <= this.ExpressionParser.tokenMaxPrecedence; tmpPrecedence++)\n\t\t\t{\n\t\t\t\t// Enumerate all tokens in a layer's expression.\n\t\t\t\t// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.\n\t\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t\t{\n\t\t\t\t\tconst tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\tif (unaryEligibleOperationTokens.includes(tmpToken.Token) &&\n\t\t\t\t\t// promote to unary if:\n\t\t\t\t\t// 1. we are the first token in our group\n\t\t\t\t\t// 2. we are prefixed by a token type that is incompatible with us being binary\n\t\t\t\t\t\t(i == 0 || unaryOperationPrefixTriggerTypes.includes(tmpSolveLayerTokens[i - 1].Type)))\n\t\t\t\t\t{\n\t\t\t\t\t\t//FIXME: slow, but don't break the static data\n\t\t\t\t\t\ttmpToken.Descriptor = JSON.parse(JSON.stringify(tmpToken.Descriptor));\n\t\t\t\t\t\ttmpToken.Descriptor.Precedence = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//FIXME: handle operators with dynamic precedence (ex. unary vs. bunary + and -)\n\t\t\t\t\t// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.\n\t\t\t\t\tif ((tmpSolveLayerTokens[i].Type === 'Token.Operator') &&\n\t\t\t\t\t\t(tmpToken.Descriptor.Precedence === tmpPrecedence))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there is a token and nothing else in this layer, then it's an error.\n\t\t\t\t\t\tif (tmpSolveLayerTokens.length === 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a single operator in a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The - at the beginning of an expression is a number line orientation modifier\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '-' || tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VNLO_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If the token is at the beginning of the expression and not a number line orientation modifier, it's an error.\n\t\t\t\t\t\telse if ((i == 0) && ((tmpToken.Token != '+') || (tmpToken.Token != '-')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the beginning of a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If the token is at the end of the expression, it is an error.\n\t\t\t\t\t\telse if (i == tmpSolveLayerTokens.length - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the end of a solve layer expression at token index ${i}`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The - after an operator or an open parenthesis is also a number line orientation modifier\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '-') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VNLO_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '+') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the token is next to another operator it's a parsing error\n\t\t\t\t\t\telse if (((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i+1].Type === 'Token.Operator')) &&\n\t\t\t\t\t\t\t\t(tmpSolveLayerTokens[i+1].Token != '-' && tmpSolveLayerTokens[i+1].Token != '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found an operator at token index ${i} that is not surrounded by two values.`);\n\t\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t\treturn tmpResults.PostfixSolveList;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Finally add a virtual symbol name to the dang thing.\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpToken.VirtualSymbolName = `V_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tmpSolveLayerTokens[i].Type === 'Token.Function') && (tmpPrecedence === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\ttmpToken.VirtualSymbolName = `VFE_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\ttmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack] = tmpToken.VirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.15 Generate Virtual Symbol Clusters for Functions and Parenthesis\n\t\t//      ... this gets funny because of precedence of operations surrounding them, parenthesis and functions.\n\t\tlet tmpFunctionCacheLIFOStack = [];\n\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t{\n\t\t\tlet tmpPostfixTokenObject = tmpResults.PostfixTokenObjects[i];\n\n\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\t// This is just to track the parenthesis stack level for User feedback\n\t\t\t\ttmpPostfixTokenObject.ParenthesisStack = tmpPostfixTokenObject.VirtualSymbolName;\n\n\t\t\t\t// At the beginning of the  expression, this must be an open parenthesis to be legal.\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ... this parenthesis group has no operators in it; make a virtual symbol name.\n\t\t\t\t\t\ttmpVirtualSymbolName = `VP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\ttmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\t// If it's an open parenthesis\n\t\t\t\telse if (tmpPostfixTokenObject.Token === '(')\n\t\t\t\t{\n\t\t\t\t\t// ... supporting a function\n\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i-1].Type === 'Token.Function')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = true;\n\t\t\t\t\t\ttmpPostfixTokenObject.Function = tmpResults.PostfixTokenObjects[i-1];\n\t\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ... this parenthesis group has no operators in it; make a virtual symbol name.\n\t\t\t\t\t\t\ttmpVirtualSymbolName = `VFP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\t\tlet tmpVirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];\n\t\t\t\t\t\tif (!tmpVirtualSymbolName)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a parenthesis group with no operators in it; make a virtual symbol name.\n\t\t\t\t\t\t\ttmpVirtualSymbolName = `VP_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpVirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\ttmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\telse if (tmpPostfixTokenObject.Token === ')')\n\t\t\t\t{\n\t\t\t\t\tlet tmpOpenParenthesis = tmpFunctionCacheLIFOStack.pop();\n\t\t\t\t\tif (!tmpOpenParenthesis)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpOpenParenthesis.IsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = true;\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpOpenParenthesis.Function.VirtualSymbolName;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.IsFunction = false;\n\t\t\t\t\t\ttmpPostfixTokenObject.VirtualSymbolName = tmpOpenParenthesis.VirtualSymbolName\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// X. Postprocess the parenthesis groups to ensure they respect the order of operations for their boundaries\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpParenthesisStack = [];\n\t\t\tlet tmpLastOperator = false;\n\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpPostfixTokenObject = tmpSolveLayerTokens[i];\n\n\t\t\t\t// Keep track of the last operator\n\t\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\ttmpLastOperator = tmpPostfixTokenObject;\n\t\t\t\t}\n\n\t\t\t\t// This is only important to do at the close parenthesis.\n\t\t\t\tif (tmpPostfixTokenObject.Type === 'Token.Function')\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpLastOperator;\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === '(') && tmpPostfixTokenObject.IsFunction)\n\t\t\t\t{\n\t\t\t\t\ttmpParenthesisStack.push(tmpPostfixTokenObject);\n\t\t\t\t\tif (tmpPostfixTokenObject.Function.PreviousOperator)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpPostfixTokenObject.Function.PreviousOperator;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === '('))\n\t\t\t\t{\n\t\t\t\t\ttmpPostfixTokenObject.PreviousOperator = tmpLastOperator;\n\t\t\t\t\ttmpParenthesisStack.push(tmpPostfixTokenObject);\n\t\t\t\t}\n\t\t\t\telse if ((tmpPostfixTokenObject.Type === 'Token.Parenthesis') && (tmpPostfixTokenObject.Token === ')'))\n\t\t\t\t{\n\t\t\t\t\t// This is ultra complex, and binds the order of operations logic to the open parenthesis for the group\n\t\t\t\t\tlet tmpOpenParenthesis = tmpParenthesisStack.pop();\n\t\t\t\t\tif (i < tmpSolveLayerTokens.length - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (let j = i + 1; j < tmpSolveLayerTokens.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpSolveLayerTokens[j].Type === 'Token.Operator')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOpenParenthesis.NextOperator = tmpSolveLayerTokens[j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpOpenParenthesis)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ${i} with no corresponding opening parenthesis.`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpOpenParenthesis.PreviousOperator && tmpOpenParenthesis.NextOperator)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpOpenParenthesis.PreviousOperator.Descriptor.Precedence <= tmpOpenParenthesis.NextOperator.Descriptor.Precedence)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpOpenParenthesis.NextOperator.LeftVirtualSymbolName = tmpOpenParenthesis.PreviousOperator.VirtualSymbolName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpOpenParenthesis.PreviousOperator.RightVirtualSymbolName = tmpOpenParenthesis.NextOperator.VirtualSymbolName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!('SolveLayerStack' in tmpPostfixTokenObject))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Decorate the solve layer stack for the token\n\t\t\t\t\t\tif (tmpParenthesisStack.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpPostfixTokenObject.SolveLayerStack = tmpParenthesisStack[tmpParenthesisStack.length-1].SolveLayerStack;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpPostfixTokenObject.SolveLayerStack = 'Expression_Root';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.2.9: Make sure the affinity of operators is respecting order of operations.\n\t\t//        Walk backwards and forwards, hoisting same value precedence backwards/forwards\n\t\t//        across each layer... the precedence change needs to be decreasing to matter\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpLastPrecedence = false;\n\t\t\tlet tmpFinalChainToken = false;\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\n\t\t\tfor (let i = tmpSolveLayerTokens.length-1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\n\t\t\t\tif (tmpToken.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\tif (!tmpFinalChainToken)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence > tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is less imporant than the last precedence, so hoist back the virtual value\n\t\t\t\t\t\ttmpToken.RightVirtualSymbolName = tmpFinalChainToken.VirtualSymbolName;\n\t\t\t\t\t\t//console.log(`Hoisting ${tmpToken.Token} back to ${tmpFinalChainToken.Token}`);\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence < tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFinalChainToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\ttmpLastPrecedence = tmpToken.Descriptor.Precedence;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet tmpDecreasingPrecedenceStack = [];\n\t\t\tlet tmpLastToken = false;\n\t\t\tfor (let i = tmpSolveLayerTokens.length-1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\n\t\t\t\tif (tmpToken.Type === 'Token.Operator')\n\t\t\t\t{\n\t\t\t\t\tif (!tmpLastToken)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence > tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Check and see if this needs to be resolved in the stack\n\t\t\t\t\t\tif (tmpDecreasingPrecedenceStack.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (let j = tmpDecreasingPrecedenceStack.length-1; j >= 0; j--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (tmpDecreasingPrecedenceStack[j].Descriptor.Precedence >= tmpToken.Descriptor.Precedence)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//console.log(`Hoisting ${tmpDecreasingPrecedenceStack[j].Token} up to ${tmpToken.Token}`);\n\t\t\t\t\t\t\t\t\ttmpDecreasingPrecedenceStack[j].LeftVirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\t\t\ttmpDecreasingPrecedenceStack.slice(j, 1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpToken.Descriptor.Precedence < tmpLastPrecedence)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpDecreasingPrecedenceStack.push(tmpLastToken);\n\t\t\t\t\t\ttmpLastToken = tmpToken;\n\t\t\t\t\t}\n\t\t\t\t\ttmpLastPrecedence = tmpToken.Descriptor.Precedence;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 5.3: Generate the Postfix Solve List\n\t\tfor (let tmpSolveLayerIndex = 0; tmpSolveLayerIndex < tmpSolveLayerKeys.length; tmpSolveLayerIndex++)\n\t\t{\n\t\t\tlet tmpSolveLayerTokens = tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];\n\n\t\t\t// If this is a layer with one value, presume it's an assignment.\n\t\t\tif (tmpSolveLayerTokens.length === 1)\n\t\t\t{\n\t\t\t\t// TODO: I think this is correct but with the addition of multiple assignment operators it's less clear.\n\t\t\t\tlet tmpAbstractAssignToken = this.getTokenContainerObject('=');\n\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixLayerstackMap[tmpSolveLayerTokens[0].SolveLayerStack];\n\t\t\t\t// If this doesn't have a matching solvelayerstack, get the virtual symbol name from the parenthesis group it's in\n\t\t\t\tif (!tmpAbstractAssignToken.VirtualSymbolName)\n\t\t\t\t{\n\t\t\t\t\tfor (let i = 0; i < tmpResults.PostfixTokenObjects.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmpResults.PostfixTokenObjects[i].ParenthesisStack === tmpSolveLayerTokens[0].SolveLayerStack)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixTokenObjects[i].VirtualSymbolName;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!tmpAbstractAssignToken.VirtualSymbolName)\n\t\t\t\t{\n\t\t\t\t\ttmpAbstractAssignToken.VirtualSymbolName = `V_SingleValue_${tmpVirtualSymbolIndex}`;\n\t\t\t\t\ttmpVirtualSymbolIndex++;\n\t\t\t\t}\n\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractAssignToken, tmpSolveLayerTokens[0], this.getTokenContainerObject('0.0')));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// For each precedence level in the layer\n\t\t\tfor (let tmpPrecedence = 0; tmpPrecedence <= this.ExpressionParser.tokenMaxPrecedence; tmpPrecedence++)\n\t\t\t{\n\t\t\t\t// Enumerate all tokens in a layer's expression.\n\t\t\t\t// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.\n\t\t\t\tfor (let i = 0; i < tmpSolveLayerTokens.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.\n\t\t\t\t\tif ((tmpSolveLayerTokens[i].Type === 'Token.Operator') &&\n\t\t\t\t\t\t(tmpSolveLayerTokens[i].Descriptor.Precedence === tmpPrecedence))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\t// The - at the beginning of an expression is a number line orientation modifier\n\t\t\t\t\t\tif ((i == 0) && (tmpToken.Token == '-'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\t// This is an abstract operation that isn't in the expression.\n\t\t\t\t\t\t\tlet tmpAbstractMultiplyToken = this.getTokenContainerObject('*');\n\t\t\t\t\t\t\ttmpAbstractMultiplyToken.VirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractMultiplyToken, this.getTokenContainerObject('-1.0'), tmpSolveLayerTokens[i+1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The - after an operator or an open parenthesis is also a number line orientation modifier\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '-') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token\n\t\t\t\t\t\t\tlet tmpAbstractMultiplyToken = this.getTokenContainerObject('*');\n\t\t\t\t\t\t\ttmpAbstractMultiplyToken.VirtualSymbolName = tmpToken.VirtualSymbolName;\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractMultiplyToken, this.getTokenContainerObject('-1.0'), tmpSolveLayerTokens[i+1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i == 0) && (tmpToken.Token == '+'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE\n\t\t\t\t\t\telse if ((i > 0) && (tmpToken.Token == '+') && ((tmpSolveLayerTokens[i-1].Type === 'Token.Operator') || (tmpSolveLayerTokens[i-1].Token === '(')))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Finally add the dang thing.\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpToken, tmpSolveLayerTokens[i-1], tmpSolveLayerTokens[i+1], tmpSolveLayerTokens, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tmpSolveLayerTokens[i].Type === 'Token.Function') && (tmpPrecedence === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpToken = tmpSolveLayerTokens[i];\n\t\t\t\t\t\ttmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpToken, tmpSolveLayerTokens[i+1], this.getTokenContainerObject('0.0')));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 7. Lastly set the assignment address.\n\t\tlet tmpAbstractAssignToken = ('PostfixedAssignmentOperator' in tmpResults) ? this.getTokenContainerObject(tmpResults.PostfixedAssignmentOperator.Token) : this.getTokenContainerObject('=');\n\t\t// The address we are assigning to\n\t\ttmpAbstractAssignToken.VirtualSymbolName = tmpResults.PostfixedAssignmentAddress;\n\t\t// The address it's coming from\n\t\tlet tmpSolveResultToken = this.getTokenContainerObject('Result', 'Token.LastResult');\n\t\tlet tmpFinalAssignmentInstruction = this.getPosfixSolveListOperation(tmpAbstractAssignToken, tmpSolveResultToken, this.getTokenContainerObject('SolverMarshal', 'Token.SolverMarshal'));\n\t\ttmpResults.PostfixSolveList.push(tmpFinalAssignmentInstruction);\n\n\t\treturn tmpResults.PostfixSolveList;\n\t}\n}\n\nmodule.exports = ExpressionParserPostfix;\n","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\nconst libSetConcatArray = require('../Fable-SetConcatArray.js');\n\nclass ExpressionParserSolver extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-Solver';\n\t}\n\n\tsolvePostfixedExpression(pPostfixedExpression, pDataDestinationObject, pResultObject, pManifest)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\tlet tmpManifest = (typeof(pManifest) === 'object') ? pManifest : this.fable.newManyfest();\n\n\t\tlet tmpDataDestinationObject = (typeof(pDataDestinationObject) === 'object') ? pDataDestinationObject : {};\n\n\t\t// If there was a fable passed in (e.g. the results object was a service or such), we won't decorate\n\t\tlet tmpPassedInFable = ('fable' in tmpResults);\n\t\tif (!tmpPassedInFable)\n\t\t{\n\t\t\ttmpResults.fable = this.fable;\n\t\t}\n\n\t\tif (!Array.isArray(pPostfixedExpression))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression was passed a non-array postfixed expression.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn false;\n\t\t}\n\t\tif (pPostfixedExpression.length < 1)\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression was passed an empty postfixed expression.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn false;\n\t\t}\n\n\t\t// This is how the user communication magic happens.\n\t\ttmpResults.VirtualSymbols = {};\n\n\t\tfor (let i = 0; i < pPostfixedExpression.length; i++)\n\t\t{\n\t\t\t// X = SUM(15, SUM(SIN(25), 10), (5 + 2), 3)\n\t\t\tif (pPostfixedExpression[i].Operation.Type === 'Token.SolverInstruction')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpStepResultObject = { ExpressionStep: pPostfixedExpression[i], ExpressionStepIndex: i, ResultsObject: tmpResults, Manifest: tmpManifest};\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.LastResult')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpResults.LastResult;\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.LastResult')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpResults.LastResult;\n\t\t\t}\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.VirtualSymbol')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.LeftValue.Token);\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.VirtualSymbol')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.RightValue.Token);\n\t\t\t}\n\n\t\t\t// Resolve the parenthesis to their actual values\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.LeftValue.VirtualSymbolName);\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.Parenthesis')\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.RightValue.VirtualSymbolName);\n\t\t\t}\n\n\t\t\t// Virtual Constants\n\t\t\tif (tmpStepResultObject.ExpressionStep.LeftValue.Type === 'Token.Constant' && !('Value' in tmpStepResultObject.ExpressionStep.LeftValue))\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.LeftValue.Value = tmpStepResultObject.ExpressionStep.LeftValue.Token;\n\t\t\t}\n\t\t\tif (tmpStepResultObject.ExpressionStep.RightValue.Type === 'Token.Constant' && !('Value' in tmpStepResultObject.ExpressionStep.RightValue))\n\t\t\t{\n\t\t\t\ttmpStepResultObject.ExpressionStep.RightValue.Value = tmpStepResultObject.ExpressionStep.RightValue.Token;\n\t\t\t}\n\n\t\t\tif (tmpStepResultObject.ExpressionStep.Operation.Type = 'Operator')\n\t\t\t{\n\t\t\t\t// TODO: This can be optimized.   A lot.  If necessary.  Seems pretty fast honestly for even thousands of operations.  Slowest part is arbitrary precision.\n\t\t\t\t// An operator always has a left and right value.\n\t\t\t\tlet tmpFunctionAddress;\n\t\t\t\t// Note: There are easier, passive ways of managing this state.  But this is complex.\n\t\t\t\tlet tmpIsFunction = false;\n\t\t\t\tif (tmpStepResultObject.ExpressionStep.Operation.Token in this.ExpressionParser.tokenMap)\n\t\t\t\t{\n\t\t\t\t\ttmpFunctionAddress = `ResultsObject.${tmpStepResultObject.ExpressionStep.Operation.Descriptor.Function}`;\n\t\t\t\t}\n\t\t\t\telse if (tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase() in this.ExpressionParser.functionMap)\n\t\t\t\t{\n\t\t\t\t\ttmpIsFunction = true;\n\t\t\t\t\ttmpFunctionAddress = `ResultsObject.${this.ExpressionParser.functionMap[tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase()].Address}`;\n\t\t\t\t}\n\n\t\t\t\tif (tmpIsFunction)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpResult;\n\t\t\t\t\t\tconst tmpFunction = tmpManifest.getValueAtAddress(tmpStepResultObject, tmpFunctionAddress);\n\t\t\t\t\t\tif (typeof tmpFunction === 'function')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpFunctionBinding = null;\n\t\t\t\t\t\t\tif (tmpFunctionAddress.includes('.'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpFunctionBinding = tmpManifest.getValueAtAddress(tmpStepResultObject, tmpFunctionAddress.split('.').slice(0, -1).join('.'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet tmpArguments = tmpStepResultObject.ExpressionStep.LeftValue.Value;\n\t\t\t\t\t\t\tif (!(tmpArguments instanceof libSetConcatArray))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpArguments = [ tmpArguments ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpArguments = tmpArguments.values;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpResult = tmpFunction.apply(tmpFunctionBinding, tmpArguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName, tmpResult);\n\t\t\t\t\t\ttmpResults.LastResult = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName);\n\t\t\t\t\t\t//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ${i} with function ${tmpStepResultObject.ExpressionStep.Operation.Token}: ${pError}`);\n\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1], { Stack: pError.stack });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t//this.log.trace(`Solving Step ${i} [${tmpStepResultObject.ExpressionStep.VirtualSymbolName}] --> [${tmpStepResultObject.ExpressionStep.Operation.Token}]: ( ${tmpStepResultObject.ExpressionStep.LeftValue.Value} , ${tmpStepResultObject.ExpressionStep.RightValue.Value} )`);\n\t\t\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName, tmpManifest.getValueAtAddress(tmpStepResultObject, `${tmpFunctionAddress}(ExpressionStep.LeftValue.Value,ExpressionStep.RightValue.Value)`));\n\t\t\t\t\t\ttmpResults.LastResult = tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols, tmpStepResultObject.ExpressionStep.VirtualSymbolName);\n\t\t\t\t\t\t//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ${i} with function ${tmpStepResultObject.ExpressionStep.Operation.Token}: ${pError}`);\n\t\t\t\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1], { Stack: pError.stack });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Equations don't always solve in virtual symbol order.\n\t\t\t\ttmpResults.SolverFinalVirtualSymbol = tmpStepResultObject.ExpressionStep.VirtualSymbolName;\n\t\t\t}\n\t\t}\n\n\t\tlet tmpSolverResultValue = tmpManifest.getValueAtAddress(tmpResults, `VirtualSymbols.${tmpResults.SolverFinalVirtualSymbol}`);\n\n\t\t// Now deal with final assignment(s)\n\t\tfor (let i = 0; i < pPostfixedExpression.length; i++)\n\t\t{\n\t\t\tif (pPostfixedExpression[i].RightValue.Type === 'Token.SolverMarshal')\n\t\t\t{\n\t\t\t\t// Set the result in the virtual symbols\n\t\t\t\ttmpManifest.setValueAtAddress(tmpResults.VirtualSymbols, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t// Set the value in the destination object\n\t\t\t\tif (pPostfixedExpression[i].Operation.Descriptor.OnlyEmpty)\n\t\t\t\t{\n\t\t\t\t\t// If it is only on \"empty\" values, check if the value is empty before assigning\n\t\t\t\t\tif (this.fable.Utility.addressIsNullOrEmpty(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Otherwise, just assign it.\n\t\t\t\t\ttmpManifest.setValueByHash(tmpDataDestinationObject, pPostfixedExpression[i].VirtualSymbolName, tmpSolverResultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmpResults.RawResult = tmpSolverResultValue;\n\n\t\t// Clean up the fable reference if we added it to the object.\n\t\tif (!tmpPassedInFable)\n\t\t{\n\t\t\tdelete tmpResults.fable;\n\t\t}\n\n\t\tif (typeof(tmpSolverResultValue) === 'object')\n\t\t{\n\t\t\treturn tmpSolverResultValue;\n\t\t}\n\t\telse if (typeof(tmpSolverResultValue) !== 'undefined')\n\t\t{\n\t\t\treturn tmpSolverResultValue.toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpSolverResultValue;\n\t\t}\n\t}\n}\n\nmodule.exports = ExpressionParserSolver;\n","module.exports={\n\t\"=\":\n\t\t{\n\t\t\t\"Name\": \"Assign Value\",\n\t\t\t\"Token\": \"=\",\n\t\t\t\"Function\": \"fable.Math.assignValue\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\":\":\n\t\t{\n\t\t\t\"Name\": \"Expression Begin\",\n\t\t\t\"Token\": \":\",\n\t\t\t\"Function\": \"fable.Math.expressionBegin\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\"?=\":\n\t\t{\n\t\t\t\"Name\": \"Null or Empty Coalescing Assign Value\",\n\t\t\t\"Token\": \"?=\",\n\t\t\t\"Function\": \"fable.Math.assignValue\",\n\t\t\t\"OnlyEmpty\": true,\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Assignment\"\n\t\t},\n\n\t\"(\":\n\t\t{\n\t\t\t\"Name\": \"Left Parenthesis\",\n\t\t\t\"Token\": \"(\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Parenthesis\"\n\t\t},\n\t\")\":\n\t\t{\n\t\t\t\"Name\": \"Right Parenthesis\",\n\t\t\t\"Token\": \")\",\n\t\t\t\"Precedence\": 0,\n\t\t\t\"Type\": \"Parenthesis\"\n\t\t},\n\t\",\":\n\t\t{\n\t\t\t\"Name\": \"Set Concatenate\",\n\t\t\t\"Token\": \",\",\n\t\t\t\"Function\": \"fable.Math.setConcatenate\",\n\t\t\t\"Precedence\": 5,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"*\":\n\t\t{\n\t\t\t\"Name\": \"Multiply\",\n\t\t\t\"Token\": \"*\",\n\t\t\t\"Function\": \"fable.Math.multiplyPrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"/\":\n\t\t{\n\t\t\t\"Name\": \"Divide\",\n\t\t\t\"Token\": \"/\",\n\t\t\t\"Function\": \"fable.Math.dividePrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"^\":\n\t\t{\n\t\t\t\"Name\": \"Exponent\",\n\t\t\t\"Token\": \"^\",\n\t\t\t\"Function\": \"fable.Math.powerPrecise\",\n\t\t\t\"Precedence\": 2,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"%\":\n\t\t{\n\t\t\t\"Name\": \"Modulus\",\n\t\t\t\"Token\": \"%\",\n\t\t\t\"Function\": \"fable.Math.modPrecise\",\n\t\t\t\"Precedence\": 3,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\n\t\"+\":\n\t\t{\n\t\t\t\"Name\": \"Add\",\n\t\t\t\"Token\": \"+\",\n\t\t\t\"Function\": \"fable.Math.addPrecise\",\n\t\t\t\"Precedence\": 4,\n\t\t\t\"Type\": \"Operator\"\n\t\t},\n\t\"-\":\n\t\t{\n\t\t\t\"Name\": \"Subtract\",\n\t\t\t\"Token\": \"-\",\n\t\t\t\"Function\": \"fable.Math.subtractPrecise\",\n\t\t\t\"Precedence\": 4,\n\t\t\t\"Type\": \"Operator\"\n\t\t}\n}\n","const libExpressionParserOperationBase = require('./Fable-Service-ExpressionParser-Base.js');\n\nclass ExpressionParserValueMarshal extends libExpressionParserOperationBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t\tthis.serviceType = 'ExpressionParser-ValueMarshal';\n\t}\n\n\t/**\n\t * Substitutes values in tokenized objects based on the provided data source and manifest.\n\t *\n\t * TODO: Move this to its own file in the \"Fable-Service-ExpressionParser\" directory.\n\t *\n\t * @param {Array} pTokenizedObjects - The array of tokenized objects.\n\t * @param {Object} pDataSource - The data source object where we pull values from.\n\t * @param {Object} pResultObject - The result object where the algorithm shows its work.\n\t * @param {Object} pManifest - The manifest object to use for hash resolution.\n\t * @returns {Array} - The modified tokenized objects array.\n\t */\n\tsubstituteValuesInTokenizedObjects(pTokenizedObjects, pDataSource, pResultObject, pManifest)\n\t{\n\t\tlet tmpResults = (typeof(pResultObject) === 'object') ? pResultObject : { ExpressionParserLog: [] };\n\n\t\tif (!Array.isArray(pTokenizedObjects))\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects was passed a non-array tokenized object list.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedObjects;\n\t\t}\n\t\tif (typeof(pDataSource) !== 'object')\n\t\t{\n\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects either was passed no data source, or was passed a non-object data source.`);\n\t\t\tthis.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\treturn pTokenizedObjects;\n\t\t}\n\n\t\tlet tmpDataSource = pDataSource;\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : this.fable.newManyfest(pManifest);\n\n\t\tfor (let i = 0; i < pTokenizedObjects.length; i++)\n\t\t{\n\t\t\tif (typeof(pTokenizedObjects[i]) !== 'object')\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found a non-object tokenized object at index ${i}`);\n\t\t\t\tthis.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpToken = pTokenizedObjects[i];\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.Symbol') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\t// Symbols always look up values by hash first\n\t\t\t\tlet tmpValue = tmpManifest.getValueByHash(tmpDataSource, tmpToken.Token);\n\t\t\t\t// if (!tmpValue)\n\t\t\t\t// {\n\t\t\t\t// \t// If no hash resolves, try by address.\n\t\t\t\t// \ttmpValue = tmpManifest.getValueAtAddress(tmpToken.Token, tmpDataSource);\n\t\t\t\t// }\n\t\t\t\tif (tmpValue == null)\n\t\t\t\t{\n\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\ttmpToken.Resolve = true;\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the symbol hash or address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\tif (this.LogNoisiness > 1) this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpValue}] for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tif (typeof tmpValue === 'object') // this encapsulates POJOs and arrays\n\t\t\t\t\t{\n\t\t\t\t\t\t// this must be checked first, which works around an edge case where bigNumber turns single-element arrays into numbers, which we never want\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst tmpValueParsed = new this.fable.Utility.bigNumber(tmpValue);\n\t\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO: Should we allow this to be a function?  Good god the complexity and beauty of that...\n\t\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}; using raw value.`);\n\t\t\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.StateAddress') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\t// Symbols are always hashes.  This gracefully works for simple shallow objects because hashes default to the address in Manyfest.\n\t\t\t\t// Sometimes the token is wrapped in {} to indicate it's a direct address reference... we need to strip those off.\n\t\t\t\t// e.g., {0x1234abcd...}\n\t\t\t\t// So we need to strip off the {} if they exist.\n\t\t\t\tlet tmpAddress = tmpToken.Token;\n\t\t\t\tif ((tmpAddress.startsWith('{')) && (tmpAddress.endsWith('}')))\n\t\t\t\t{\n\t\t\t\t\ttmpAddress = tmpAddress.substring(1, tmpAddress.length-1);\n\t\t\t\t}\n\t\t\t\tlet tmpValue = tmpManifest.getValueAtAddress(tmpDataSource, tmpAddress);\n\t\t\t\tif (tmpValue == null)\n\t\t\t\t{\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//tmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpValue}] for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpValueParsed = new this.fable.Utility.bigNumber(tmpValue);\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t\t}\n\t\t\t\t\tcatch(pError)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: Should we allow this to be a function?  Good god the complexity and beauty of that...\n\t\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\t\ttmpToken.Value = tmpValue;\n\t\t\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}; using raw value.`);\n\t\t\t\t\t\t//this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.String') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpToken.Token}] for the string ${tmpToken.Token} at index ${i}`);\n\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t// Take the quotes off the string\n\t\t\t\ttmpToken.Value = tmpToken.Token.substring(1, tmpToken.Token.length-1);\n\t\t\t}\n\t\t\tif ((pTokenizedObjects[i].Type === 'Token.Constant') && !tmpToken.Resolved)\n\t\t\t{\n\t\t\t\ttmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpToken.Token}] for the constant ${tmpToken.Token} at index ${i}`);\n\t\t\t\tif (this.LogNoisiness > 1) this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlet tmpValueParsed = new this.fable.Utility.bigNumber(tmpToken.Token);\n\t\t\t\t\ttmpToken.Resolved = true;\n\t\t\t\t\ttmpToken.Value = tmpValueParsed.toString();\n\t\t\t\t}\n\t\t\t\tcatch(pError)\n\t\t\t\t{\n\t\t\t\t\t// This constant has the right symbols but apparently isn't a parsable number.\n\t\t\t\t\ttmpResults.ExpressionParserLog.push(`ERROR: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ${tmpToken.Token} at index ${i}`);\n\t\t\t\t\t//this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);\n\t\t\t\t\ttmpToken.Resolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pTokenizedObjects;\n\t}\n}\n\nmodule.exports = ExpressionParserValueMarshal;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libFS = require('fs');\nconst libPath = require('path');\nconst libReadline = require('readline');\n\n\nclass FableServiceFilePersistence extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'FilePersistence';\n\n\t\tif (!('Mode' in this.options))\n\t\t{\n\t\t\tthis.options.Mode = parseInt('0777', 8) & ~process.umask();\n\t\t}\n\n\t\tthis.libFS = libFS;\n\t\tthis.libPath = libPath;\n\t\tthis.libReadline = libReadline;\n\t}\n\n\tjoinPath(...pPathArray)\n\t{\n\t\t// TODO: Fix anything that's using this before changing this to the new true node join\n\t\t// return libPath.join(...pPathArray);\n\t\treturn libPath.resolve(...pPathArray);\n\t}\n\n\tresolvePath(...pPathArray)\n\t{\n\t\treturn libPath.resolve(...pPathArray);\n\t}\n\n\texistsSync(pPath)\n\t{\n\t\treturn libFS.existsSync(pPath);\n\t}\n\n\texists(pPath, fCallback)\n\t{\n\t\tlet tmpFileExists = this.existsSync(pPath);\n\t\treturn fCallback(null, tmpFileExists);\n\t}\n\n\tdeleteFileSync(pFileName)\n\t{\n\t\treturn libFS.unlinkSync(pFileName);\n\t}\n\n\tdeleteFolderSync(pFileName)\n\t{\n\t\treturn libFS.rmdirSync(pFileName);\n\t}\n\n\treadFileSync(pFilePath, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.readFileSync(pFilePath, tmpOptions);\n\t}\n\n\treadFile(pFilePath, pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.readFile(pFilePath, tmpOptions, fCallback);\n\t}\n\n\treadFileCSV(pFilePath, pOptions, fRecordFunction, fCompleteFunction, fErrorFunction)\n\t{\n\t\tlet tmpCSVParser = this.fable.instantiateServiceProviderWithoutRegistration('CSVParser', pOptions);\n\t\tlet tmpRecordFunction = (typeof(fRecordFunction) === 'function') ? fRecordFunction :\n\t\t\t(pRecord) =>\n\t\t\t{\n\t\t\t\tthis.fable.log.trace(`CSV Reader received line ${pRecord}`);\n\t\t\t};\n\t\tlet tmpCompleteFunction = (typeof(fCompleteFunction) === 'function') ? fCompleteFunction :\n\t\t\t() =>\n\t\t\t{\n\t\t\t\tthis.fable.log.info(`CSV Read of ${pFilePath} complete.`);\n\t\t\t};\n\t\tlet tmpErrorFunction = (typeof(fErrorFunction) === 'function') ? fErrorFunction :\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.fable.log.error(`CSV Read of ${pFilePath} Error: ${pError}`, pError);\n\t\t\t};\n\n\t\treturn this.lineReaderFactory(pFilePath,\n\t\t\t(pLine) =>\n\t\t\t{\n\t\t\t\tlet tmpRecord = tmpCSVParser.parseCSVLine(pLine);\n\t\t\t\tif (tmpRecord)\n\t\t\t\t{\n\t\t\t\t\ttmpRecordFunction(tmpRecord, pLine);\n\t\t\t\t}\n\t\t\t}, tmpCompleteFunction, tmpErrorFunction);\n\t}\n\n\tappendFileSync(pFileName, pAppendContent, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.appendFileSync(pFileName, pAppendContent, tmpOptions);\n\t}\n\n\twriteFileSync(pFileName, pFileContent, pOptions)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.writeFileSync(pFileName, pFileContent, tmpOptions);\n\t}\n\n\twriteFileSyncFromObject(pFileName, pObject)\n\t{\n\t\treturn this.writeFileSync(pFileName, JSON.stringify(pObject, null, 4));\n\t}\n\n\twriteFileSyncFromArray(pFileName, pFileArray)\n\t{\n\t\tif (!Array.isArray(pFileArray))\n\t\t{\n\t\t\tthis.log.error(`File Persistence Service attempted to write ${pFileName} from array but the expected array was not an array (it was a ${typeof(pFileArray)}).`);\n\t\t\treturn Error('Attempted to write ${pFileName} from array but the expected array was not an array (it was a ${typeof(pFileArray)}).');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (let i = 0; i < pFileArray.length; i++)\n\t\t\t{\n\t\t\t\treturn this.appendFileSync(pFileName, `${pFileArray[i]}\\n`);\n\t\t\t}\n\t\t}\n\t}\n\n\twriteFile(pFileName, pFileContent, pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = (typeof(pOptions) === 'undefined') ? 'utf8' : pOptions;\n\t\treturn libFS.writeFile(pFileName, pFileContent, tmpOptions, fCallback);\n\t}\n\n\tlineReaderFactory(pFilePath, fOnLine, fOnComplete, fOnError)\n\t{\n\t\tlet tmpLineReader = {};\n\n\t\tif (typeof(pFilePath) != 'string')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\ttmpLineReader.filePath = pFilePath;\n\n\t\ttmpLineReader.fileStream = libFS.createReadStream(tmpLineReader.filePath);\n\n\t\ttmpLineReader.reader = libReadline.createInterface({ input: tmpLineReader.fileStream, crlfDelay: Infinity });\n\n\t\tif (typeof(fOnError) === 'function')\n\t\t{\n\t\t\ttmpLineReader.reader.on('error', fOnError);\n\t\t}\n\n\t\ttmpLineReader.reader.on('line', (typeof(fOnLine) === 'function') ? fOnLine : () => {});\n\n\t\tif (typeof(fOnComplete) === 'function')\n\t\t{\n\t\t\ttmpLineReader.reader.on('close', fOnComplete);\n\t\t}\n\n\t\treturn tmpLineReader;\n\t}\n\n\t// Folder management\n\tmakeFolderRecursive(pParameters, fCallback)\n\t{\n\t\tlet tmpParameters = pParameters;\n\n\t\tif (typeof(pParameters) == 'string')\n\t\t{\n\t\t\ttmpParameters = { Path: pParameters };\n\t\t}\n\t\telse if (typeof(pParameters) !== 'object')\n\t\t{\n\t\t\tfCallback(new Error('Parameters object or string not properly passed to recursive folder create.'));\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(tmpParameters.Path) !== 'string'))\n\t\t{\n\t\t\tfCallback(new Error('Parameters object needs a path to run the folder create operation.'));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!('Mode' in tmpParameters))\n\t\t{\n\t\t\ttmpParameters.Mode = this.options.Mode;\n\t\t}\n\n\t\t// Check if we are just starting .. if so, build the initial state for our recursive function\n\t\tif (typeof(tmpParameters.CurrentPathIndex) === 'undefined')\n\t\t{\n\t\t\t// Build the tools to start recursing\n\t\t\ttmpParameters.ActualPath = libPath.normalize(tmpParameters.Path);\n\t\t\ttmpParameters.ActualPathParts = tmpParameters.ActualPath.split(libPath.sep);\n\t\t\ttmpParameters.CurrentPathIndex = 0;\n\t\t\ttmpParameters.CurrentPath = '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is not our first run, so we will continue the recursion.\n\t\t\t// Build the new base path\n\t\t\tif (tmpParameters.CurrentPath == libPath.sep)\n\t\t\t{\n\t\t\t\ttmpParameters.CurrentPath = tmpParameters.CurrentPath + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpParameters.CurrentPath = tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];\n\t\t\t}\n\n\t\t\t// Increment the path index\n\t\t\ttmpParameters.CurrentPathIndex++;\n\t\t}\n\n\t\t// Check if the path is fully complete\n\t\tif (tmpParameters.CurrentPathIndex >= tmpParameters.ActualPathParts.length)\n\t\t{\n\t\t\treturn fCallback(null);\n\t\t}\n\n\t\t// Check if the path exists (and is a folder)\n\t\tlibFS.open(tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex], 'r',\n\t\t\t(pError, pFileDescriptor)=>\n\t\t\t{\n\t\t\t\tif (pFileDescriptor)\n\t\t\t\t{\n\t\t\t\t\tlibFS.closeSync(pFileDescriptor);\n\t\t\t\t}\n\n\t\t\t\tif (pError && pError.code=='ENOENT')\n\t\t\t\t{\n\t\t\t\t\t/* Path doesn't exist, create it */\n\t\t\t\t\tlibFS.mkdir(tmpParameters.CurrentPath + libPath.sep + tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex], tmpParameters.Mode,\n\t\t\t\t\t\t(pCreateError) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!pCreateError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// We have now created our folder and there was no error -- continue.\n\t\t\t\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (pCreateError.code =='EEXIST')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The folder exists -- our dev might be running this in parallel/async/whatnot.\n\t\t\t\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconsole.log(pCreateError.code);\n\t\t\t\t\t\t\t\treturn fCallback(pCreateError);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn this.makeFolderRecursive(tmpParameters, fCallback);\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n\nmodule.exports = FableServiceFilePersistence;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceLogic extends libFableServiceBase\n{\n\t/**\n\t * @param {import('../Fable.js')} pFable - The fable object\n\t * @param {Record<string, any>} [pOptions] - The options object\n\t * @param {string} [pServiceHash] - The hash of the service\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t *\n\t * @param {string|number} pLeft - The left value to check\n\t * @param {string} pComparisonOperator - The comparison operator to use\n\t * @param {string|number} pRight - The right value to check\n\t * @param {any} pOnTrue - The value to return if the comparison is true\n\t * @param {any} [pOnFalse = ''] - The value to return if the comparison is false\n\t * @return {any} - The selected value\n\t */\n\tcheckIf(pLeft, pComparisonOperator, pRight, pOnTrue, pOnFalse)\n\t{\n\t\t// precise numeric\n\t\t// string (non-numeric)\n\t\tlet tmpMathLeft = this.fable.Math.parsePrecise(pLeft, null);\n\t\tlet tmpMathRight = this.fable.Math.parsePrecise(pRight, null);\n\t\tlet tmpCheckResult = false;\n\t\tif (tmpMathLeft === null || tmpMathRight === null)\n\t\t{\n\t\t\tif (typeof pOnFalse === 'undefined')\n\t\t\t{\n\t\t\t\tpOnFalse = '';\n\t\t\t}\n\t\t\tswitch (pComparisonOperator)\n\t\t\t{\n\t\t\t\tcase '<':\n\t\t\t\tcase 'LT':\n\t\t\t\t\ttmpCheckResult = pLeft < pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<=':\n\t\t\t\tcase 'LTE':\n\t\t\t\t\ttmpCheckResult = pLeft <= pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase 'GT':\n\t\t\t\t\ttmpCheckResult = pLeft > pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>=':\n\t\t\t\tcase 'GTE':\n\t\t\t\t\ttmpCheckResult = pLeft >= pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '==':\n\t\t\t\t\ttmpCheckResult = pLeft == pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '===':\n\t\t\t\t\ttmpCheckResult = pLeft === pRight;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.fable.log.warn(`[FableServiceLogic.checkIf] Invalid comparison operator: ${pComparisonOperator}`);\n\t\t\t\t\ttmpCheckResult = pLeft == pRight;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (typeof pOnFalse === 'undefined')\n\t\t\t{\n\t\t\t\tpOnFalse = '0';\n\t\t\t}\n\t\t\tswitch (pComparisonOperator)\n\t\t\t{\n\t\t\t\tcase '<':\n\t\t\t\tcase 'LT':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.ltPrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<=':\n\t\t\t\tcase 'LTE':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.ltePrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase 'GT':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.gtPrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>=':\n\t\t\t\tcase 'GTE':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.gtePrecise(tmpMathLeft, tmpMathRight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '==':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.comparePreciseWithin(tmpMathLeft, tmpMathRight, '0.000001') == 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '===':\n\t\t\t\t\ttmpCheckResult = this.fable.Math.comparePrecise(tmpMathLeft, tmpMathRight) == 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.fable.log.warn(`[FableServiceLogic.checkIf] Invalid comparison operator: ${pComparisonOperator}`);\n\t\t\t\t\ttmpCheckResult = pLeft == pRight ? pOnTrue : pOnFalse;\n\t\t\t}\n\t\t}\n\t\treturn tmpCheckResult ? pOnTrue : pOnFalse;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t *\n\t * @param {any} pCheckForTruthy - The object to check\n\t * @param {any} pOnTrue - The value to return if the object is truthy\n\t * @param {any} [pOnFalse = ''] - The value to return if the object is falsy\n\t * @return {any} - The value from the object\n\t */\n\twhen(pCheckForTruthy, pOnTrue, pOnFalse = '')\n\t{\n\t\tif (!pCheckForTruthy)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\tif (Array.isArray(pCheckForTruthy) && pCheckForTruthy.length < 1)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\tif (typeof pCheckForTruthy === 'object' && Object.keys(pCheckForTruthy).length < 1)\n\t\t{\n\t\t\treturn pOnFalse;\n\t\t}\n\t\treturn pOnTrue;\n\t}\n}\n\nmodule.exports = FableServiceLogic;\n","/**\n * @file Fable-Service-Math.js\n * @description This file contains the implementation of the FableServiceMath class, which provides simple functions for performing arbitrary precision math operations.\n * @module FableServiceMath\n * @extends libFableServiceBase\n */\nconst libFableServiceBase = require('fable-serviceproviderbase');\nconst libSetConcatArray = require('./Fable-SetConcatArray.js');\n\n/**\n * Arbitrary Precision Math Operations\n * @author      Steven Velozo <steven@velozo.com>\n * @description Simple functions that perform arbitrary precision math operations and return string resultant values.  Wraps big.js\n * @class FableServiceMath\n * @extends libFableServiceBase\n */\nclass FableServiceMath extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'Math';\n\n\t\tthis.pi = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679';\n\t\t// From NASA: https://apod.nasa.gov/htmltest/gifcity/e.2mil\n\t\tthis.euler = '2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664';\n\t\tthis.errorReturnValue = NaN;\n\n\t\t//\t\tthis.manifest = this.fable.newManyfest();\n\t\tthis.bigNumber = this.fable.Utility.bigNumber;\n\n\t\tthis.ln2Cache = new Map();\n\t}\n\n\t/*\n\t\tPass-through Rounding Method Constants\n\n\t\tProperty\t   Value   BigDecimal Equiv   Description\n\t\t----------     -----   ----------------   -----------\n\t\troundDown      0       ROUND_DOWN         Rounds towards zero. (_I.e. truncate, no rounding._)\n\t\troundHalfUp    1       ROUND_HALF_UP      Rounds towards nearest neighbour. (_If equidistant, rounds away from zero._)\n\t\troundHalfEven  2       ROUND_HALF_EVEN    Rounds towards nearest neighbour. (_If equidistant, rounds towards even neighbour._)\n\t\troundUp        3       ROUND_UP           Rounds positively away from zero. (_Always round up._)\n\t*/\n\tget roundDown() { return this.bigNumber.roundDown; }\n\tget roundHalfUp() { return this.bigNumber.roundHalfUp; }\n\tget roundHalfEven() { return this.bigNumber.roundHalfEven; }\n\tget roundUp() { return this.bigNumber.roundUp; }\n\n\t/**\n\t * Parses a precise number value.\n\t *\n\t * @param {number} pValue - The value to parse.\n\t * @param {any} pNonNumberValue - The value to use if parsing fails.\n\t * @returns {string} - The parsed number as a string.\n\t */\n\tparsePrecise(pValue, pNonNumberValue)\n\t{\n\t\tlet tmpNumber;\n\n\t\ttry\n\t\t{\n\t\t\ttmpNumber = new this.bigNumber(pValue);\n\t\t}\n\t\tcatch (pError)\n\t\t{\n\t\t\t// TODO: This seems more correct -- we can add a silent or noisy parameter if we want this to export.\n\t\t\t//       Reason: Currently this is absolutely obliterating logs in the data integrations from bad data sources.\n\t\t\t//this.log.warn(`Error parsing number (type ${typeof (pValue)}): ${pError}`);\n\t\t\ttmpNumber = (typeof (pNonNumberValue) === 'undefined') ? \"0.0\" : pNonNumberValue;\n\t\t}\n\n\t\treturn tmpNumber ? tmpNumber.toString() : tmpNumber;\n\t}\n\n\t/**\n\t * Assigns the given value.  For equals operations in the solver.\n\t * @param {*} pValue - The value to be assigned.\n\t * @returns {*} The assigned value.\n\t */\n\tassignValue(pValue)\n\t{\n\t\treturn pValue;\n\t}\n\n\t/**\n\t * Begins an expression with the given value. For performing colon operations in the solver.\n\t * @param {*} pValue - The value to begin the expression with.\n\t * @returns {*} The begun expression value.\n\t */\n\texpressionBegin(pValue)\n\t{\n\t\treturn pValue;\n\t}\n\n\t/**\n\t * Calculates the precise percentage of a given value compared to another value.\n\t *\n\t * @param {number} pIs - The value to calculate the percentage of.\n\t * @param {number} pOf - The value to calculate the percentage against.\n\t * @returns {string} The precise percentage as a string.\n\t */\n\tpercentagePrecise(pIs, pOf)\n\t{\n\t\tlet tmpLeftValue = isNaN(pIs) ? 0 : pIs;\n\t\tlet tmpRightValue = isNaN(pOf) ? 0 : pOf;\n\n\t\tif (tmpRightValue == 0)\n\t\t{\n\t\t\treturn '0';\n\t\t}\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.div(tmpRightValue);\n\t\ttmpResult = tmpResult.times(100);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Concatenates two value sets and returns the result as a string.\n\t *\n\t * Value sets are comma separated.\n\t *\n\t * Used for arbitrary precision set generation.\n\t *\n\t * @param {any} pLeftValue - The left value to append.\n\t * @param {any} pRightValue - The right value to append.\n\t * @returns {InstanceType<libSetConcatArray>} The concatenated string of the left and right values.\n\t */\n\tsetConcatenate(pLeftValue, pRightValue)\n\t{\n\t\treturn new libSetConcatArray(pLeftValue, pRightValue);\n\t}\n\n\t/**\n\t * Rounds a value to a specified number of decimal places using a specified rounding method.\n\t *\n\t * @param {number} pValue - The value to be rounded.\n\t * @param {number} pDecimals - The number of decimal places to round to.\n\t * @param {function} [pRoundingMethod] - The rounding method to use. Defaults to `this.roundHalfUp`.\n\t * @returns {string} - The rounded value as a string.\n\t */\n\troundPrecise(pValue, pDecimals, pRoundingMethod)\n\t{\n\t\tlet tmpValue = pValue === false || isNaN(pValue) ? 0 : pValue;\n\t\tlet tmpDecimals = isNaN(pDecimals) ? 0 : parseInt(pDecimals, 10);\n\t\tlet tmpRoundingMethod = (typeof (pRoundingMethod) === 'undefined') ? this.roundHalfUp : parseInt(pRoundingMethod, 10);\n\n\t\ttry\n\t\t{\n\t\t\tlet tmpArbitraryValue = new this.bigNumber(tmpValue);\n\t\t\tlet tmpResult = tmpArbitraryValue.round(tmpDecimals, tmpRoundingMethod);\n\t\t\treturn tmpResult.toString();\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\treturn this.errorReturnValue;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a string representation of a number with a specified number of decimals.\n\t *\n\t * @param {number} pValue - The number to be formatted.\n\t * @param {number} pDecimals - The number of decimals to include in the formatted string.\n\t * @param {string} [pRoundingMethod] - The rounding method to use. Defaults to 'roundHalfUp'.\n\t * @returns {string} - The formatted number as a string.\n\t */\n\ttoFixedPrecise(pValue, pDecimals, pRoundingMethod)\n\t{\n\t\tlet tmpValue = pValue === false || isNaN(pValue) ? 0 : pValue;\n\t\tlet tmpDecimals = isNaN(pDecimals) ? 0 : parseInt(pDecimals, 10);\n\t\tlet tmpRoundingMethod = (typeof (pRoundingMethod) === 'undefined') ? this.roundHalfUp : pRoundingMethod;\n\n\t\ttry\n\t\t{\n\t\t\tlet tmpArbitraryValue = new this.bigNumber(tmpValue);\n\t\t\tlet tmpResult = tmpArbitraryValue.toFixed(tmpDecimals, tmpRoundingMethod);\n\t\t\treturn tmpResult.toString();\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\treturn this.errorReturnValue;\n\t\t}\n\t}\n\n\t/**\n\t * Adds two values precisely.\n\t * @param {number|string} pLeftValue - The left value to be added.\n\t * @param {number|string} pRightValue - The right value to be added.\n\t * @returns {string} - The result of adding the two values as a string.\n\t */\n\taddPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.plus(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Subtracts two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to subtract.\n\t * @param {number|string} pRightValue - The right value to subtract.\n\t * @returns {string} The result of the subtraction as a string.\n\t */\n\tsubtractPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.minus(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the precise power of two numbers.\n\t *\n\t * @param {number} pLeftValue - The base value.\n\t * @param {number} pRightValue - The exponent value.\n\t * @returns {string} The result of raising the base value to the exponent value.\n\t */\n\tpowerPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : parseInt(pRightValue);\n\t\tlet tmpResult;\n\t\tif (tmpRightValue == Number(pRightValue))\n\t\t{\n\t\t\tconst tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\t\ttmpResult = tmpLeftArbitraryValue.pow(tmpRightValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//FIXME: big.js shits itself on non-integer exponents........................\n\t\t\ttmpResult = Math.pow(tmpLeftValue, Number(pRightValue));\n\t\t}\n\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Multiplies two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to multiply.\n\t * @param {number|string} pRightValue - The right value to multiply.\n\t * @returns {string} The result of the multiplication as a string.\n\t */\n\tmultiplyPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.times(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Divides two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to be divided.\n\t * @param {number|string} pRightValue - The right value to divide by.\n\t * @returns {string} The result of the division as a string.\n\t */\n\tdividePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.div(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the modulus of two values with precision.\n\t *\n\t * @param {number|string} pLeftValue - The left value.\n\t * @param {number|string} pRightValue - The right value.\n\t * @returns {string} The result of the modulus operation as a string.\n\t */\n\tmodPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.mod(tmpRightValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the square root of a number with precise decimal places.\n\t *\n\t * @param {number|string} pValue - The number to calculate the square root of.\n\t * @returns {string} The square root of the input number as a string.\n\t */\n\tsqrtPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.sqrt();\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the absolute value of a number precisely.\n\t *\n\t * @param {number|string} pValue - The number to calculate the absolute value of.\n\t * @returns {string} The absolute value of the input number as a string.\n\t */\n\tabsPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpValue);\n\t\tlet tmpResult = tmpLeftArbitraryValue.abs();\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the floor of a number precisely.\n\t *\n\t * @param {string|number} pValue - The number to calculate the floor value of.\n\t * @returns {string} The floor value of the input number as a string.\n\t */\n\tfloorPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpResult = Math.floor(tmpValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the ceiling of a number precisely.\n\t *\n\t * @param {number|string} pValue - The number to calculate the ceiling value of.\n\t * @returns {string} The ceiling value of the input number as a string.\n\t */\n\tceilPrecise(pValue)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? 0 : pValue;\n\n\t\tlet tmpResult = Math.ceil(tmpValue);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Compares two values precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {number} - Returns the result of the comparison.\n\t */\n\tcomparePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.cmp(tmpRightValue);\n\t}\n\n\t/**\n\t * Compares two values precisely within a tolerance.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @param {number|string} pEpsilon - The epsilon value for comparison.\n\t * @returns {number} - Returns the result of the comparison.\n\t */\n\tcomparePreciseWithin(pLeftValue, pRightValue, pEpsilon)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\tconst diff = tmpLeftArbitraryValue.minus(tmpRightValue).abs();\n\t\tif (diff.lte(pEpsilon))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (tmpLeftArbitraryValue.lt(tmpRightValue))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Determines if the left value is greater than the right value precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is greater than the right value, otherwise returns false.\n\t */\n\tgtPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.gt(tmpRightValue);\n\t}\n\n\t/**\n\t * Checks if the left value is greater than or equal to the right value.\n\t * If either value is not a number, it is treated as 0.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - True if the left value is greater than or equal to the right value, false otherwise.\n\t */\n\tgtePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.gte(tmpRightValue);\n\t}\n\n\t/**\n\t * Determines if the left value is less than the right value precisely.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is less than the right value, otherwise returns false.\n\t */\n\tltPrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.lt(tmpRightValue);\n\t}\n\n\t/**\n\t * Determines if the left value is less than or equal to the right value.\n\t *\n\t * @param {number|string} pLeftValue - The left value to compare.\n\t * @param {number|string} pRightValue - The right value to compare.\n\t * @returns {boolean} - Returns true if the left value is less than or equal to the right value, otherwise returns false.\n\t */\n\tltePrecise(pLeftValue, pRightValue)\n\t{\n\t\tlet tmpLeftValue = isNaN(pLeftValue) ? 0 : pLeftValue;\n\t\tlet tmpRightValue = isNaN(pRightValue) ? 0 : pRightValue;\n\n\t\tlet tmpLeftArbitraryValue = new this.bigNumber(tmpLeftValue);\n\t\treturn tmpLeftArbitraryValue.lte(tmpRightValue);\n\t}\n\n\t/**\n\t * Converts degrees to radians with arbitrary precision.\n\t *\n\t * @param {number|string} pDegrees - The degrees to convert to radians.\n\t * @returns {string} - The converted radians as a string.\n\t */\n\tradPrecise(pDegrees)\n\t{\n\t\tlet tmpDegrees = isNaN(pDegrees) ? 0 : pDegrees;\n\n\t\tlet tmpDegreesArbitraryValue = new this.bigNumber(tmpDegrees);\n\t\t// TODO: Const for pi in arbitrary precision?\n\t\tlet tmpResult = tmpDegreesArbitraryValue.times(Math.PI).div(180);\n\t\treturn tmpResult.toString();\n\t}\n\n\t/**\n\t * Calculates the value of pi with the specified precision.\n\t * If no precision is provided, returns 100 digits after the decimal.\n\t *\n\t * @param {number|string} [pPrecision] - The precision to use for calculating pi.\n\t * @returns {number} - The calculated value of pi.\n\t */\n\tpiPrecise(pPrecision)\n\t{\n\t\tif (typeof (pPrecision) === 'undefined')\n\t\t{\n\t\t\treturn this.pi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.roundPrecise(this.pi, pPrecision);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the value of euler with the specified precision.\n\t *\n\t * @param {number|string} [pPrecision] - The precision to use for calculating E.\n\t * @returns {string} - The calculated value of E.\n\t */\n\teulerPrecise(pPrecision)\n\t{\n\t\tif (typeof (pPrecision) === 'undefined')\n\t\t{\n\t\t\treturn this.euler;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.roundPrecise(this.euler, pPrecision);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the sine of the given angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The sine of the angle.\n\t */\n\tsin(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.sin(tmpRadians);\n\t}\n\n\t/**\n\t * Calculates the cosine of the given angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The cosine of the angle.\n\t */\n\tcos(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.cos(tmpRadians);\n\t}\n\n\t/**\n\t * Calculates the tangent of an angle in radians.\n\t *\n\t * @param {number} pRadians - The angle in radians.\n\t * @returns {number} The tangent of the angle.\n\t */\n\ttan(pRadians)\n\t{\n\t\tlet tmpRadians = isNaN(pRadians) ? 0 : pRadians;\n\t\treturn Math.tan(tmpRadians);\n\t}\n\n\t/* * * * * * * * * * * * * * * *\n\t * Set functions\n\t * These are meant to work fine with arrays and more complex set descriptions returned by Manyfest.\n\t * Manyfest sometimes returns values as arrays and sometimes as a map of addresses with values depending\n\t * on what was requested.\n\t *\n\t * The following functions will likely be broken into their own service.\n\t */\n\n\t/**\n\t * Counts the number of elements in a set.\n\t *\n\t * @param {Array|Object|any} pValueSet - The set to count the elements of.\n\t * @returns {number} The number of elements in the set.\n\t */\n\tcountSetElements(pValueSet)\n\t{\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\treturn pValueSet.length;\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\treturn Object.keys(pValueSet).length;\n\t\t}\n\t\telse if (pValueSet)\n\t\t{\n\t\t\t// This is controversial.  Discuss with colleagues!\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Sorts the elements in the given value set in ascending order using the precise parsing and comparison.\n\t *\n\t * @param {Array|Object} pValueSet - The value set to be sorted.\n\t * @returns {Array} - The sorted value set.\n\t */\n\tsortSetPrecise(pValueSet)\n\t{\n\t\tlet tmpSortedSet = [];\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\ttmpSortedSet.push(this.parsePrecise(pValueSet[i], NaN));\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\ttmpSortedSet.push(this.parsePrecise(pValueSet[tmpKeys[i]], NaN));\n\t\t\t}\n\t\t}\n\n\t\ttmpSortedSet.sort((pLeft, pRight) => { return this.comparePrecise(pLeft, pRight); });\n\n\t\treturn tmpSortedSet;\n\t}\n\n\t/**\n\t * Bucketizes a set of values based on a specified bucket size.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to be bucketized.\n\t * @param {number} [pBucketSize] - The size of each bucket. Optional - If NaN, the values will be bucketized by their value.\n\t * @returns {Object} - The bucketized set of values.\n\t */\n\tbucketSetPrecise(pValueSet, pBucketSize)\n\t{\n\t\tlet tmpBucketedSet = {};\n\t\tlet tmpBucketSize = this.parsePrecise(pBucketSize, NaN);\n\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\tlet tmpBucket = tmpValue.toString();\n\t\t\t\tif (!isNaN(tmpBucketSize))\n\t\t\t\t{\n\t\t\t\t\ttmpBucket = this.dividePrecise(pValueSet[i], tmpBucketSize);\n\t\t\t\t}\n\t\t\t\tif (!(tmpBucket in tmpBucketedSet))\n\t\t\t\t{\n\t\t\t\t\ttmpBucketedSet[tmpBucket] = 0;\n\t\t\t\t}\n\t\t\t\ttmpBucketedSet[tmpBucket] = tmpBucketedSet[tmpBucket] + 1;\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\tlet tmpBucket = tmpValue.toString();\n\t\t\t\tif (!isNaN(tmpBucketSize))\n\t\t\t\t{\n\t\t\t\t\ttmpBucket = this.dividePrecise(pValueSet[i], tmpBucketSize);\n\t\t\t\t}\n\t\t\t\tif (!(tmpBucket in tmpBucketedSet))\n\t\t\t\t{\n\t\t\t\t\ttmpBucketedSet[tmpBucket] = 0;\n\t\t\t\t}\n\t\t\t\ttmpBucketedSet[tmpBucket] = tmpBucketedSet[tmpBucket] + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpBucketedSet;\n\t}\n\n\t/**\n\t * Calculates the histogram using precise bucket set for the given pValueSet.\n\t *\n\t * @param {Array<number>} pValueSet - The array of p-values.\n\t * @returns {Array<number>} The histogram of the p-values.\n\t */\n\thistogramPrecise(pValueSet)\n\t{\n\t\treturn this.bucketSetPrecise(pValueSet);\n\t}\n\n\t/**\n\t * Sorts the histogram object in ascending order based on the frequencies of the buckets.\n\t *\n\t * @param {Object} pHistogram - The histogram object to be sorted.\n\t * @returns {Object} - The sorted histogram object.\n\t */\n\tsortHistogramPrecise(pHistogram)\n\t{\n\t\tlet tmpSortedHistogram = {};\n\t\tlet tmpKeys = Object.keys(pHistogram);\n\n\t\ttmpKeys.sort((pLeft, pRight) => { return pHistogram[pLeft] - pHistogram[pRight]; });\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpSortedHistogram[tmpKeys[i]] = pHistogram[tmpKeys[i]];\n\t\t}\n\n\t\treturn tmpSortedHistogram;\n\t}\n\n\t/**\n\t * Sorts the histogram object in ascending order based on the keys.\n\t *\n\t * @param {Object} pHistogram - The histogram object to be sorted.\n\t * @returns {Object} - The sorted histogram object.\n\t */\n\tsortHistogramByKeys(pHistogram, pDescending)\n\t{\n\t\tlet tmpSortedHistogram = {};\n\t\tlet tmpKeys = Object.keys(pHistogram);\n\t\tlet tmpDescending = (typeof (pDescending) === 'undefined') ? false : pDescending;\n\n\t\t// Sort tmpKeys by the string comparison\n\t\ttmpKeys.sort();\n\n\t\tif (tmpDescending)\n\t\t{\n\t\t\ttmpKeys = tmpKeys.reverse();\n\t\t}\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpSortedHistogram[tmpKeys[i]] = pHistogram[tmpKeys[i]];\n\t\t}\n\n\t\treturn tmpSortedHistogram;\n\t}\n\n\tcleanValueArray(pValueArray, pRemoveZeroes)\n\t{\n\t\tlet tmpRemoveZeroes = (typeof (pRemoveZeroes) === 'undefined') ? false : pRemoveZeroes;\n\n\t\tif (!Array.isArray(pValueArray))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpCleanedArray = [];\n\t\tfor (let i = 0; i < pValueArray.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(pValueArray[i], NaN);\n\t\t\tif (!isNaN(tmpValue) && (!tmpRemoveZeroes || (tmpValue != \"0\")))\n\t\t\t{\n\t\t\t\ttmpCleanedArray.push(tmpValue);\n\t\t\t}\n\t\t}\n\t\treturn tmpCleanedArray;\n\t}\n\n\t/**\n\t * Calculate the natural log of 2 to a specific precision, for use in the Taylor series.\n\t * Cache outcome so it only runs once per precision.\n\t * @param {number} pPrecision - The decimal precision to calculate ln(2) to.\n\t * @returns\n\t */\n\tarbitraryNaturalLogOfTwo(pPrecision)\n\t{\n\t\tconst tmpPrecisionKey = pPrecision | 0;\n\t\tconst tmpPrecision = new this.bigNumber(tmpPrecisionKey);\n\t\tif (this.ln2Cache.has(tmpPrecisionKey))\n\t\t{\n\t\t\treturn this.ln2Cache.get(tmpPrecisionKey);\n\t\t}\n\n\t\tconst tmpTwoConstant = new this.bigNumber(2);\n\t\tconst y = tmpTwoConstant.minus(1).div(tmpTwoConstant.plus(1)); // 1/3\n\t\tconst y2 = y.mul(y);\n\t\tlet tmpSummation = new this.bigNumber(0);\n\t\tlet tmpTermination = y;\n\t\tlet tmpDenominator = 1;\n\n\t\t// Use a slightly larger precision for this to prevent numeric drift for larger log requirements\n\t\tconst tmpEpsilon = this.powerPrecise(10, -(tmpPrecision.add(8))); // target tail < 10^-(precision+8)\n\n\t\tfor (let i = 0; i < 200000; i++)\n\t\t{\n\t\t\ttmpSummation = tmpSummation.plus(tmpTermination.div(tmpDenominator));\n\t\t\ttmpTermination = tmpTermination.mul(y2);\n\t\t\ttmpDenominator += 2;\n\t\t\tif (tmpTermination.abs().div(tmpDenominator).lt(tmpEpsilon))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst tmpNaturalLogOfTwo = tmpSummation.mul(2);\n\t\tthis.ln2Cache.set(tmpPrecisionKey, tmpNaturalLogOfTwo);\n\t\treturn tmpNaturalLogOfTwo;\n\t}\n\n\t/**\n\t * Calculate the natural log of a number to a specific precision using arbitrary precision numbers.\n\t * @param {number} pNumberToCompute\n\t * @param {number} pPrecision\n\t * @returns\n\t */\n\tarbitraryNaturalLog(pNumberToCompute, pPrecision)\n\t{\n\t\tlet tmpNumberToCompute = new this.bigNumber(pNumberToCompute);\n\t\tlet tmpPrecision = new this.bigNumber(pPrecision);\n\n\t\tif (tmpNumberToCompute.lte(0)) throw new Error('ln undefined for non-positive values.');\n\t\tif (tmpNumberToCompute.eq(1)) return new this.bigNumber(0);\n\n\t\t// Reduce x to m in ~[0.75, 1.5] by multiplying/dividing by 2\n\t\tconst TWO = new this.bigNumber(2);\n\t\tlet k = 0;\n\t\tlet m = tmpNumberToCompute;\n\n\t\tconst tmpUpperBounds = new this.bigNumber('1.5');\n\t\tconst tmpLowerBounds = new this.bigNumber('0.75');\n\n\t\twhile (m.gt(tmpUpperBounds))\n\t\t{\n\t\t\tm = m.div(TWO); k += 1;\n\t\t}\n\t\twhile (m.lt(tmpLowerBounds))\n\t\t{\n\t\t\tm = m.mul(TWO); k -= 1;\n\t\t}\n\n\t\t// ln(m) via atanh/Taylor\n\t\tconst y = m.minus(1).div(m.plus(1)); // |y| < 1\n\t\tconst y2 = y.mul(y);\n\n\t\tlet tmpSummation = new this.bigNumber(0);\n\t\tlet tmpSeriesTermination = y; // y^(2j+1)\n\t\tlet tmpDenominator = 1;\n\n\t\tconst tmpEpsilon = this.powerPrecise(10, -(tmpPrecision.add(6))); // target tail < 10^-(precision+6)\n\n\t\t// Iterate until next term contribution is below eps\n\t\tfor (let i = 0; i < 200000; i++)\n\t\t{\n\t\t\ttmpSummation = tmpSummation.plus(tmpSeriesTermination.div(tmpDenominator));\n\t\t\ttmpSeriesTermination = tmpSeriesTermination.mul(y2);\n\t\t\ttmpDenominator += 2;\n\t\t\t// Stop when |tmpSeriesTermination|/tmpDenominator < eps\n\t\t\tif (tmpSeriesTermination.abs().div(tmpDenominator).lt(tmpEpsilon))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst tmpNaturalLog = tmpSummation.mul(2);\n\n\t\t// ln(2) once per precision via same series with m=2 (y = 1/3 ==> for faster convergence)\n\t\tconst tmpPrecisionNaturalLog = this.arbitraryNaturalLogOfTwo(tmpPrecision);\n\n\t\treturn tmpNaturalLog.plus(tmpPrecisionNaturalLog.mul(k));\n\t}\n\n\t/**\n\t * High-precision natural log using:\n\t *  - Argument reduction by powers of 2: x = m * 2^k with m ~ 1\n\t *  - atanh series: ln(m) = 2 * sum_{j>=0} y^(2j+1)/(2j+1), y=(m-1)/(m+1), |y|<1\n\t *\n\t * Converges rapidly when m is close to 1 with arbitrary precision numbers.\n\t *\n\t * @param {number} pNumberToGenerateLogarithmFor - The number to generate the logarithm for.\n\t * @param {number} [pBase] - The base of the logarithm. Defaults to 10.\n\t * @param {number} [pPrecision] - The precision of the result. Defaults to 9 decimal places.\n\t * @returns {string} - The logarithm of the number to the specified base and precision.\n\t */\n\tlogPrecise(pNumberToGenerateLogarithmFor, pBase, pPrecision)\n\t{\n\t\tlet tmpBase = (typeof (pBase) === 'undefined') ? this.bigNumber(10) : this.bigNumber(pBase);\n\t\t// Default precision is 9 decimal places -- matches Excel's default for LOG function\n\t\tconst tmpPrecision = (typeof (pPrecision) === 'undefined') ? 9 : pPrecision;\n\t\t// Extra precision to avoid rounding errors since we are using a series\n\t\tconst tmpExtraPrecision = 8;\n\t\tconst tmpWorkingPrecision = tmpPrecision + tmpExtraPrecision;\n\n\t\t// Store existing precision since this function integrates on a its own precision terms\n\t\tconst tmpSavedBigDecimalPrecision = this.bigNumber.DP;\n\t\tconst tmpSavedBigRoundingMethod = this.bigNumber.RM;\n\n\t\tthis.bigNumber.DP = tmpWorkingPrecision;\n\t\tthis.bigNumber.RM = 1; // round half up for the Taylor series\n\n\t\tconst N = this.bigNumber(pNumberToGenerateLogarithmFor);\n\t\tconst B = this.bigNumber(tmpBase);\n\n\t\t// Run domain checks, which Excel also does\n\t\tif (N.lte(0))\n\t\t{\n\t\t\tthis.log.error(`Fable logPrecise Error: Number must be greater than 0; number was ${pNumberToGenerateLogarithmFor}.`);\n\t\t\treturn NaN;\n\t\t}\n\t\tif (B.lte(0) || B.eq(1))\n\t\t{\n\t\t\tthis.log.error(`Fable logPrecise Error: Base must be greater than 0 and not equal to 1 -- base ${Base} was passed in.`);\n\t\t\treturn NaN;\n\t\t}\n\n\t\tconst tmpNaturalLogOfN = this.arbitraryNaturalLog(N, tmpPrecision);\n\t\tconst tmpNaturalLogOfB = this.arbitraryNaturalLog(B, tmpPrecision);\n\n\t\tconst tmpResult = tmpNaturalLogOfN.div(tmpNaturalLogOfB);\n\n\t\t// Final rounding to requested precision\n\t\tlet finalResult = tmpResult.toFixed(tmpPrecision);\n\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\tthis.bigNumber.RM = tmpSavedBigRoundingMethod;\n\t\treturn finalResult;\n\t}\n\n\texpPrecise(pValue, pDecimalPrecision)\n\t{\n\t\tlet tmpValue = isNaN(pValue) ? this.bigNumber(1) : this.bigNumber(pValue);\n\n\t\t// Constants & thresholds (Excel / IEEE-754 double limits) -- this is required to match Excel's behavior\n\t\tconst tmpDecimalPrecision = (typeof (pDecimalPrecision) === 'undefined') ? 9 : parseInt(pDecimalPrecision, 10);\n\t\tconst tmpSavedBigDecimalPrecision = this.bigNumber.DP;\n\t\tthis.bigNumber.DP = tmpDecimalPrecision + 10; // a bit of extra precision for rounding safety (this makes it match excel)\n\n\t\t// ln(2), min/max natural logs before double overflow/underflow\n\t\tconst tmpNaturalLogOfTwo = new this.bigNumber('0.693147180559945309417232121458176568'); // This is hilarious that we can compute the value above but this is what Excel uses.\n\t\tconst tmpNaturalLogMaxDouble = new this.bigNumber('709.782712893384'); // ln(1.7976931348623157e308)\n\t\tconst tmpNaturalLogMinimumValue = new this.bigNumber('-744.4400719213812'); // ln(5e-324)\n\n\t\t// 1. Guard for Overflow / underflow behavior to match Excel\n\t\tif (tmpValue.gt(tmpNaturalLogMaxDouble))\n\t\t{\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn NaN; // Excel shows #NUM! when result overflows we will use NaN\n\t\t}\n\t\tif (tmpValue.lt(tmpNaturalLogMinimumValue))\n\t\t{\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn new this.bigNumber(0); // Excel underflows to 0\n\t\t}\n\n\t\t// 2. Perform Range reduction: x = k*ln2 + r, with r small\n\t\t// k = floor(x / ln2)\n\t\tlet k;\n\t\ttry\n\t\t{\n\t\t\tk = tmpValue.div(tmpNaturalLogOfTwo).round(0, 0 /* RoundDown toward -infinity */); // floor for positives & negatives\n\t\t}\n\t\tcatch(pErrorRounding)\n\t\t{\n\t\t\tthis.log.error(`Fable expPrecise Error: Rounding error during range reduction for value of ${pValue}.  Error: ${pErrorRounding}`);\n\t\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\t\treturn NaN;\n\t\t}\n\t\tconst r = tmpValue.minus(k.times(tmpNaturalLogOfTwo));\n\n\t\t// Compute exp(r) via Taylor series with Big arithmetic\n\t\t// exp(r) = Summation of r^n / n!, n=0..infinity\n\t\t// Sum until termination is below tolerance based on decimal precision\n\t\tconst tmpTolerance = new this.bigNumber(10).pow(-(tmpDecimalPrecision + 2));\n\t\tlet tmpTermination = new this.bigNumber(1); // r^0/0! = 1\n\t\tlet tmpSummation = new this.bigNumber(1);\n\t\tlet n = 1;\n\n\t\t// 3. Multiply incrementally: term *= r / n\n\t\t// SOOOOO close to a fractal!\n\t\twhile (true)\n\t\t{\n\t\t\ttmpTermination = tmpTermination.times(r).div(n);\n\t\t\tif (tmpTermination.abs().lt(tmpTolerance)) break;\n\t\t\ttmpSummation = tmpSummation.plus(tmpTermination);\n\t\t\tn++;\n\t\t\t// Hard safety cap for pathological inputs (shouldnt be possible with step 2's range reduction):\n\t\t\tif (n > 2000)\n\t\t\t{\n\t\t\t\tthis.log.warn(`Fable expPrecise warning: Taylor series failed to converge after 2000 iterations for value of ${pValue}.`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 4. Recompose: exp(x) = 2^k * exp(r)\n\t\tconst tmpTwo = new this.bigNumber(2);\n\t\tconst tmpAbsoluteValueOfK = k.abs().toNumber(); // k is integer; big.js pow requires a JS integer\n\t\tlet tmpTwoToThePowerOfAbsoluteK = tmpAbsoluteValueOfK === 0 ? new this.bigNumber(1) : tmpTwo.pow(tmpAbsoluteValueOfK);\n\t\tconst tmpResult = k.gte(0) ? tmpSummation.times(tmpTwoToThePowerOfAbsoluteK) : tmpSummation.div(tmpTwoToThePowerOfAbsoluteK);\n\n\t\t// 5. Restore global decimal precision\n\t\tthis.bigNumber.DP = tmpSavedBigDecimalPrecision;\n\t\treturn tmpResult.round(tmpDecimalPrecision).toString();\n\t}\n\n\tcleanValueObject(pValueObject)\n\t{\n\t\tif (typeof (pValueObject) !== 'object')\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\t//TODO: is this right?\n\t\tlet tmpCleanedObject = {};\n\t\tlet tmpKeys = Object.keys(pValueObject);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(pValueObject[tmpKeys[i]], NaN);\n\t\t\tif (!isNaN(tmpValue))\n\t\t\t{\n\t\t\t\ttmpCleanedObject[tmpKeys[i]] = tmpValue;\n\t\t\t}\n\t\t}\n\t\treturn tmpCleanedObject;\n\t}\n\n\t/**\n\t * Make a histogram of representative counts for exact values (.tostring() is the keys to count)\n\t * @param {Array} pValueSet\n\t * @param {string} pValueAddress\n\t */\n\thistogramDistributionByExactValue(pValueObjectSet, pValueAddress, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpHistogram = {};\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest).toString();\n\n\t\t\tif (!(tmpValue in tmpHistogram))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = 0;\n\t\t\t}\n\t\t\ttmpHistogram[tmpValue] = tmpHistogram[tmpValue] + 1;\n\t\t}\n\n\t\treturn tmpHistogram;\n\t}\n\n\thistogramDistributionByExactValueFromInternalState(pValueObjectSetAddress, pValueAddress)\n\t{\n\t\tif (!pValueObjectSetAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObjectSet = this.fable.Utility.getInternalValueByHash(pValueObjectSetAddress);\n\t\treturn this.histogramDistributionByExactValue(tmpValueObjectSet, pValueAddress);\n\t}\n\n\t/**\n\t * Make a histogram of representative counts for exact values (.tostring() is the keys to count)\n\t * @param {Array} pValueSet\n\t * @param {string} pValueAddress\n\t */\n\thistogramAggregationByExactValue(pValueObjectSet, pValueAddress, pValueAmountAddress, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress || !pValueAmountAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpHistogram = {};\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest);\n\t\t\tif (typeof(tmpValue) === undefined)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tmpAmount = this.parsePrecise(this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAmountAddress, pManifest), NaN);\n\n\t\t\tif (!(tmpValue in tmpHistogram))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = 0;\n\t\t\t}\n\n\t\t\tif (!isNaN(tmpAmount))\n\t\t\t{\n\t\t\t\ttmpHistogram[tmpValue] = this.addPrecise(tmpHistogram[tmpValue], tmpAmount);\n\t\t\t}\n\t\t}\n\n\t\treturn tmpHistogram;\n\t}\n\n\t/**\n\t * Aggregates a histogram by exact value from an internal state object.\n\t *\n\t * @param {string} pValueObjectSetAddress - The address of the internal value object set.\n\t * @param {string} pValueAddress - The address of the value to aggregate by.\n\t * @param {string} pValueAmountAddress - The address of the amount to aggregate.\n\t * @returns {Object} The aggregated histogram object. Returns an empty object if the value object set address is not provided.\n\t */\n\thistogramAggregationByExactValueFromInternalState(pValueObjectSetAddress, pValueAddress, pValueAmountAddress)\n\t{\n\t\tif (!pValueObjectSetAddress)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObjectSet = this.fable.Utility.getInternalValueByHash(pValueObjectSetAddress);\n\t\treturn this.histogramAggregationByExactValue(tmpValueObjectSet, pValueAddress, pValueAmountAddress);\n\t}\n\n\t/**\n\t * Given a value object set (an array of objects), find a specific entry when\n\t * sorted by a specific value address.  Supports -1 syntax for last entry.\n\t * @param {Array} pValueObjectSet\n\t * @param {string} pValueAddress\n\t * @param {Object} pManifest\n\t */\n\tentryInSet(pValueObjectSet, pValueAddress, pEntryIndex)\n\t{\n\t\tconst tmpEntryIndex = typeof pEntryIndex === 'number' ? pEntryIndex : parseInt(pEntryIndex);\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isNaN(tmpEntryIndex) || tmpEntryIndex >= pValueObjectSet.length)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpValueArray = pValueObjectSet.toSorted((pLeft, pRight) => { return this.comparePrecise(pLeft[pValueAddress], pRight[pValueAddress]); });\n\t\tlet tmpIndex = (tmpEntryIndex < 0) ? tmpValueArray.length + tmpEntryIndex : tmpEntryIndex;\n\t\treturn tmpValueArray[tmpIndex];\n\t}\n\n\t/**\n\t * Finds the smallest value in a set of objects based on a specified value address.\n\t *\n\t * @param {Object[]} pValueObjectSet - An array of objects to search through.\n\t * @param {string} pValueAddress - The key or path used to access the value within each object.\n\t * @returns {*} The smallest value found in the set at the specified value address.\n\t */\n\tsmallestInSet(pValueObjectSet, pValueAddress)\n\t{\n\t\treturn this.entryInSet(pValueObjectSet, pValueAddress, 0);\n\t}\n\n\t/**\n\t * Finds the largest value in a set of objects based on a specified value address.\n\t *\n\t * @param {Object[]} pValueObjectSet - An array of objects to search through.\n\t * @param {string} pValueAddress - The address (key or path) within each object to compare values.\n\t * @returns {*} The largest value found at the specified address in the set of objects.\n\t */\n\tlargestInSet(pValueObjectSet, pValueAddress)\n\t{\n\t\treturn this.entryInSet(pValueObjectSet, pValueAddress, -1);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to sum.  Expects\n\t * an address to put the cumulative summation as well.\n\t *\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {Object} pManifest - The manifest to use for value retrieval and setting\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\tcumulativeSummation(pValueObjectSet, pValueAddress, pCumulationResultAddress, pManifest)\n\t{\n\t\treturn this.iterativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, \"1.0\", \"add\", \"0.0\", true, pManifest);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to sum.  Expects\n\t * an address to put the cumulative summation as well.\n\t *\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {string} pStartingValue - The (optional) address of the value to start with\n\t * @param {Object} pManifest - The manifest to use for value retrieval and setting\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\tsubtractingSummation(pValueObjectSet, pValueAddress, pCumulationResultAddress, pStartingValue, pManifest)\n\t{\n\t\tlet tmpProcessFirstRow = true;\n\t\t// If the starting value comes from somewhere else, we want to subtract the first row from it.\n\t\tif (typeof (pStartingValue) === 'undefined' || pStartingValue === null)\n\t\t{\n\t\t\ttmpProcessFirstRow = false;\n\t\t}\n\t\treturn this.iterativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, \"1.0\", \"subtract\", pStartingValue, tmpProcessFirstRow, pManifest);\n\t}\n\n\t/**\n\t * Expects an array of objects, and an address in each object to perform an iterative mathematical operation on.\n\n\t * @param {Array} pValueObjectSet - The array of objects to perform a cumulative summation on\n\t * @param {string} pValueAddress - The address of the column in each object to sum\n\t * @param {string} pValueMultiplier - The multiplier to apply to each value before summation\n\t * @param {string} pSummationOperation - The operation to perform for summation: +, -, *, / (and some textual equivalents)\n\t * @param {string} pCumulationResultAddress - The address in each object to put the cumulative summation result\n\t * @param {string} pStartingValue - The address of the value to process from; defaults to the first row\n\t * @param {boolean} pProcessFirstRowWithAValue - Whether to process the first row's value from all subsequent rows\n\t * @param {Object} pManifest - The manifest to\n\t * @returns {Array} The updated value object set with cumulative summation results.\n\t */\n\titerativeSeries(pValueObjectSet, pValueAddress, pCumulationResultAddress, pValueMultiplier, pSummationOperation, pStartingValue, pProcessFirstRowWithAValue, pManifest)\n\t{\n\t\tif (!Array.isArray(pValueObjectSet))\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\tif (!pValueAddress || !pCumulationResultAddress)\n\t\t{\n\t\t\treturn pValueObjectSet;\n\t\t}\n\n\t\t// By default don't subtract the first row from the value\n\t\tlet tmpProcessFirstRow = (typeof(pProcessFirstRowWithAValue) === 'undefined') ? false : pProcessFirstRowWithAValue;\n\n\t\tlet tmpValueMultiplier;\n\t\tif (pValueMultiplier && pValueMultiplier !== '')\n\t\t{\n\t\t\ttmpValueMultiplier = this.parsePrecise(pValueMultiplier);\n\t\t}\n\t\tif (isNaN(tmpValueMultiplier))\n\t\t{\n\t\t\ttmpValueMultiplier = this.parsePrecise(\"1.0\");\n\t\t}\n\n\t\t// Default to start from the current value address\n\t\tlet tmpSummationValue;\n\t\t// This logic ensures we don't default to 0 when pStartingValue is an empty string\n\t\tif (pStartingValue || (pStartingValue !== ''))\n\t\t{\n\t\t\ttmpSummationValue = this.parsePrecise(pStartingValue);\n\t\t}\n\t\tif (isNaN(tmpSummationValue) || typeof(pStartingValue) === 'undefined' || pStartingValue === null)\n\t\t{\n\t\t\ttmpSummationValue = '';\n\t\t}\n\n\t\tfor (let i = 0; i < pValueObjectSet.length; i++)\n\t\t{\n\t\t\tlet tmpValue = this.parsePrecise(this.fable.Utility.getValueByHash(pValueObjectSet[i], pValueAddress, pManifest));\n\t\t\t// Since summation might start on a row after the first,\n\t\t\tlet tmpFirstRowWithValue = false;\n\t\t\tif ((tmpSummationValue === '') && tmpValue && !isNaN(tmpSummationValue))\n\t\t\t{\n\t\t\t\t// Try to grab the summation value from the first row with a value\n\t\t\t\ttmpSummationValue = tmpValue;\n\t\t\t\ttmpFirstRowWithValue = true;\n\t\t\t}\n\n\t\t\t// Continue on with the values as they are if the current row doesn't have a change\n\t\t\tif (isNaN(tmpValue))\n\t\t\t{\n\t\t\t\tthis.fable.Utility.setValueByHash(pValueObjectSet[i], pCumulationResultAddress, tmpSummationValue, pManifest);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmpValue = this.multiplyPrecise(tmpValue, tmpValueMultiplier);\n\n\t\t\t// Now perform the operation\n\t\t\tif (!tmpFirstRowWithValue || tmpProcessFirstRow)\n\t\t\t{\n\t\t\t\tswitch (pSummationOperation)\n\t\t\t\t{\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase 'add':\n\t\t\t\t\tcase 'plus':\n\t\t\t\t\tcase 'addition':\n\t\t\t\t\t\ttmpSummationValue = this.addPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase 'sub':\n\t\t\t\t\tcase 'minus':\n\t\t\t\t\tcase 'subtract':\n\t\t\t\t\t\ttmpSummationValue = this.subtractPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase 'mul':\n\t\t\t\t\tcase 'times':\n\t\t\t\t\tcase 'multiply':\n\t\t\t\t\t\ttmpSummationValue = this.multiplyPrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase 'div':\n\t\t\t\t\tcase 'over':\n\t\t\t\t\tcase 'divide':\n\t\t\t\t\t\ttmpSummationValue = this.dividePrecise(tmpSummationValue, tmpValue);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.fable.Utility.setValueByHash(pValueObjectSet[i], pCumulationResultAddress, tmpSummationValue, pManifest);\n\t\t}\n\n\t\treturn pValueObjectSet;\n\t}\n\n\t/**\n\t * Finds the maximum value from a set of precise values.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to find the maximum from.\n\t * @returns {number} - The maximum value from the set.\n\t */\n\tmaxPrecise(pValueSet)\n\t{\n\t\tlet tmpMaxValue = NaN;\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMaxValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMaxValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t\tif (this.gtPrecise(tmpComparisonValue, tmpMaxValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMaxValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMaxValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMaxValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t\tif (this.gtPrecise(tmpComparisonValue, tmpMaxValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMaxValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpMaxValue;\n\t}\n\n\t/**\n\t * Finds the minimum value from a set of values.\n\t *\n\t * @param {Array|Object} pValueSet - The set of values to find the minimum from.\n\t * @returns {number} The minimum value from the set.\n\t */\n\tminPrecise(pValueSet)\n\t{\n\t\tlet tmpMinValue = NaN;\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMinValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMinValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\t\tif (!isNaN(tmpComparisonValue) && this.ltPrecise(tmpComparisonValue, tmpMinValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMinValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (!tmpMinValue)\n\t\t\t\t{\n\t\t\t\t\ttmpMinValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\t\tif (!isNaN(tmpComparisonValue) && this.ltPrecise(tmpComparisonValue, tmpMinValue))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpMinValue = tmpComparisonValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpMinValue;\n\t}\n\n\t/**\n\t * Calculates the precise sum of values in the given value set.\n\t *\n\t * @param {Array|Object} pValueSet - The value set to calculate the sum from.\n\t * @returns {string} The precise sum value as a string.\n\t */\n\tsumPrecise(pValueSet)\n\t{\n\t\tlet tmpSumValue = \"0.0\";\n\t\tif (Array.isArray(pValueSet))\n\t\t{\n\t\t\tfor (let i = 0; i < pValueSet.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[i], NaN);\n\t\t\t\tif (!isNaN(tmpComparisonValue))\n\t\t\t\t{\n\t\t\t\t\ttmpSumValue = this.addPrecise(tmpSumValue, tmpComparisonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof (pValueSet) === 'object')\n\t\t{\n\t\t\tlet tmpKeys = Object.keys(pValueSet);\n\t\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpComparisonValue = this.parsePrecise(pValueSet[tmpKeys[i]], NaN);\n\t\t\t\tif (!isNaN(tmpComparisonValue))\n\t\t\t\t{\n\t\t\t\t\ttmpSumValue = this.addPrecise(tmpSumValue, tmpComparisonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmpSumValue;\n\t}\n\n\t/**\n\t * Calculates the precise mean of a given value set.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the mean.\n\t * @returns {string} The precise mean value as a string.\n\t */\n\tmeanPrecise(pValueSet)\n\t{\n\t\tlet tmpSumValue = this.sumPrecise(pValueSet);\n\t\tlet tmpCount = this.countSetElements(pValueSet);\n\t\tif (tmpCount == 0)\n\t\t{\n\t\t\treturn '0.0';\n\t\t}\n\t\treturn this.dividePrecise(tmpSumValue, tmpCount);\n\t}\n\n\t/**\n\t * Calculates the average of an array of values precisely.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the average of.\n\t * @returns {string} The precise average of the values.\n\t */\n\taveragePrecise(pValueSet)\n\t{\n\t\treturn this.meanPrecise(pValueSet);\n\t}\n\n\t/**\n\t * Calculates the precise median value of a given value set.\n\t *\n\t * @param {Array<number>} pValueSet - The array of values to calculate the median from.\n\t * @returns {number|string} - The median value of the given value set. If the value set is empty, returns '0.0'.\n\t */\n\tmedianPrecise(pValueSet)\n\t{\n\t\tlet tmpCount = this.countSetElements(pValueSet);\n\t\t// If there are no elements, return 0 ... should this be NaN?\n\t\tif (tmpCount == 0)\n\t\t{\n\t\t\treturn '0.0';\n\t\t}\n\n\t\tlet tmpSortedValueSet = this.sortSetPrecise(pValueSet);\n\t\tlet tmpMiddleElement = Math.floor(tmpCount / 2);\n\n\t\t// If the count is odd, return the middle element\n\t\tif (tmpCount % 2 == 1)\n\t\t{\n\t\t\treturn tmpSortedValueSet[tmpMiddleElement];\n\t\t}\n\t\t// If the count is even, return the average of the two middle elements\n\t\telse\n\t\t{\n\t\t\tlet tmpLeftMiddleValue = tmpSortedValueSet[tmpMiddleElement - 1];\n\t\t\tlet tmpRightMiddleValue = tmpSortedValueSet[tmpMiddleElement];\n\t\t\treturn this.dividePrecise(this.addPrecise(tmpLeftMiddleValue, tmpRightMiddleValue), 2);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the mode (most frequently occurring value) of a given value set using precise mode calculation.\n\t *\n\t * @param {Array} pValueSet - The array of values to calculate the mode from.\n\t * @returns {Array} - An array containing the mode value(s) from the given value set.\n\t */\n\tmodePrecise(pValueSet)\n\t{\n\t\tlet tmpHistogram = this.bucketSetPrecise(pValueSet);\n\t\tlet tmpMaxCount = 0;\n\n\t\t// Philosophical question about whether the values should be returned sorted.\n\t\tlet tmpHistogramValueSet = Object.keys(tmpHistogram);\n\n\t\tlet tmpModeValueSet = [];\n\n\t\tfor (let i = 0; i < tmpHistogramValueSet.length; i++)\n\t\t{\n\t\t\tif (tmpHistogram[tmpHistogramValueSet[i]] > tmpMaxCount)\n\t\t\t{\n\t\t\t\ttmpMaxCount = tmpHistogram[tmpHistogramValueSet[i]];\n\t\t\t\ttmpModeValueSet = [tmpHistogramValueSet[i]];\n\t\t\t}\n\t\t\telse if (tmpHistogram[tmpHistogramValueSet[i]] == tmpMaxCount)\n\t\t\t{\n\t\t\t\ttmpModeValueSet.push(tmpHistogramValueSet[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn tmpModeValueSet;\n\t}\n\n\t/**\n\t * Calculates the variance of a given value set using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the variance from.\n\t * @param {boolean} [pIsPopulation=false] - Whether to calculate population variance (true) or sample variance (false).\n\t *\n\t * @return {string} - The variance of the given value set.\n\t */\n\tvariancePrecise(pValueSet, pIsPopulation = false)\n\t{\n\t\tlet tmpValueSet = pValueSet;\n\t\tif (!Array.isArray(tmpValueSet) && typeof tmpValueSet === 'object')\n\t\t{\n\t\t\ttmpValueSet = Object.keys(tmpValueSet).map((pKey) => tmpValueSet[pKey]);\n\t\t}\n\t\tconst tmpMeanValue = this.meanPrecise(tmpValueSet);\n\t\tconst tmpVarianceSum = tmpValueSet.reduce((pAccumulator, pValue) =>\n\t\t{\n\t\t\tconst tmpDiff = this.subtractPrecise(pValue, tmpMeanValue);\n\t\t\tconst tmpSquaredDiff = this.multiplyPrecise(tmpDiff, tmpDiff);\n\t\t\treturn this.addPrecise(pAccumulator, tmpSquaredDiff);\n\t\t}, '0.0');\n\t\treturn this.dividePrecise(tmpVarianceSum, pIsPopulation ? tmpValueSet.length : tmpValueSet.length - 1);\n\t}\n\n\t/**\n\t * Calculates the variance of a given population of values using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the variance from.\n\t *\n\t * @return {string} - The variance of the given value set.\n\t */\n\tpopulationVariancePrecise(pValueSet)\n\t{\n\t\treturn this.variancePrecise(pValueSet, true);\n\t}\n\n\t/**\n\t * Calculates the standard deviation of a given value set using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the standard deviation from.\n\t * @param {boolean} [pIsPopulation=false] - Whether to calculate population variance (true) or sample variance (false).\n\t *\n\t * @return {string} - The standard deviation of the given value set.\n\t */\n\tstandardDeviationPrecise(pValueSet, pIsPopulation = false)\n\t{\n\t\treturn this.sqrtPrecise(this.variancePrecise(pValueSet, pIsPopulation));\n\t}\n\n\t/**\n\t * Calculates the standard deviation of a given population of values using precise mode calculation.\n\t *\n\t * @param {Array<string|number>} pValueSet - The array of values to calculate the standard deviation from.\n\t *\n\t * @return {string} - The standard deviation of the given value set.\n\t */\n\tpopulationStandardDeviationPrecise(pValueSet)\n\t{\n\t\treturn this.standardDeviationPrecise(pValueSet, true);\n\t}\n\n\t/**\n\t * Performs an nth degree polynomial regression on the given data points.\n\t *\n\t * @param {Array<number|string>} pXVector - The x-coordinates of the data points.\n\t * @param {Array<number|string>} pYVector - The y-coordinates of the data points.\n\t * @param {number} [pDegree=2] - The degree of the polynomial to fit.\n\t *\n\t * @return {Array<number|string>} The coefficients of the fitted polynomial, starting from the constant term.\n\t */\n\tpolynomialRegression(pXVector, pYVector, pDegree = 2)\n\t{\n\t\tconst n = pDegree;\n\t\tconst tmpXMatrix = [];\n\t\tconst tmpYVector = pYVector;\n\n\t\t// Build Vandermonde matrix\n\t\tfor (let i = 0; i < pXVector.length; ++i)\n\t\t{\n\t\t\tconst row = [];\n\t\t\tfor (let j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\trow.push(this.powerPrecise(pXVector[i], j));\n\t\t\t}\n\t\t\ttmpXMatrix.push(row);\n\t\t}\n\n\t\t// Compute coefficients\n\t\tconst X_T = this.matrixTranspose(tmpXMatrix);\n\t\tconst XTX = this.matrixMultiply(X_T, tmpXMatrix);\n\t\tconst XTY = this.matrixMultiply(X_T, tmpYVector.map(v => [v]));\n\t\tconst XTX_inv = this.matrixInverse(XTX);\n\t\tconst A = this.matrixMultiply(XTX_inv, XTY);\n\n\t\t// Flatten coefficients\n\t\treturn A.map((row) => row[0]);\n\t}\n\n\t/**\n\t * Compute least squares regression coefficients for multivariable linear interpolation.\n\t *\n\t * @param {Array<Array<number|string>> | Array<number|string> | string} pIndependentVariableVectors - array of arrays [[x11, x12, ...], [x21, x22, ...], ...] or single array for single variable.\n\t * @param {Array<number|string>|string} pDependentVariableVector - array of target values [y1, y2, ...]\n\t *\n\t * @return {Array<number|string>} - linear coefficients [b0, b1, ..., bn] where y = b0 + b1*x1 + b2*x2 + ... + bn*xn\n\t */\n\tleastSquares(pIndependentVariableVectors, pDependentVariableVector)\n\t{\n\t\tconst tmpIndependentVariableVectors = Array.isArray(pIndependentVariableVectors) ? (Array.isArray(pIndependentVariableVectors[0]) ? this.matrixTranspose(pIndependentVariableVectors) : pIndependentVariableVectors.map(value => [value])) : [ [ pIndependentVariableVectors ] ];\n\t\tconst tmpDependentVariableVector = Array.isArray(pDependentVariableVector) ? pDependentVariableVector : [ pDependentVariableVector ];\n\t\tif (tmpIndependentVariableVectors.length  === 1)\n\t\t{\n\t\t\t// degenerate case: only one independent variable value, result is just a y-intercept\n\t\t\treturn [ tmpDependentVariableVector[0], '0.0' ];\n\t\t}\n\t\t// Add bias term (intercept)\n\t\tconst tmpIndependentVariableMatrixWithBiasTerm = tmpIndependentVariableVectors.map(row => [1, ...row]);\n\n\t\t// Compute X^T * X\n\t\tconst tmpIndependentTermTranpose = this.matrixTranspose(tmpIndependentVariableMatrixWithBiasTerm);\n\t\tconst tmpDependentTransposeMultiplication = this.matrixMultiply(tmpIndependentTermTranpose, tmpIndependentVariableMatrixWithBiasTerm);\n\n\t\t// Compute X^T * y\n\t\tconst tmpIndependentTransposeMultiplication = this.matrixVectorMultiply(tmpIndependentTermTranpose, tmpDependentVariableVector);\n\n\t\t// Solve (XtX) * beta = Xty\n\t\tconst tmpLinearCoefficients = this.gaussianElimination(tmpDependentTransposeMultiplication, tmpIndependentTransposeMultiplication);\n\n\t\treturn tmpLinearCoefficients;\n\t}\n\n\t/**\n\t * Helper function to transpose a matrix\n\t *\n\t * @param {Array<Array<number|string>>} pInputMatrix - matrix to transpose\n\t *\n\t * @return {Array<Array<number|string>>} - transposed matrix\n\t */\n\tmatrixTranspose(pInputMatrix)\n\t{\n\t\treturn pInputMatrix[0].map((_, i) => pInputMatrix.map((row) => row[i]));\n\t}\n\n\tmatrixMultiply(pLHSMatrix, pRHSMatrix)\n\t{\n\t\tconst result = Array(pLHSMatrix.length)\n\t\t\t.fill(0)\n\t\t\t.map(() => Array(pRHSMatrix[0].length).fill(0));\n\t\tfor (let i = 0; i < pLHSMatrix.length; ++i)\n\t\t{\n\t\t\tfor (let j = 0; j < pRHSMatrix[0].length; ++j)\n\t\t\t{\n\t\t\t\tfor (let k = 0; k < pRHSMatrix.length; ++k)\n\t\t\t\t{\n\t\t\t\t\tresult[i][j] = this.addPrecise(result[i][j], this.multiplyPrecise(pLHSMatrix[i][k], pRHSMatrix[k][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Array<Array<number|string>>} pMatrix - matrix to multiply\n\t * @param {Array<number|string>} pVector - vector to multiply\n\t *\n\t * @return {Array<number|string>} - result vector\n\t */\n\tmatrixVectorMultiply(pMatrix, pVector)\n\t{\n\t\tconst result = Array(pMatrix.length).fill(0);\n\t\tfor (let i = 0; i < pMatrix.length; ++i)\n\t\t{\n\t\t\tfor (let j = 0; j < pMatrix[0].length; ++j)\n\t\t\t{\n\t\t\t\tresult[i] = this.addPrecise(result[i], this.multiplyPrecise(pMatrix[i][j], pVector[j]));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Matrix inverse (using Gaussian elimination)\n\t *\n\t * @param {Array<Array<number|string>>} pMatrix - matrix to invert\n\t *\n\t * @return {Array<Array<number|string>>} - inverted matrix\n\t */\n\tmatrixInverse(pMatrix)\n\t{\n\t\tconst n = pMatrix.length;\n\t\tconst tmpIdentityMatrix = pMatrix.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));\n\t\tconst tmpAugmentedMatrix = pMatrix.map((row, i) => row.concat(tmpIdentityMatrix[i]));\n\n\t\tfor (let i = 0; i < n; ++i)\n\t\t{\n\t\t\t// Pivot\n\t\t\tlet maxRow = i;\n\t\t\tfor (let k = i + 1; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (this.gtPrecise(this.absPrecise(tmpAugmentedMatrix[k][i]), this.absPrecise(tmpAugmentedMatrix[maxRow][i])))\n\t\t\t\t{\n\t\t\t\t\tmaxRow = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\t[tmpAugmentedMatrix[i], tmpAugmentedMatrix[maxRow]] = [tmpAugmentedMatrix[maxRow], tmpAugmentedMatrix[i]];\n\n\t\t\t// divide by pivot\n\t\t\tconst tmpPivotValue = tmpAugmentedMatrix[i][i];\n\t\t\tfor (let j = 0; j < 2 * n; ++j)\n\t\t\t{\n\t\t\t\ttmpAugmentedMatrix[i][j] = this.dividePrecise(tmpAugmentedMatrix[i][j], tmpPivotValue);\n\t\t\t}\n\n\t\t\t// Eliminate other rows\n\t\t\tfor (let k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (k === i)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst tmpFactor = tmpAugmentedMatrix[k][i];\n\t\t\t\tfor (let j = 0; j < 2 * n; ++j)\n\t\t\t\t{\n\t\t\t\t\ttmpAugmentedMatrix[k][j] = this.subtractPrecise(tmpAugmentedMatrix[k][j], this.multiplyPrecise(tmpFactor, tmpAugmentedMatrix[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract right half (inverse)\n\t\treturn tmpAugmentedMatrix.map((row) => row.slice(n));\n\t}\n\n\n\t/**\n\t * Compute solution to linear system using Gaussian elimination.\n\t *\n\t * @param {Array<Array<number|string>>} pCoefficientMatrix - Coefficient matrix\n\t * @param {Array<number|string>} pVector - Right-hand side vector\n\t *\n\t * @return {Array<number|string>} - Solution vector x\n\t */\n\tgaussianElimination(pCoefficientMatrix, pVector)\n\t{\n\t\t// Solve A*x = b using Gaussian elimination\n\t\tconst n = pCoefficientMatrix.length;\n\t\tconst tmpAugmentedMatrix = pCoefficientMatrix.map((row, i) => [...row, pVector[i]]);\n\n\t\tfor (let i = 0; i < n; ++i)\n\t\t{\n\t\t\t// Pivot\n\t\t\tlet maxRow = i;\n\t\t\tfor (let k = i + 1; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (this.gtPrecise(this.absPrecise(tmpAugmentedMatrix[k][i]), this.absPrecise(tmpAugmentedMatrix[maxRow][i])))\n\t\t\t\t{\n\t\t\t\t\tmaxRow = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst tmpSwapValue = tmpAugmentedMatrix[i];\n\t\t\ttmpAugmentedMatrix[i] = tmpAugmentedMatrix[maxRow];\n\t\t\ttmpAugmentedMatrix[maxRow] = tmpSwapValue;\n\n\t\t\t// Normalize pivot row\n\t\t\tconst tmpPivotValue = tmpAugmentedMatrix[i][i];\n\t\t\tif (this.comparePrecise(tmpPivotValue, 0) == 0)\n\t\t\t{\n\t\t\t\tthrow new Error('Matrix not invertible');\n\t\t\t}\n\t\t\tfor (let j = i; j <= n; ++j)\n\t\t\t{\n\t\t\t\ttmpAugmentedMatrix[i][j] = this.dividePrecise(tmpAugmentedMatrix[i][j], tmpPivotValue);\n\t\t\t}\n\n\t\t\t// Eliminate other rows\n\t\t\tfor (let k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (k === i)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst tmpFactor = tmpAugmentedMatrix[k][i];\n\t\t\t\tfor (let j = i; j <= n; ++j)\n\t\t\t\t{\n\t\t\t\t\ttmpAugmentedMatrix[k][j] = this.subtractPrecise(tmpAugmentedMatrix[k][j], this.multiplyPrecise(tmpFactor, tmpAugmentedMatrix[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract solution\n\t\treturn tmpAugmentedMatrix.map((row) => row[n]);\n\t}\n\n\tgenerateValueFromEasingDescription(pEasingConfiguration)\n\t{\n\t\t// Branch based on type\n\t\tswitch (pEasingConfiguration.Easing)\n\t\t{\n\t\t\tcase 'LINEAR':\n\t\t\tdefault:\n\t\t\t\tlet tmpDomainRange = pEasingConfiguration.DomainLength;\n\n\t\t\t\tif (this.comparePrecise(tmpDomainRange, 0) == 0)\n\t\t\t\t{\n\t\t\t\t\treturn this.parsePrecise(pEasingConfiguration.DomainRangeStart);\n\t\t\t\t}\n\n\t\t\t\t// Now, generate a random number and then multiply it to fit in the domain length\n\t\t\t\tlet tmpRandomFraction = Math.random();\n\t\t\t\t// Scale it to the domain\n\t\t\t\tlet tmpScaledValue = this.multiplyPrecise(tmpRandomFraction, tmpDomainRange);\n\t\t\t\t// Shift it to the range start\n\t\t\t\treturn this.addPrecise(pEasingConfiguration.DomainRangeStart, tmpScaledValue);\n\t\t}\n\t}\n\n\t/**\n\t * Predicts the dependent variable using a regression model.\n\t *\n\t * @param {Array<number|string>} pRegressionCoefficients - The regression coefficients [b0, b1, ..., bn].\n\t * @param {Array<number|string>|number|string} pIndependentVariableVector - The independent variable values [x1, x2, ..., xn] or single value for single variable.\n\t *\n\t * @return {number|string} - The predicted dependent variable value.\n\t */\n\tpredictFromRegressionModel(pRegressionCoefficients, pIndependentVariableVector)\n\t{\n\t\tlet tmpIndependentVariableVector = pIndependentVariableVector;\n\t\tif (!Array.isArray(pIndependentVariableVector))\n\t\t{\n\t\t\ttmpIndependentVariableVector = [ pIndependentVariableVector ];\n\t\t}\n\t\treturn pRegressionCoefficients.slice(1).reduce((sum, b, i) =>\n\t\t\t{\n\t\t\t\treturn this.addPrecise(sum, this.multiplyPrecise(b, tmpIndependentVariableVector[i]));\n\t\t\t}, pRegressionCoefficients[0]);\n\t}\n\n\t/**\n\t * Evaluate a point on a cubic bezier curve at parameter t.\n\t *\n\t * B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n\t *\n\t * @param {number|string} pP0 - First control point value\n\t * @param {number|string} pP1 - Second control point value\n\t * @param {number|string} pP2 - Third control point value\n\t * @param {number|string} pP3 - Fourth control point value\n\t * @param {number|string} pT - Parameter t in [0,1]\n\t *\n\t * @return {string} - The bezier curve value at parameter t\n\t */\n\tbezierPoint(pP0, pP1, pP2, pP3, pT)\n\t{\n\t\tlet tmpT = this.parsePrecise(pT, 0);\n\t\tlet tmpOneMinusT = this.subtractPrecise(1, tmpT);\n\n\t\t// (1-t)^3 * P0\n\t\tlet tmpTerm0 = this.multiplyPrecise(this.powerPrecise(tmpOneMinusT, 3), pP0);\n\t\t// 3 * (1-t)^2 * t * P1\n\t\tlet tmpTerm1 = this.multiplyPrecise(this.multiplyPrecise(this.multiplyPrecise(3, this.powerPrecise(tmpOneMinusT, 2)), tmpT), pP1);\n\t\t// 3 * (1-t) * t^2 * P2\n\t\tlet tmpTerm2 = this.multiplyPrecise(this.multiplyPrecise(this.multiplyPrecise(3, tmpOneMinusT), this.powerPrecise(tmpT, 2)), pP2);\n\t\t// t^3 * P3\n\t\tlet tmpTerm3 = this.multiplyPrecise(this.powerPrecise(tmpT, 3), pP3);\n\n\t\treturn this.addPrecise(this.addPrecise(tmpTerm0, tmpTerm1), this.addPrecise(tmpTerm2, tmpTerm3));\n\t}\n\n\t/**\n\t * Fit a cubic bezier curve to a set of data points using least-squares optimization.\n\t *\n\t * Given arrays of X and Y values representing data points, this function finds the four\n\t * control points (P0, P1, P2, P3) of a cubic bezier curve that best fits the data.\n\t *\n\t * The first and last control points are pinned to the first and last data points.\n\t * The interior control points (P1, P2) are found by least-squares minimization of\n\t * the squared distances between the data points and the curve.\n\t *\n\t * Parameter t values are assigned by chord-length parameterization: each data point\n\t * gets a t value proportional to its cumulative distance along the polyline.\n\t *\n\t * @param {Array<number|string>} pXValues - Array of x coordinates\n\t * @param {Array<number|string>} pYValues - Array of y coordinates\n\t *\n\t * @return {Array<Array<string>>} - Four control points as [[x0,y0], [x1,y1], [x2,y2], [x3,y3]]\n\t */\n\tbezierCurveFit(pXValues, pYValues)\n\t{\n\t\tif (!Array.isArray(pXValues) || !Array.isArray(pYValues))\n\t\t{\n\t\t\tthis.log.warn('bezierCurveFit: pXValues and pYValues must be arrays');\n\t\t\treturn [[0, 0], [0, 0], [0, 0], [0, 0]];\n\t\t}\n\n\t\tlet tmpN = Math.min(pXValues.length, pYValues.length);\n\n\t\tif (tmpN < 2)\n\t\t{\n\t\t\tthis.log.warn('bezierCurveFit: need at least 2 data points');\n\t\t\treturn [[0, 0], [0, 0], [0, 0], [0, 0]];\n\t\t}\n\n\t\t// Pin P0 and P3 to the first and last data points\n\t\tlet tmpP0x = this.parsePrecise(pXValues[0], 0);\n\t\tlet tmpP0y = this.parsePrecise(pYValues[0], 0);\n\t\tlet tmpP3x = this.parsePrecise(pXValues[tmpN - 1], 0);\n\t\tlet tmpP3y = this.parsePrecise(pYValues[tmpN - 1], 0);\n\n\t\tif (tmpN === 2)\n\t\t{\n\t\t\t// With only two points, place control points at 1/3 and 2/3 along the line\n\t\t\tlet tmpP1x = this.addPrecise(tmpP0x, this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3));\n\t\t\tlet tmpP1y = this.addPrecise(tmpP0y, this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3));\n\t\t\tlet tmpP2x = this.addPrecise(tmpP0x, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3), 2));\n\t\t\tlet tmpP2y = this.addPrecise(tmpP0y, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3), 2));\n\t\t\treturn [\n\t\t\t\t[tmpP0x.toString(), tmpP0y.toString()],\n\t\t\t\t[tmpP1x.toString(), tmpP1y.toString()],\n\t\t\t\t[tmpP2x.toString(), tmpP2y.toString()],\n\t\t\t\t[tmpP3x.toString(), tmpP3y.toString()]\n\t\t\t];\n\t\t}\n\n\t\t// Compute chord-length parameterization for t values\n\t\tlet tmpDistances = [0];\n\t\tfor (let i = 1; i < tmpN; i++)\n\t\t{\n\t\t\tlet tmpDx = this.subtractPrecise(pXValues[i], pXValues[i - 1]);\n\t\t\tlet tmpDy = this.subtractPrecise(pYValues[i], pYValues[i - 1]);\n\t\t\tlet tmpDist = this.sqrtPrecise(this.addPrecise(this.multiplyPrecise(tmpDx, tmpDx), this.multiplyPrecise(tmpDy, tmpDy)));\n\t\t\ttmpDistances.push(this.addPrecise(tmpDistances[i - 1], tmpDist));\n\t\t}\n\n\t\tlet tmpTotalLength = tmpDistances[tmpN - 1];\n\t\tlet tmpTValues = [];\n\t\tfor (let i = 0; i < tmpN; i++)\n\t\t{\n\t\t\tif (this.comparePrecise(tmpTotalLength, 0) == 0)\n\t\t\t{\n\t\t\t\ttmpTValues.push(this.dividePrecise(i, tmpN - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpTValues.push(this.dividePrecise(tmpDistances[i], tmpTotalLength));\n\t\t\t}\n\t\t}\n\n\t\t// Build the least-squares system for interior control points P1 and P2.\n\t\t// For each data point i with parameter t_i:\n\t\t//   B(t_i) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n\t\t//\n\t\t// We want to minimize sum of |DataPoint_i - B(t_i)|^2 over P1 and P2.\n\t\t// Let A1(t) = 3*(1-t)^2*t and A2(t) = 3*(1-t)*t^2.\n\t\t// Then: A1(t)*P1 + A2(t)*P2 = DataPoint - (1-t)^3*P0 - t^3*P3\n\t\t//\n\t\t// This gives a 2x2 linear system (solved independently for x and y).\n\n\t\tlet tmpC11 = 0, tmpC12 = 0, tmpC22 = 0;\n\t\tlet tmpRx1 = 0, tmpRx2 = 0;\n\t\tlet tmpRy1 = 0, tmpRy2 = 0;\n\n\t\tfor (let i = 0; i < tmpN; i++)\n\t\t{\n\t\t\tlet tmpT = tmpTValues[i];\n\t\t\tlet tmpOneMinusT = this.subtractPrecise(1, tmpT);\n\n\t\t\t// Basis functions for P1 and P2\n\t\t\tlet tmpA1 = this.multiplyPrecise(this.multiplyPrecise(3, this.powerPrecise(tmpOneMinusT, 2)), tmpT);\n\t\t\tlet tmpA2 = this.multiplyPrecise(this.multiplyPrecise(3, tmpOneMinusT), this.powerPrecise(tmpT, 2));\n\n\t\t\t// Build normal equations: C * [P1; P2] = R\n\t\t\ttmpC11 = this.addPrecise(tmpC11, this.multiplyPrecise(tmpA1, tmpA1));\n\t\t\ttmpC12 = this.addPrecise(tmpC12, this.multiplyPrecise(tmpA1, tmpA2));\n\t\t\ttmpC22 = this.addPrecise(tmpC22, this.multiplyPrecise(tmpA2, tmpA2));\n\n\t\t\t// Right-hand side: DataPoint - (1-t)^3*P0 - t^3*P3\n\t\t\tlet tmpB0 = this.powerPrecise(tmpOneMinusT, 3);\n\t\t\tlet tmpB3 = this.powerPrecise(tmpT, 3);\n\n\t\t\tlet tmpResidualX = this.subtractPrecise(this.subtractPrecise(pXValues[i], this.multiplyPrecise(tmpB0, tmpP0x)), this.multiplyPrecise(tmpB3, tmpP3x));\n\t\t\tlet tmpResidualY = this.subtractPrecise(this.subtractPrecise(pYValues[i], this.multiplyPrecise(tmpB0, tmpP0y)), this.multiplyPrecise(tmpB3, tmpP3y));\n\n\t\t\ttmpRx1 = this.addPrecise(tmpRx1, this.multiplyPrecise(tmpA1, tmpResidualX));\n\t\t\ttmpRx2 = this.addPrecise(tmpRx2, this.multiplyPrecise(tmpA2, tmpResidualX));\n\t\t\ttmpRy1 = this.addPrecise(tmpRy1, this.multiplyPrecise(tmpA1, tmpResidualY));\n\t\t\ttmpRy2 = this.addPrecise(tmpRy2, this.multiplyPrecise(tmpA2, tmpResidualY));\n\t\t}\n\n\t\t// Solve the 2x2 system: [[C11, C12], [C12, C22]] * [P1, P2] = [R1, R2]\n\t\tlet tmpDet = this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpC22), this.multiplyPrecise(tmpC12, tmpC12));\n\n\t\tlet tmpP1x, tmpP1y, tmpP2x, tmpP2y;\n\n\t\tif (this.comparePrecise(this.absPrecise(tmpDet), '1e-20') < 0)\n\t\t{\n\t\t\t// Degenerate case: place control points at 1/3 and 2/3 along the line\n\t\t\ttmpP1x = this.addPrecise(tmpP0x, this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3));\n\t\t\ttmpP1y = this.addPrecise(tmpP0y, this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3));\n\t\t\ttmpP2x = this.addPrecise(tmpP0x, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3x, tmpP0x), 3), 2));\n\t\t\ttmpP2y = this.addPrecise(tmpP0y, this.multiplyPrecise(this.dividePrecise(this.subtractPrecise(tmpP3y, tmpP0y), 3), 2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpP1x = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC22, tmpRx1), this.multiplyPrecise(tmpC12, tmpRx2)), tmpDet);\n\t\t\ttmpP1y = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC22, tmpRy1), this.multiplyPrecise(tmpC12, tmpRy2)), tmpDet);\n\t\t\ttmpP2x = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpRx2), this.multiplyPrecise(tmpC12, tmpRx1)), tmpDet);\n\t\t\ttmpP2y = this.dividePrecise(this.subtractPrecise(this.multiplyPrecise(tmpC11, tmpRy2), this.multiplyPrecise(tmpC12, tmpRy1)), tmpDet);\n\t\t}\n\n\t\treturn [\n\t\t\t[tmpP0x.toString(), tmpP0y.toString()],\n\t\t\t[tmpP1x.toString(), tmpP1y.toString()],\n\t\t\t[tmpP2x.toString(), tmpP2y.toString()],\n\t\t\t[tmpP3x.toString(), tmpP3y.toString()]\n\t\t];\n\t}\n}\n\nmodule.exports = FableServiceMath;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\n/**\n* Precedent Meta-Templating\n* @author      Steven Velozo <steven@velozo.com>\n* @description Process text stream trie and postfix tree, parsing out meta-template expression functions.\n*/\nconst libWordTree = require(`./Fable-Service-MetaTemplate/MetaTemplate-WordTree.js`);\nconst libStringParser = require(`./Fable-Service-MetaTemplate/MetaTemplate-StringParser.js`);\n\n\nclass FableServiceMetaTemplate extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'MetaTemplate';\n\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser(this.fable);\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\n\taddPattern(pPatternStart, pPatternEnd, pParser, pParserContext)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser, pParserContext);\n\t}\n\n\taddPatternBoth(pPatternStart, pPatternEnd, pParser, pParserPromise, pParserContext)\n\t{\n\t\treturn this.WordTree.addPatternBoth(pPatternStart, pPatternEnd, pParser, pParserPromise, pParserContext);\n\t}\n\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @param {object} pData - Data to pass in as the second argument\n\t * @param {function} fCallback - The callback function to call when a pattern is matched\n\t * @param {array} pDataContext - The history of data objects already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\tif (this.LogNoisiness > 4)\n\t\t{\n\t\t\tthis.fable.log.trace(`Metatemplate parsing template string [${pString}] where the callback is a ${typeof(fCallback)}`, {TemplateData:pData});\n\t\t}\n\t\treturn this.StringParser.parseString(pString, this.ParseTree, pData, fCallback, pDataContext, pScope, pState);\n\t}\n}\n\nmodule.exports = FableServiceMetaTemplate;\n","/**\n* String Parser\n* @author      Steven Velozo <steven@velozo.com>\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\t}\n\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tAsynchronous: false,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: {},\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchEnd: false\n\t\t});\n\t}\n\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\tresetOutputBuffer (pParserState)\n\t{\n\t\t// Flush the output buffer.\n\t\tthis.flushOutputBuffer(pParserState);\n\t\t// End pattern mode\n\t\tpParserState.Pattern = false;\n\t\tpParserState.PatternStartNode = false;\n\t\tpParserState.StartPatternMatchComplete = false;\n\t\tpParserState.EndPatternMatchBegan = false;\n\t\tpParserState.PatternMatch = false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {any} pData - The data available to the template\n\t * @param {Array<any>} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState, pData, pDataContext, pScope, pState)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && (pCharacter in pParserState.Pattern))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\t// Run the function\n\t\t\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\t\t\tif (tmpFunctionContext)\n\t\t\t\t\t{\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t}\n\t\t\t\telse if (pCharacter in pParserState.PatternStartNode.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('PatternEnd' in pParserState.Pattern)\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Run the t*mplate function\n\t\t\t\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\t\t\t\tif (tmpFunctionContext)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.resetOutputBuffer(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\tif (!pParserState.PatternMatch)\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pCharacter in pParserState.ParseTree)\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t */\n\texecutePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t// Trim the start and end tags off the output buffer now\n\t\tif (pParserState.Pattern.isAsync)\n\t\t{\n\t\t\t// Run the function\n\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\tif (tmpFunctionContext)\n\t\t\t{\n\t\t\t\treturn pParserState.Pattern.ParseAsync.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData,\n\t\t\t\t\t(pError, pAsyncOutput) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.fable.log.info(`Precedent ERROR: Async template error happened parsing ${pParserState.Pattern.PatternStart} ... ${pParserState.Pattern.PatternEnd}: ${pError}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpParserState.OutputBuffer = pAsyncOutput;\n\t\t\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn pParserState.Pattern.ParseAsync(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData,\n\t\t\t\t\t(pError, pAsyncOutput) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.fable.log.info(`Precedent ERROR: Async template error happened parsing ${pParserState.Pattern.PatternStart} ... ${pParserState.Pattern.PatternEnd}: ${pError}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpParserState.OutputBuffer = pAsyncOutput;\n\t\t\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}, pDataContext, pScope, pState);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Run the t*mplate function\n\t\t\tlet tmpFunctionContext = ('ParserContext' in pParserState.Pattern) ? pParserState.Pattern.ParserContext : false;\n\t\t\tif (tmpFunctionContext)\n\t\t\t{\n\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse.call(tmpFunctionContext, pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)), pData, pDataContext, pScope, pState);\n\t\t\t}\n\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacterAsync\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t * @private\n\t */\n\tparseCharacterAsync (pCharacter, pParserState, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// If we are already in a pattern match traversal\n\t\tif (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern is still matching the start and we haven't passed the buffer\n\t\t\tif (!pParserState.StartPatternMatchComplete && (pCharacter in pParserState.Pattern))\n\t\t\t{\n\t\t\t\tpParserState.Pattern = pParserState.Pattern[pCharacter];\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\telse if (pParserState.EndPatternMatchBegan)\n\t\t\t{\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// Flush the output buffer.\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this.executePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pCharacter in pParserState.PatternStartNode.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// We broke out of the end -- see if this is a new start of the end.\n\t\t\t\t\tpParserState.Pattern = pParserState.PatternStartNode.PatternEnd[pCharacter];\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpParserState.EndPatternMatchBegan = false;\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('PatternEnd' in pParserState.Pattern)\n\t\t\t{\n\t\t\t\tif (!pParserState.StartPatternMatchComplete)\n\t\t\t\t{\n\t\t\t\t\tpParserState.StartPatternMatchComplete = true;\n\t\t\t\t\tpParserState.PatternStartNode = pParserState.Pattern;\n\t\t\t\t}\n\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\n\t\t\t\tif (pCharacter in pParserState.Pattern.PatternEnd)\n\t\t\t\t{\n\t\t\t\t\t// This is the first character of the end pattern.\n\t\t\t\t\tpParserState.EndPatternMatchBegan = true;\n\t\t\t\t\t// This leaf has a PatternEnd tree, so we will wait until that end is met.\n\t\t\t\t\tpParserState.Pattern = pParserState.Pattern.PatternEnd[pCharacter];\n\t\t\t\t\t// If this last character is the end of the pattern, parse it.\n\t\t\t\t\tif ('Parse' in pParserState.Pattern)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this.executePatternAsync(pParserState, pData, fCallback, pDataContext, pScope, pState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are in a pattern start but didn't match one; reset and start trying again from this character.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t}\n\t\t}\n\t\t// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\t// This may be the start of a new pattern....\n\t\t\tif (pCharacter in pParserState.ParseTree)\n\t\t\t{\n\t\t\t\t// ... assign the root node as the matched node.\n\t\t\t\tthis.resetOutputBuffer(pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\tpParserState.Pattern = pParserState.ParseTree[pCharacter];\n\t\t\t\tpParserState.PatternMatch = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t}\n\t\t// Without this, templates of all sizes work fine in node.  They do not in the browser.\n\t\t// Trying this out without the timout on non asynchronous template flips.\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t * @param {Object} pData - The data to pass to the function as a second parameter\n\t * @param {function} fCallback - The callback function to call when the parse is complete\n\t * @param {array} pDataContext - The history of data objects/context already passed in\n\t * @param {any} [pScope] - A sticky scope that can be used to carry state and simplify template\n\t * @param {any} [pState] - A catchall state object for plumbing data through template processing.\n\t */\n\tparseString (pString, pParseTree, pData, fCallback, pDataContext, pScope, pState)\n\t{\n\t\t// TODO: There is danger here if a template function attempts to functionally recurse and doesn't pass this in.\n\t\tlet tmpPreviousDataContext = (Array.isArray(pDataContext)) ? pDataContext : [];\n\t\tlet tmpDataContext = Array.from(tmpPreviousDataContext);\n\t\ttmpDataContext.push(pData)\n\n\t\tif (typeof(fCallback) !== 'function')\n\t\t{\n\t\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\t\tfor (var i = 0; i < pString.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: This is not fast.\n\t\t\t\tthis.parseCharacter(pString[i], tmpParserState, pData, tmpDataContext, pScope, pState);\n\t\t\t}\n\n\t\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\t\treturn tmpParserState.Output;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is the async mode\n\t\t\tlet tmpParserState = this.newParserState(pParseTree);\n\t\t\ttmpParserState.Asynchronous = true;\n\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tfor (let i = 0; i < pString.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(\n\t\t\t\t\t(fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.parseCharacterAsync(pString[i], tmpParserState, pData, fCallback, tmpDataContext, pScope, pState);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\t// Flush the remaining data\n\t\t\t\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\t\t\treturn fCallback(pError, tmpParserState.Output);\n\t\t\t\t});\n\t\t}\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n* @author      Steven Velozo <steven@velozo.com>\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern)\n\t{\n\t\tif (!(pPattern in pTree))\n\t\t{\n\t\t\tpTree[pPattern] = {};\n\t\t}\n\n\t\treturn pTree[pPattern];\n\t}\n\n\t/**\n\t * Add a child character to a Parse Tree PatternEnd subtree\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddEndChild (pTree, pPattern)\n\t{\n\t\tif (!('PatternEnd' in pTree))\n\t\t{\n\t\t\tpTree.PatternEnd = {};\n\t\t}\n\n\t\tpTree.PatternEnd[pPattern] = {};\n\n\t\treturn pTree.PatternEnd[pPattern];\n\t}\n\n\t/** Add a Pattern to the Parse Tree with both function parameter types\n\t * @method addPatternAll\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {function} fParserAsync - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {Object} pParserContext - The context to pass to the parser function\n\t * @return {Object} The leaf parser from the tree\n\t */\n\taddPatternBoth (pPatternStart, pPatternEnd, fParser, fParserAsync, pParserContext)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart[i], i);\n\t\t}\n\n\t\tif (!('PatternEnd' in tmpLeaf))\n\t\t{\n\t\t\ttmpLeaf.PatternEnd = {};\n\t\t}\n\n\t\tlet tmpPatternEnd = (typeof(pPatternEnd) === 'string') ? pPatternEnd : pPatternStart;\n\t\tfor (let i = 0; i < tmpPatternEnd.length; i++)\n\t\t{\n\t\t\ttmpLeaf = this.addEndChild(tmpLeaf, tmpPatternEnd[i], i);\n\t\t}\n\n\t\ttmpLeaf.PatternStartString = pPatternStart;\n\t\ttmpLeaf.PatternEndString = tmpPatternEnd;\n\t\ttmpLeaf.Parse = (typeof(fParser) === 'function') ? fParser :\n\t\t\t\t\t\t(typeof(fParser) === 'string') ? (pHash, pData) => { return fParser; } :\n\t\t\t\t\t\t(pHash, pData) => { return pHash; };\n\n\t\ttmpLeaf.ParseAsync = (typeof(fParserAsync) === 'function') ? fParserAsync :\n\t\t\t\t\t\t(typeof(fParserAsync) === 'string') ? (pHash, pData, fCallback) => { return fCallback(null, fParserAsync); } :\n\t\t\t\t\t\t(pHash, pData, fCallback) => { return fCallback(null, tmpLeaf.Parse(pHash, pData)); }\n\n\t\t// A \"this\" for every object\n\t\tif (pParserContext)\n\t\t{\n\t\t\ttmpLeaf.ParserContext = pParserContext;\n\t\t}\n\n\t\ttmpLeaf.isAsync = true;\n\n\t\treturn tmpLeaf;\n\t}\n\n\t/** Add a Pattern to the Parse Tree with both function parameter types\n\t * @method addPatternAll\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @param {Object} pParserContext - The context to pass to the parser function\n\t */\n\taddPattern (pPatternStart, pPatternEnd, fParser, pParserContext)\n\t{\n\t\treturn this.addPatternBoth(pPatternStart, pPatternEnd, fParser, null, pParserContext);\n\t}\n}\n\nmodule.exports = WordTree;\n","module.exports = (\n\t{\n\t\t\"Metadata\": {\n\t\t\t\"UUID\": false,\n\t\t\t\"Hash\": false,\n\n\t\t\t\"Name\": \"\",\n\t\t\t\"Summary\": \"\",\n\n\t\t\t\"Version\": 0\n\t\t},\n\t\t\"Status\": {\n\t\t\t\"Completed\": false,\n\t\t\t\"StepCount\": 1\n\t\t},\n\t\t\"Steps\": [],\n\t\t\"Errors\": [],\n\t\t\"Log\": []\n\t}\n);","const { PE } = require('big.js');\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst _OperationStatePrototypeString = JSON.stringify(require('./Fable-Service-Operation-DefaultSettings.js'));\n\nclass FableOperation extends libFableServiceBase\n{\n\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t// Timestamps will just be the long ints\n\t\tthis.timeStamps = {};\n\n\t\tthis.serviceType = 'PhasedOperation';\n\n\t\tthis.state = JSON.parse(_OperationStatePrototypeString);\n\n\t\tthis.stepMap = {};\n\t\tthis.stepFunctions = {};\n\n\t\t// Match the service instantiation to the operation.\n\t\tthis.state.Metadata.Hash = this.Hash;\n\t\tthis.state.Metadata.UUID = this.UUID;\n\n\t\tthis.state.Metadata.Name = (typeof(this.options.Name) == 'string') ? this.options.Name : `Unnamed Operation ${this.state.Metadata.UUID}`;\n\t\tthis.name = this.state.Metadata.Name;\n\n\t\tthis.progressTrackerSet = this.fable.instantiateServiceProviderWithoutRegistration('ProgressTrackerSet');\n\n\t\tthis.state.OverallProgressTracker = this.progressTrackerSet.createProgressTracker(`Overall-${this.state.Metadata.UUID}`);\n\n\t\t// This is here to use the pass-through logging functions in the operation itself.\n\t\tthis.log = this;\n\t}\n\n\texecute(fExecutionCompleteCallback)\n\t{\n\t\t// TODO: Should the same operation be allowed to execute more than one time?\n\t\tif (this.state.OverallProgressTracker.StartTimeStamp > 0)\n\t\t{\n\t\t\treturn fExecutionCompleteCallback(new Error(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} has already been executed!`));\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tthis.progressTrackerSet.setProgressTrackerTotalOperations(this.state.OverallProgressTracker.Hash, this.state.Status.StepCount);\n\t\tthis.progressTrackerSet.startProgressTracker(this.state.OverallProgressTracker.Hash);\n\t\tthis.info(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} starting...`);\n\n\t\tfor (let i = 0; i < this.state.Steps.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(\n\t\t\t\tfunction(fNext)\n\t\t\t\t{\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} starting...`);\n\t\t\t\t\tthis.progressTrackerSet.startProgressTracker(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\treturn fNext();\n\t\t\t\t}.bind(this));\n\t\t\t// Steps are executed in a custom context with\n\t\t\ttmpAnticipate.anticipate(this.stepFunctions[this.state.Steps[i].GUIDStep].bind(\n\t\t\t\t{\n\t\t\t\t\tlog:this,\n\t\t\t\t\tfable:this.fable,\n\t\t\t\t\toptions:this.state.Steps[i].Metadata,\n\t\t\t\t\tmetadata:this.state.Steps[i].Metadata,\n\t\t\t\t\tProgressTracker:this.progressTrackerSet.getProgressTracker(this.state.Steps[i].ProgressTracker.Hash),\n\t\t\t\t\tlogProgressTrackerStatus: function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}]: ${this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash)}`);\n\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\tOperationState:this.state,\n\t\t\t\t\tStepState:this.state.Steps[i]\n\t\t\t\t}));\n\t\t\ttmpAnticipate.anticipate(\n\t\t\t\tfunction(fNext)\n\t\t\t\t{\n\t\t\t\t\tthis.progressTrackerSet.endProgressTracker(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\tlet tmpStepTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash);\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} complete.`);\n\t\t\t\t\tthis.fable.log.info(`Step #${i} [${this.state.Steps[i].GUIDStep}] ${this.state.Steps[i].Name} ${tmpStepTimingMessage}.`);\n\n\t\t\t\t\tthis.progressTrackerSet.incrementProgressTracker(this.state.OverallProgressTracker.Hash, 1);\n\t\t\t\t\tlet tmpOperationTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.OverallProgressTracker.Hash);\n\t\t\t\t\tthis.fable.log.info(`Operation [${this.state.Metadata.UUID}] ${tmpOperationTimingMessage}.`);\n\t\t\t\t\treturn fNext();\n\t\t\t\t}.bind(this));\n\t\t}\n\n\t\t// Wait for the anticipation to complete\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.fable.log.error(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} had an error: ${pError}`, pError);\n\t\t\t\t\treturn fExecutionCompleteCallback(pError);\n\t\t\t\t}\n\t\t\t\tthis.info(`Operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} complete.`);\n\t\t\t\tlet tmpOperationTimingMessage = this.progressTrackerSet.getProgressTrackerStatusString(this.state.OverallProgressTracker.Hash);\n\t\t\t\tthis.progressTrackerSet.endProgressTracker(this.state.OverallProgressTracker.Hash);\n\t\t\t\tthis.fable.log.info(`Operation [${this.state.Metadata.UUID}] ${tmpOperationTimingMessage}.`);\n\t\t\t\treturn fExecutionCompleteCallback();\n\t\t\t});\n\t}\n\n\t// There are three ways to add steps:\n\t// 1. As a basic javascript function\n\t//    --\n\t//    This is the most basic, java\"script\" way to add a step.  It will\n\t//    setup a \"this\" context that has the following properties:\n\t//    - log: A reference to the operation's log object\n\n\taddStep(fStepFunction, pStepMetadata, pStepName, pStepDescription, pGUIDStep)\n\t{\n\t\tlet tmpStep = {};\n\n\t\t// GUID is optional\n\t\ttmpStep.GUIDStep = (typeof(pGUIDStep) !== 'undefined') ? pGUIDStep : `STEP-${this.state.Steps.length}-${this.fable.DataGeneration.randomNumericString()}`;\n\n\n\t\t// Name is optional\n\t\ttmpStep.Name = (typeof(pStepName) !== 'undefined') ? pStepName : `Step [${tmpStep.GUIDStep}]`;\n\t\ttmpStep.Description = (typeof(pStepDescription) !== 'undefined') ? pStepDescription : `Step execution of ${tmpStep.Name}.`;\n\n\t\ttmpStep.ProgressTracker = this.progressTrackerSet.createProgressTracker(tmpStep.GUIDStep);\n\n\t\ttmpStep.Metadata = (typeof(pStepMetadata) === 'object') ? pStepMetadata : {};\n\n\t\t// There is an array of steps, in the Operation State itself ... push a step there\n\t\tthis.state.Steps.push(tmpStep);\n\n\t\tthis.stepMap[tmpStep.GUIDStep] = tmpStep;\n\n\t\tthis.stepFunctions[tmpStep.GUIDStep] = typeof(fStepFunction) == 'function' ? fStepFunction : function (fDone) { return fDone(); };\n\n\t\tthis.state.Status.StepCount++;\n\n\t\treturn tmpStep;\n\t}\n\n\tsetStepTotalOperations(pGUIDStep, pTotalOperationCount)\n\t{\n\t\tif (!(pGUIDStep in this.stepMap))\n\t\t{\n\t\t\treturn new Error(`Step [${pGUIDStep}] does not exist in operation [${this.state.Metadata.UUID}] ${this.state.Metadata.Name} when attempting to set total operations to ${pTotalOperationCount}.`);\n\t\t}\n\n\t\tthis.progressTrackerSet.setProgressTrackerTotalOperations(this.stepMap[pGUIDStep].ProgressTracker.Hash, pTotalOperationCount);\n\t}\n\n\twriteOperationLog(pLogLevel, pLogText, pLogObject)\n\t{\n\t\tthis.state.Log.push(`[${new Date().toUTCString()}]-[${pLogLevel}]: ${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Log.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\twriteOperationErrors(pLogText, pLogObject)\n\t{\n\t\tthis.state.Errors.push(`${pLogText}`);\n\n\t\tif (typeof(pLogObject) == 'object')\n\t\t{\n\t\t\tthis.state.Errors.push(JSON.stringify(pLogObject));\n\t\t}\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('TRACE', pLogText, pLogObject);\n\t\tthis.fable.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('DEBUG', pLogText, pLogObject);\n\t\tthis.fable.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('INFO', pLogText, pLogObject);\n\t\tthis.fable.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('WARN', pLogText, pLogObject);\n\t\tthis.fable.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('ERROR', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.writeOperationLog('FATAL', pLogText, pLogObject);\n\t\tthis.writeOperationErrors(pLogText, pLogObject);\n\t\tthis.fable.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = FableOperation;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceProgressTime extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ProgressTime';\n\n\t\tthis.timeStamps = {};\n\t}\n\n\tformatTimeDuration(pTimeDurationInMilliseconds)\n\t{\n\t\tlet tmpTimeDuration = typeof(pTimeDurationInMilliseconds) == 'number' ? pTimeDurationInMilliseconds : 0;\n\n\t\tif (pTimeDurationInMilliseconds < 0)\n\t\t{\n\t\t\treturn 'unknown';\n\t\t}\n\n\t\tlet tmpTimeDurationString = '';\n\t\tif (tmpTimeDuration > 3600000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/3600000)+'h ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 3600000;\n\t\t}\n\t\tif (tmpTimeDuration > 60000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/60000)+'m ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 60000;\n\t\t}\n\t\tif (tmpTimeDuration > 1000)\n\t\t{\n\t\t\ttmpTimeDurationString += Math.floor(tmpTimeDuration/1000)+'s ';\n\t\t\ttmpTimeDuration = tmpTimeDuration % 1000;\n\t\t}\n\t\ttmpTimeDurationString += Math.round(tmpTimeDuration)+'ms';\n\n\t\treturn tmpTimeDurationString;\n\t}\n\n\tcreateTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tthis.timeStamps[tmpTimeStampHash] = +new Date();\n\t\treturn this.timeStamps[tmpTimeStampHash];\n\t}\n\n\tgetTimeStampValue(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\treturn (tmpTimeStampHash in this.timeStamps) ? this.timeStamps[tmpTimeStampHash] : -1;\n\t}\n\n\tupdateTimeStampValue(pTimeStampHash, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpReferenceTime = false;\n\n\t\t// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.\n\t\tif (typeof(pReferenceTime) == 'string')\n\t\t{\n\t\t\ttmpReferenceTime = (tmpReference in this.timeStamps) ? this.timeStamps[tmpReference] : false;\n\t\t}\n\t\telse if (typeof(pReferenceTime) == 'number')\n\t\t{\n\t\t\ttmpReferenceTime = pReferenceTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpReferenceTime = +new Date();\n\t\t}\n\n\t\tif ((tmpTimeStampHash in this.timeStamps) && tmpReferenceTime)\n\t\t{\n\t\t\tthis.timeStamps[tmpTimeStampHash] = tmpReferenceTime;\n\t\t\treturn this.timeStamps[tmpTimeStampHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tremoveTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tif (tmpTimeStampHash in this.timeStamps)\n\t\t{\n\t\t\tdelete this.timeStamps[tmpTimeStampHash];\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetTimeStampDelta(pTimeStampHash, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpReferenceTime = false;\n\n\t\t// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.\n\t\tif (typeof(pReferenceTime) == 'string')\n\t\t{\n\t\t\ttmpReferenceTime = (tmpReference in this.timeStamps) ? this.timeStamps[tmpReference] : false;\n\t\t}\n\t\telse if (typeof(pReferenceTime) == 'number')\n\t\t{\n\t\t\ttmpReferenceTime = pReferenceTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpReferenceTime = +new Date();\n\t\t}\n\n\t\tif ((tmpTimeStampHash in this.timeStamps) && tmpReferenceTime)\n\t\t{\n\t\t\treturn tmpReferenceTime-this.timeStamps[tmpTimeStampHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgetDurationBetweenTimestamps(pTimeStampHashStart, pTimeStampHashEnd)\n\t{\n\t\tlet tmpTimeStampHashStart = (typeof(pTimeStampHashStart) == 'string') ? pTimeStampHashStart : 'Default';\n\t\tlet tmpTimeStampHashEnd = (typeof(pTimeStampHashEnd) == 'string') ? pTimeStampHashEnd : 'Default';\n\t\tif ((tmpTimeStampHashStart in this.timeStamps) && (tmpTimeStampHashEnd in this.timeStamps))\n\t\t{\n\t\t\treturn this.timeStamps[tmpTimeStampHashEnd]-this.timeStamps[tmpTimeStampHashStart];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgetTimeStampDeltaMessage(pTimeStampHash, pMessage, pReferenceTime)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : `Elapsed for ${tmpTimeStampHash}: `;\n\t\tlet tmpOperationTime = this.getTimeStampDelta(tmpTimeStampHash, pReferenceTime);\n\n\t\treturn `${tmpMessage} ${this.formatTimeDuration(tmpOperationTime)}`;\n\t}\n\n\tlogTimeStampDelta(pTimeStampHash, pMessage, pReferenceTime)\n\t{\n\t\tthis.fable.log.info(this.getTimeStampDeltaMessage(pTimeStampHash, pMessage, pReferenceTime));\n\t}\n}\n\nmodule.exports = FableServiceProgressTime;\n","class ProgressTracker\n{\n\tconstructor(pProgressTrackerSet, pProgressTrackerHash)\n\t{\n\t\tthis.progressTrackerSet = pProgressTrackerSet;\n\t\tthis.progressTrackerHash = pProgressTrackerHash;\n\n\t\tthis.data = this.progressTrackerSet.getProgressTrackerData(this.progressTrackerHash);\n\t}\n\n\tupdateProgressTracker(pProgressAmount)\n\t{\n\t\treturn this.progressTrackerSet.updateProgressTracker(this.progressTrackerHash, pProgressAmount);\n\t}\n\n\tincrementProgressTracker(pProgressIncrementAmount)\n\t{\n\t\treturn this.progressTrackerSet.incrementProgressTracker(this.progressTrackerHash, pProgressIncrementAmount);\n\t}\n\n\tsetProgressTrackerTotalOperations(pTotalOperationCount)\n\t{\n\t\treturn this.progressTrackerSet.setProgressTrackerTotalOperations(this.progressTrackerHash, pTotalOperationCount);\n\t}\n\n\tgetProgressTrackerStatusString()\n\t{\n\t\treturn this.progressTrackerSet.getProgressTrackerStatusString(this.progressTrackerHash);\n\t}\n}\n\nmodule.exports = ProgressTracker;","const libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libProgressTrackerClass = require('./Fable-Service-ProgressTracker/ProgressTracker.js');\n\nclass FableServiceProgressTrackerSet extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'ProgressTrackerSet';\n\n\t\tthis.progressTrackers = {};\n\n\t\t// Create an internal PorgressTime service to track timestamps\n\t\tthis.progressTimes = this.fable.instantiateServiceProviderWithoutRegistration('ProgressTime');\n\n\t\t// This timestamp is used and updated by *all* progress trackers.\n\t\tthis.progressTimes.createTimeStamp('CurrentTime');\n\t}\n\n\tgetProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\treturn new libProgressTrackerClass(this, pProgressTrackerHash);\n\t}\n\n\tgetProgressTrackerData(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tcreateProgressTracker(pProgressTrackerHash, pTotalOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tlet tmpProgressTracker = (\n\t\t\t{\n\t\t\t\tHash: tmpProgressTrackerHash,\n\n\t\t\t\tStartTimeHash: `${tmpProgressTrackerHash}-Start`,\n\t\t\t\tStartTimeStamp: -1,\n\t\t\t\tCurrentTimeStamp: -1,\n\t\t\t\tEndTimeHash: `${tmpProgressTrackerHash}-End`,\n\t\t\t\tEndTimeStamp: -1,\n\n\t\t\t\tPercentComplete: -1,\n\t\t\t\t// If this is set to true, PercentComplete will be calculated as CurrentCount / TotalCount even if it goes over 100%\n\t\t\t\tAllowTruePercentComplete: false,\n\n\t\t\t\tElapsedTime: -1,\n\t\t\t\tAverageOperationTime: -1,\n\t\t\t\tEstimatedCompletionTime: -1,\n\n\t\t\t\tTotalCount: tmpTotalOperations,\n\n\t\t\t\tCurrentCount:-1\n\t\t\t});\n\n\t\tif (tmpProgressTrackerHash in this.progressTrackers)\n\t\t{\n\t\t\tthis.fable.log.warn(`ProgressTracker ${tmpProgressTrackerHash} already exists!  Overwriting with a new tracker...`);\n\t\t\tthis.progressTimes.removeTimeStamp(tmpProgressTracker.StartTimeHash);\n\t\t\tthis.progressTimes.removeTimeStamp(tmpProgressTracker.EndTimeHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash] = tmpProgressTracker;\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tsetProgressTrackerTotalOperations(pProgressTrackerHash, pTotalOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to set the total operations of ProgressTracker ${tmpProgressTrackerHash} but it does not exist!  Creating a new tracker...`);\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, tmpTotalOperations);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].TotalCount = tmpTotalOperations;\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tstartProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This is the only method to lazily create ProgressTrackers now\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.createProgressTracker(tmpProgressTrackerHash, 100);\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tthis.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);\n\t\ttmpProgressTracker.StartTimeStamp = this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);\n\t\tif (tmpProgressTracker.CurrentCount < 0)\n\t\t{\n\t\t\ttmpProgressTracker.CurrentCount = 0;\n\t\t}\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tendProgressTracker(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.error(`Attempted to end ProgressTracker ${tmpProgressTrackerHash} that does not exist!`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tthis.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);\n\t\ttmpProgressTracker.EndTimeStamp = this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tsolveProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.error(`Attempted to solve ProgressTracker ${tmpProgressTrackerHash} that does not exist!`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\tif ((tmpProgressTracker.TotalCount < 1) || isNaN(tmpProgressTracker.TotalCount))\n\t\t{\n\t\t\tthis.fable.log.error(`ProgressTracker ${tmpProgressTracker.Hash} has an invalid total count of operations (${tmpProgressTracker.TotalCount}!  Setting it to the default of 100...`);\n\t\t\ttmpProgressTracker.TotalCount = 100;\n\t\t}\n\n\t\t// Compute the percentage of progress that is complete.\n\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = (tmpProgressTracker.CurrentCount / tmpProgressTracker.TotalCount) * 100.0;\n\t\t}\n\n\t\tif (!tmpProgressTracker.AllowTruePercentComplete && (tmpProgressTracker.PercentComplete > 100))\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = 100;\n\t\t}\n\n\t\t// Compute the average time per operation\n\t\tthis.progressTimes.updateTimeStampValue('CurrentTime');\n\t\ttmpProgressTracker.CurrentTimeStamp = this.progressTimes.getTimeStampValue('CurrentTime');\n\t\ttmpProgressTracker.ElapsedTime = tmpProgressTracker.CurrentTimeStamp - tmpProgressTracker.StartTimeStamp;\n\n\t\tif (tmpProgressTracker.EndTimeStamp > 0)\n\t\t{\n\t\t\ttmpProgressTracker.ElapsedTime = tmpProgressTracker.EndTimeStamp - tmpProgressTracker.StartTimeStamp;\n\t\t}\n\n\t\tif (tmpProgressTracker.CurrentCount > 0)\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = (tmpProgressTracker.CurrentTimeStamp-tmpProgressTracker.StartTimeStamp) / tmpProgressTracker.CurrentCount;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = -1;\n\t\t}\n\n\t\t// Compute the estimated completion\n\t\tif (tmpProgressTracker.AverageOperationTime > 0)\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = Math.max((tmpProgressTracker.TotalCount - tmpProgressTracker.CurrentCount), 0) * tmpProgressTracker.AverageOperationTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = -1;\n\t\t}\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tupdateProgressTracker(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to update ProgressTracker ${tmpProgressTrackerHash} with an invalid number of operations!`)\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = tmpCurrentOperations;\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tincrementProgressTracker(pProgressTrackerHash, pOperationIncrementAmount)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\t\tlet tmpOperationIncrementAmount = parseInt(pOperationIncrementAmount);\n\n\t\tif (isNaN(tmpOperationIncrementAmount))\n\t\t{\n\t\t\ttmpOperationIncrementAmount = 1;\n\t\t}\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to increment ProgressTracker ${tmpProgressTrackerHash} but it did not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.progressTrackers[tmpProgressTrackerHash].StartTimeStamp < 1)\n\t\t{\n\t\t\tthis.fable.log.warn(`Attempted to increment ProgressTracker ${tmpProgressTrackerHash} but it was not started.. starting now.`);\n\t\t\tthis.startProgressTracker(tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = this.progressTrackers[tmpProgressTrackerHash].CurrentCount + tmpOperationIncrementAmount;\n\n\t\treturn this.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\t}\n\n\tgetProgressTrackerCompletedOperationCountString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t// The states of a progress tracker:\n\t\tif (tmpProgressTracker.CurrentCount < 0)\n\t\t{\n\t\t\treturn `none`;\n\t\t}\n\t\telse if (tmpProgressTracker.CurrentCount < 1)\n\t\t{\n\t\t\treturn `0`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn `${tmpProgressTracker.CurrentCount}`;\n\t\t}\n\t}\n\n\tgetProgressTrackerPercentCompleteString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\t// TODO: Is there a pattern to avoid this double call that's worth putting in?\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\treturn `ProgressTracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\t// The states of a progress tracker:\n\t\t\t// 1. Not started\n\t\t\tif (tmpProgressTracker.StartTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `0%`;\n\t\t\t}\n\t\t\t// 2. Started, but no operations completed\n\n\t\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t\t{\n\t\t\t\treturn `0%`;\n\t\t\t}\n\t\t\t// 3. Started, some operations completed\n\t\t\telse if (tmpProgressTracker.EndTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `${tmpProgressTracker.PercentComplete.toFixed(3)}%`;\n\t\t\t}\n\t\t\t// 4. Done\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn `${tmpProgressTracker.PercentComplete.toFixed(3)}%`;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetProgressTrackerStatusString(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'Default';\n\n\t\t// This call here can mean if we add operations and then immediately get the string, this function runs twice.\n\t\t// TODO: Is there a pattern to avoid this double call that's worth putting in?\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\tif (!(tmpProgressTrackerHash in this.progressTrackers))\n\t\t{\n\t\t\treturn `ProgressTracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\t// The states of a progress tracker:\n\t\t\t// 1. Not started\n\t\t\tif (tmpProgressTracker.StartTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} has not been started yet.`;\n\t\t\t}\n\t\t\t// 2. Started, but no operations completed\n\n\t\t\tif ((tmpProgressTracker.CurrentCount < 1) && (tmpProgressTracker.EndTimeStamp < 1))\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} has no completed operations.  ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} have elapsed since it was started.`;\n\t\t\t}\n\t\t\t// 3. Started, some operations completed\n\t\t\telse if (tmpProgressTracker.EndTimeStamp < 1)\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} is ${tmpProgressTracker.PercentComplete.toFixed(3)}% completed - ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations over ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} (median ${this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)} per).  Estimated completion: ${this.progressTimes.formatTimeDuration(tmpProgressTracker.EstimatedCompletionTime)}`;\t\t\t}\n\t\t\t// 4. Done\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn `ProgressTracker ${tmpProgressTracker.Hash} is done.  ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations were completed in ${this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)} (median ${this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)} per).`;\n\t\t\t}\n\t\t}\n\t}\n\n\tlogProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tthis.fable.log.info(this.getProgressTrackerStatusString(pProgressTrackerHash));\n\t}\n}\n\nmodule.exports = FableServiceProgressTrackerSet;","const libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libSimpleGet = require('simple-get');\nconst libCookie = require('cookie');\n\nclass FableServiceRestClient extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.TraceLog = false;\n\t\tif (this.options.TraceLog || this.fable.TraceLog)\n\t\t{\n\t\t\tthis.TraceLog = true;\n\t\t}\n\n\t\tthis.dataFormat = this.fable.services.DataFormat;\n\n\t\tthis.serviceType = 'RestClient';\n\n\t\tthis.cookie = false;\n\n\t\t// This is a function that can be overridden, to allow the management\n\t\t// of the request options before they are passed to the request library.\n\t\tthis.prepareRequestOptions = (pOptions) => { return pOptions; };\n\t}\n\n\tget simpleGet()\n\t{\n\t\treturn libSimpleGet;\n\t}\n\n\tprepareCookies(pRequestOptions)\n\t{\n\t\tif (this.cookie)\n\t\t{\n\t\t\tlet tmpCookieObject = this.cookie;\n\t\t\tif (!('headers' in pRequestOptions))\n\t\t\t{\n\t\t\t\tpRequestOptions.headers = {};\n\t\t\t}\n\t\t\tlet tmpCookieKeys = Object.keys(tmpCookieObject);\n\t\t\tif (tmpCookieKeys.length > 0)\n\t\t\t{\n\t\t\t\t// Only grab the first for now.\n\t\t\t\tpRequestOptions.headers.cookie = libCookie.serialize(tmpCookieKeys[0], tmpCookieObject[tmpCookieKeys[0]]);\n\t\t\t}\n\t\t}\n\t\treturn pRequestOptions;\n\t}\n\n\tpreRequest(pOptions)\n\t{\n\t\t// Validate the options object\n\t\tlet tmpOptions = this.prepareCookies(pOptions);\n\n\t\t// Prepend a string to the URL if it exists in the Fable Config\n\t\tif ('RestClientURLPrefix' in this.fable.settings)\n\t\t{\n\t\t\ttmpOptions.url = this.fable.settings.RestClientURLPrefix + tmpOptions.url;\n\t\t}\n\n\t\treturn this.prepareRequestOptions(tmpOptions);\n\t}\n\n\texecuteChunkedRequest(pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpData = '';\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// For JSON, the chunk is the serialized object.\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> ${tmpOptions.method} completed data size ${tmpData.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, tmpData);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\texecuteChunkedRequestBinary(pOptions, fCallback)\n\t{\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\ttmpOptions.json = false;\n\t\ttmpOptions.encoding = null;\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpDataBuffer = false;\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// For JSON, the chunk is the serialized object.\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: Potentially create a third option that streams this to a file?  So it doesn't have to hold it all in memory.\n\t\t\t\t\t\tif (!tmpDataBuffer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDataBuffer = Buffer.from(pChunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpDataBuffer = Buffer.concat([tmpDataBuffer, pChunk]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> ${tmpOptions.method} completed data size ${tmpDataBuffer.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, tmpDataBuffer);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\texecuteJSONRequest(pOptions, fCallback)\n\t{\n\t\tpOptions.json = true;\n\n\t\tlet tmpOptions = this.preRequest(pOptions);\n\n\t\tif (!('headers' in tmpOptions))\n\t\t{\n\t\t\ttmpOptions.headers = {};\n\t\t}\n\t\t/* Automated headers break some APIs\n\t\tif (!('Content-Type' in tmpOptions.headers))\n\t\t{\n\t\t\ttmpOptions.headers['Content-Type'] = 'application/json';\n\t\t}\n\t\t*/\n\n\t\ttmpOptions.RequestStartTime = this.fable.log.getTimeStamp();\n\n\t\tif (this.TraceLog)\n\t\t{\n\t\t\tthis.fable.log.debug(`Beginning ${tmpOptions.method} JSON request to ${tmpOptions.url} at ${tmpOptions.RequestStartTime}`);\n\t\t}\n\n\t\treturn libSimpleGet(tmpOptions,\n\t\t\t(pError, pResponse)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\treturn fCallback(pError, pResponse);\n\t\t\t\t}\n\n\t\t\t\tif (this.TraceLog)\n\t\t\t\t{\n\t\t\t\t\tlet tmpConnectTime = this.fable.log.getTimeStamp();\n\t\t\t\t\tthis.fable.log.debug(`--> JSON ${tmpOptions.method} connected in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpConnectTime)}ms code ${pResponse.statusCode}`);\n\t\t\t\t}\n\n\t\t\t\tlet tmpJSONData = '';\n\n\t\t\t\tpResponse.on('data', (pChunk) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpChunkTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`--> JSON ${tmpOptions.method} data chunk size ${pChunk.length}b received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpChunkTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpJSONData += pChunk;\n\t\t\t\t\t});\n\n\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.TraceLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpCompletionTime = this.fable.log.getTimeStamp();\n\t\t\t\t\t\t\tthis.fable.log.debug(`==> JSON ${tmpOptions.method} completed - received in ${this.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime, tmpCompletionTime)}ms`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback(pError, pResponse, JSON.parse(tmpJSONData));\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tgetJSON(pOptionsOrURL, fCallback)\n\t{\n\t\tlet tmpRequestOptions = (typeof(pOptionsOrURL) == 'object') ? pOptionsOrURL : {};\n\t\tif (typeof(pOptionsOrURL) == 'string')\n\t\t{\n\t\t\ttmpRequestOptions.url = pOptionsOrURL;\n\t\t}\n\n\t\ttmpRequestOptions.method = 'GET';\n\n\t\treturn this.executeJSONRequest(tmpRequestOptions, fCallback);\n\t}\n\n\tputJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`PUT JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'PUT';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tpostJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`POST JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'POST';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tpatchJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`PATCH JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'PATCH';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\theadJSON(pOptions, fCallback)\n\t{\n\t\tif (typeof(pOptions.body) != 'object')\n\t\t{\n\t\t\treturn fCallback(new Error(`HEAD JSON Error Invalid options object`));\n\t\t}\n\n\t\tpOptions.method = 'HEAD';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tdelJSON(pOptions, fCallback)\n\t{\n\t\tpOptions.method = 'DELETE';\n\n\t\treturn this.executeJSONRequest(pOptions, fCallback);\n\t}\n\n\tgetRawText(pOptionsOrURL, fCallback)\n\t{\n\t\tlet tmpRequestOptions = (typeof(pOptionsOrURL) == 'object') ? pOptionsOrURL : {};\n\t\tif (typeof(pOptionsOrURL) == 'string')\n\t\t{\n\t\t\ttmpRequestOptions.url = pOptionsOrURL;\n\t\t}\n\n\t\ttmpRequestOptions.method = 'GET';\n\n\t\treturn this.executeChunkedRequest(tmpRequestOptions, fCallback);\n\t}\n}\n\nmodule.exports = FableServiceRestClient;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\nclass FableServiceTemplate extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.serviceType = 'Template';\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t\t\tEvaluate: /<%([\\s\\S]+?)%>/g,\n\t\t\t\tInterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t\t\t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t\t\t\tGuaranteedNonMatch: /.^/\n\t\t\t});\n\n\t\t// This is a helper for the escaper and unescaper functions.\n\t\t// Right now we are going to keep what underscore is doing, but, not forever.\n\t\tthis.templateEscapes = {\n\t\t\t'\\\\': '\\\\',\n\t\t\t\"'\": \"'\",\n\t\t\t'r': '\\r',\n\t\t\t'\\r': 'r',\n\t\t\t'n': '\\n',\n\t\t\t'\\n': 'n',\n\t\t\t't': '\\t',\n\t\t\t'\\t': 't',\n\t\t\t'u2028': '\\u2028',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'u2029': '\\u2029',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\t// This is defined as such to underscore that it is a dynamic programming\n\t\t// function on this class.\n\t\tthis.renderFunction = false;\n\t\tthis.templateString = false;\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction()\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n\t{\n\t\t// For now this is being kept in a weird form ... this is to mimic the old\n\t\t// underscore code until this is rewritten using precedent.\n\t\tthis.TemplateSource = \"__p+='\" + pTemplateText\n\t\t\t.replace(this.Matchers.Escaper,\n\t\t\t\t(pMatch)=>\n\t\t\t\t{\n\t\t\t\t\treturn `\\\\${this.templateEscapes[pMatch]}`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t\t\t\t})\n\t\t\t.replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n\t\t\t\t{\n\t\t\t\t\treturn `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t\t\t\t}) + `';\\n`;\n\n\n\t\tthis.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n\t\tthis.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n\t\tthis.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n\t\tif (typeof(pData) != 'undefined')\n\t\t{\n\t\t\treturn this.renderFunction(pData);\n\t\t}\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\tthis.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n\t\treturn this.templateFunction();\n\t}\n}\n\nmodule.exports = FableServiceTemplate;\n","const libFableServiceBase = require('fable-serviceproviderbase');\n\n// TODO: These are still pretty big -- consider the smaller polyfills\nconst libAsyncWaterfall = require('async.waterfall');\nconst libAsyncEachLimit = require('async.eachlimit');\n\nconst libBigNumber = require('big.js');\n\nclass FableServiceUtility extends libFableServiceBase\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\tthis.templates = {};\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\n\t\tthis.bigNumber = libBigNumber;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\t// Nevermind, the native thing is not stable enough across environments\n\t// Basic shallow copy\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\tfor (let i = 0; i < pSourceObjects.length; i++)\n\t\t{\n\t\t\tlet tmpSourceObject = pSourceObjects[i];\n\t\t\tif (typeof(tmpSourceObject) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpObjectProperties = Object.keys(tmpSourceObject);\n\t\t\t\tfor (let k = 0; k < tmpObjectProperties.length; k++)\n\t\t\t\t{\n\t\t\t\t\tpDestinationObject[tmpObjectProperties[k]] = tmpSourceObject[tmpObjectProperties[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pDestinationObject;\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.instantiateServiceProviderWithoutRegistration('Template');\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// Build a template function from a template hash, and, register it with the service provider\n\tbuildHashedTemplate(pTemplateHash, pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = this.fable.instantiateServiceProvider('Template', {}, pTemplateHash);\n\t\tthis.templates[pTemplateHash] = tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t\treturn this.templates[pTemplateHash];\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n\n\t/**\n\t * Get a value from fable/pict by hash/address\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t */\n\tgetInternalValueByHash(pValueAddress)\n\t{\n\t\t// Get the value from the internal manifest and return it\n\t\treturn this.getValueByHash(this.fable, pValueAddress);\n\t}\n\n\t/**\n\t * Set a value from fable/pict by hash/address\n\t *\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {any} pValue - The value to set\n\t */\n\tsetInternalValueByHash(pValueAddress, pValue)\n\t{\n\t\t// Get the value from the internal manifest and return it\n\t\treturn this.setValueByHash(this.fable, pValueAddress, pValue);\n\t}\n\n\t/**\n\t * Get a value from an object by hash/address\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value from the object\n\t */\n\tgetValueByHash(pObject, pValueAddress, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpManifest.getValueByHash(pObject, pValueAddress);\n\t}\n\n\t/**\n\t * Set a value to an object by hash/address\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} pValue - The value to set\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value from the object\n\t */\n\tsetValueByHash(pObject, pValueAddress, pValue, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpManifest.setValueByHash(pObject, pValueAddress, pValue);\n\t}\n\n\t/**\n\t * Get a value array from an object by hash/address list\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueArrayByHashes(pObject, pValueHashes, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\tif (!Array.isArray(pValueHashes))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpValueArray = [];\n\t\tfor (let i = 0; i < pValueHashes.length; i++)\n\t\t{\n\t\t\ttmpValueArray.push(tmpManifest.getValueByHash(pObject, pValueHashes[i]));\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpValueArray;\n\t}\n\n\tslice(pValueArray, pStartIndex, pEndIndex)\n\t{\n\t\tif (!Array.isArray(pValueArray))\n\t\t{\n\t\t\tthis.fable.log.error('Fable.Math.slice called with non-array value', { pValueArray });\n\t\t\treturn [];\n\t\t}\n\t\tconst tmpStartIndex = Number(this.fable.Math.parsePrecise(pStartIndex, '0'));\n\t\tconst tmpEndIndex = Number(this.fable.Math.parsePrecise(pEndIndex, pValueArray.length.toString()));\n\t\treturn pValueArray.slice(tmpStartIndex, tmpEndIndex);\n\t}\n\n\t/**\n\t * Get a value array by hash/address list from the internal fable/pict state\n\t * @param {string} pValueHashes - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueArrayByHashesFromInternal(pValueHashes, pManifest)\n\t{\n\t\treturn this.createValueArrayByHashes(this.fable, pValueHashes, pManifest);\n\t}\n\n\tcreateValueArrayByHashParametersFromInternal()\n\t{\n\t\tif (arguments.length < 2)\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tlet tmpValueHashes = Array.prototype.slice.call(arguments);\n\t\treturn this.createValueArrayByHashes(this.fable, tmpValueHashes);\n\t}\n\n\t/**\n\t * Get a value object from a list of hash/addressese\n\t * @param {object} pObject - The object to get the value from\n\t * @param {string} pValueHashes - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value object built from the hash list\n\t */\n\tcreateValueObjectByHashes(pObject, pValueHashes, pManifest)\n\t{\n\t\tlet tmpManifest = pManifest;\n\n\t\tif (typeof(tmpManifest) == 'undefined')\n\t\t{\n\t\t\t// Lazily create a manifest if it doesn't exist\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpManifest = this.manifest;\n\t\t}\n\n\t\tif (!Array.isArray(pValueHashes))\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tlet tmpValueObject = {};\n\t\tfor (let i = 0; i < pValueHashes.length; i++)\n\t\t{\n\t\t\ttmpValueObject[pValueHashes[i]] = tmpManifest.getValueByHash(pObject, pValueHashes[i]);\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\treturn tmpValueObject;\n\t}\n\n\t/**\n\t * Get a value object by hash/address list from the internal fable/pict state\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to get\n\t * @param {object} [pManifest] - The manyfest object to use; constructs one inline if not provided\n\t * @returns {object} - The value object built from the hash list\n\t */\n\tcreateValueObjectByHashesFromInternal(pValueHashes, pManifest)\n\t{\n\t\treturn this.createValueObjectByHashes(this.fable, pValueHashes, pManifest);\n\t}\n\n\t/**\n\t * Get a value object by hash/address list as parameters from the internal fable/pict state\n\t * @returns {Array} - The value array built from the hash list\n\t */\n\tcreateValueObjectByHashParametersFromInternal()\n\t{\n\t\tlet tmpValueHashes = Array.prototype.slice.call(arguments);\n\t\treturn this.createValueObjectByHashes(this.fable, tmpValueHashes);\n\t}\n\n\n\t/**\n\t * Check if a value is null or empty\n\t * @param {object} pObject - The object to check\n\t * @param {string} pValueAddress - The manyfest hash/address to check\n\t */\n\taddressIsNullOrEmpty(pObject, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\t// If it doesn't exist, it is null or empty.\n\t\tif (!this.manifest.checkAddressExists(pObject, pValueAddress))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the value from the internal manifest and return it\n\t\tlet tmpValue = this.manifest.getValueByHash(pObject, pValueAddress);\n\t\tif (tmpValue === null || tmpValue === '')\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Convert objects to arrays of labels or values for solvers\n\tobjectKeysToArray(pObject)\n\t{\n\t\treturn Object.keys(pObject);\n\t}\n\n\t// Convert object values to an array of values\n\tobjectValuesToArray(pObject)\n\t{\n\t\tif ((typeof(pObject) !== 'object') || (pObject === null))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\t\tlet tmpKeys = Object.keys(pObject);\n\t\tlet tmpValues = [];\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\ttmpValues.push(pObject[tmpKeys[i]]);\n\t\t}\n\n\t\treturn tmpValues;\n\t}\n\n\tobjectValuesSortByExternalArray(pArray, pObjectArray, pDescending, pSearchAddress)\n\t{\n\t\tlet tmpDescending = (typeof(pDescending) == 'boolean') ? pDescending :\n\t\t\t\t\t\t\t((typeof(pDescending) == 'number') && (pDescending == 1)) ? true :\n\t\t\t\t\t\t\t((typeof(pDescending) == 'string') && (pDescending == '1')) ? true :\n\t\t\t\t\t\t\tfalse;\n\t\tlet tmpManifest = this.fable.newManyfest();\n\n\t\tlet tmpSearchAddresses = pSearchAddress;\n\n\t\tif (typeof(tmpSearchAddresses) != 'string')\n\t\t{\n\t\t\t// Defaulting to \"label\"...\n\t\t\ttmpSearchAddresses = 'label';\n\t\t}\n\n\t\tlet tmpSortHelperArray = [];\n\n\t\tfor (let i = 0; i < pArray.length; i++)\n\t\t{\n\t\t\ttmpSortHelperArray.push(\n\t\t\t\t{\n\t\t\t\t\tValue: pArray[i],\n\t\t\t\t\tSortValue: tmpManifest.getValueByHash(pObjectArray[i], tmpSearchAddresses),\n\t\t\t\t\tSortObject: pObjectArray[i]\n\t\t\t\t});\n\t\t}\n\n\t\tlet tmpSortedArray = tmpSortHelperArray.sort((pLeft, pRight) =>\n\t\t{\n\t\t\tif (pLeft.SortValue < pRight.SortValue)\n\t\t\t{\n\t\t\t\treturn tmpDescending ? 1 : -1;\n\t\t\t}\n\t\t\tif (pLeft.SortValue > pRight.SortValue)\n\t\t\t{\n\t\t\t\treturn tmpDescending ? -1 : 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}).map((pSortHelperArrayObject) => { return pSortHelperArrayObject.Value; });\n\n\t\treturn tmpSortedArray;\n\t}\n\n\t// Convert an ISO string to a javascript date object\n\t// Adapted from https://stackoverflow.com/a/54751179\n\t//\n\t// Takes strings like: 2022-11-04T11:34:45.000Z\n\t//                and: 1986-06-11T09:34:46.012Z+0200\n\t// ... and converts them into javascript timestamps, following the directions of the timezone stuff.\n\t//\n\t// This is not meant to replace the more complex libraries such as moment or luxon.\n\t// This *is* meant to be a simple, small, and fast way to convert ISO strings to dates in engines\n\t// with ultra limited JS capabilities where those don't work.\n\tisoStringToDate (pISOString)\n\t{\n\t\tif (!('Dates' in this.fable))\n\t\t{\n\t\t\tthis.fable.instantiateServiceProvider('Dates');\n\t\t}\n\n\t\tlet tmpDate = false;\n\n\t\ttry\n\t\t{\n\t\t\ttmpDate = this.fable.Dates.dayJS.utc(pISOString);\n\t\t}\n\t\tcatch(pError)\n\t\t{\n\t\t\t// TODO: Should this throw?  Doubtful.\n\t\t\tthis.fable.log.error(`Could not parse date string ${pISOString} with dayJS.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tmpDate)\n\t\t{\n\t\t\treturn tmpDate.toDate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {array} pObjectArray - The array of objects to search\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByStringIncludes(pObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (!Array.isArray(pObjectArray))\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (let i = 0; i < pObjectArray.length; i++)\n\t\t{\n\t\t\tlet tmpValueToMatch = this.manifest.getValueByHash(pObjectArray[i], pValueToMatchAddress);\n\t\t\tif (tmpValueToMatch && (tmpValueToMatch.includes(pValueToMatch)))\n\t\t\t{\n\t\t\t\treturn this.manifest.getValueByHash(pObjectArray[i], pValueAddress);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {string} pFableAddress - The address in the fable object to pull the value from\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByStringIncludesInternal(pFableAddress, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (typeof(pFableAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpObjectArray = this.manifest.getValueByHash(this.fable, pFableAddress);\n\n\t\treturn this.findFirstValueByStringIncludes(tmpObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress);\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {array} pObjectArray - The array of objects to search\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByExactMatch(pObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (!Array.isArray(pObjectArray))\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (let i = 0; i < pObjectArray.length; i++)\n\t\t{\n\t\t\tlet tmpValueToMatch = this.manifest.getValueByHash(pObjectArray[i], pValueToMatchAddress);\n\t\t\tif (tmpValueToMatch && (tmpValueToMatch == pValueToMatch))\n\t\t\t{\n\t\t\t\treturn this.manifest.getValueByHash(pObjectArray[i], pValueAddress);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Find the first value in an object that contains a specific value\n\t * @param {string} pFableAddress - The address in the fable object to pull the value from\n\t * @param {string} pValueToMatchAddress - The manyfest hash/address of the value to match\n\t * @param {string} pValueToMatch - The value to match\n\t * @param {string} pValueAddress - The manyfest hash/address of the value to return\n\t * @returns {any} - The value from the object\n\t */\n\tfindFirstValueByExactMatchInternal(pFableAddress, pValueToMatchAddress, pValueToMatch, pValueAddress)\n\t{\n\t\t// Lazily create a manifest if it doesn't exist\n\t\tif (!this.manifest)\n\t\t{\n\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t}\n\n\t\tif (typeof(pFableAddress) != 'string')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpObjectArray = this.manifest.getValueByHash(this.fable, pFableAddress);\n\n\t\treturn this.findFirstValueByExactMatch(tmpObjectArray, pValueToMatchAddress, pValueToMatch, pValueAddress);\n\t}\n\n\t/**\n\t * Find the index of a value in an array, using the specified search mode.\n\t *\n\t * @param {any} pValueToFind - The value to find.\n\t * @param {Array<any>|string} pSearchArray - The array to search, or the address of such an array.\n\t * @param {string|number} [pSearchMode='1'] - The search mode ('0' for exact match, '1' (or default) for searching sorted sets and finding the first value >= the specifid value. '-1' is the same behavior as '1' but sorted descending.\n\t *\n\t * @returns {number} - The index of the found value, or -1 if not found.\n\t */\n\tfindIndexInternal(pValueToFind, pSearchArray, pSearchMode = '1')\n\t{\n\t\tlet tmpSearchArray = pSearchArray;\n\t\tif (typeof (pSearchArray) === 'string')\n\t\t{\n\t\t\tif (!this.manifest)\n\t\t\t{\n\t\t\t\tthis.manifest = this.fable.newManyfest();\n\t\t\t}\n\t\t\ttmpSearchArray = this.manifest.getValueByHash(this.fable, pSearchArray);\n\t\t}\n\n\t\tif (!Array.isArray(tmpSearchArray))\n\t\t{\n\t\t\tthis.fable.log.error('findIndexInternal called with non-array search array.');\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst tmpIsNumericSearch = this.fable.Math.parsePrecise(pValueToFind, null) !== null;\n\t\tlet tmpMatchIndex = -1;\n\t\tlet tmpComparisonFunction;\n\t\tif (Number(pSearchMode) === 0)\n\t\t{\n\t\t\t// Exact match\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.comparePrecise(pCandidate, pValueToFind) === 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate === pValueToFind;\n\t\t\t}\n\t\t}\n\t\telse if (Number(pSearchMode) === -1)\n\t\t{\n\t\t\t// Sorted descending\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.ltePrecise(pCandidate, pValueToFind);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate <= pValueToFind;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Sorted ascending\n\t\t\tif (tmpIsNumericSearch)\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => this.fable.Math.gtePrecise(pCandidate, pValueToFind);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpComparisonFunction = (pCandidate) => pCandidate >= pValueToFind;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < tmpSearchArray.length; i++)\n\t\t{\n\t\t\tif (tmpComparisonFunction(tmpSearchArray[i]))\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Flatten an array of solver inputs into a single array\n\t *\n\t * @param {Array<any>} pInputArray - The array of inputs to flatten\n\t * @return {Array<any>} - The flattened array\n\t */\n\tflattenArrayOfSolverInputs(pInputArray)\n\t{\n\t\tif (!Array.isArray(pInputArray))\n\t\t{\n\t\t\tif (typeof pInputArray === 'object')\n\t\t\t{\n\t\t\t\tpInputArray = Object.values(pInputArray);\n\t\t\t}\n\t\t\tif (!pInputArray)\n\t\t\t{\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t\tconst tmpArrayFlattener = (p) =>\n\t\t{\n\t\t\tif (Array.isArray(p))\n\t\t\t{\n\t\t\t\treturn p; // .flatMap(tmpArrayFlattener);\n\t\t\t}\n\t\t\tif (typeof p === 'object')\n\t\t\t{\n\t\t\t\treturn Object.values(p);\n\t\t\t}\n\t\t\treturn [ p ];\n\t\t};\n\t\treturn pInputArray.flatMap(tmpArrayFlattener);\n\t}\n\n\tgenerateArrayOfObjectsFromSets()\n\t{\n\t\t// For each argument pair, map data to an array of objects with the first parameter of the pairs as the property name and the second parameter as the array of values\n\t\tlet tmpResultArray = [];\n\t\tif (arguments.length % 2 != 0)\n\t\t{\n\t\t\t// Must be pairs\n\t\t\treturn tmpResultArray;\n\t\t}\n\n\t\tlet tmpPropertyNames = [];\n\t\tlet tmpValueArrays = [];\n\n\t\tfor (let i = 0; i < arguments.length; i += 2)\n\t\t{\n\t\t\ttmpPropertyNames.push(arguments[i]);\n\t\t\ttmpValueArrays.push(this.objectValuesToArray(arguments[i + 1]));\n\t\t}\n\n\t\tfor (let h = 0; h < tmpValueArrays.length; h++)\n\t\t{\n\t\t\tlet tmpValueArray = tmpValueArrays[h];\n\t\t\tlet tmpPropertyName = tmpPropertyNames[h];\n\t\t\tif (!Array.isArray(tmpValueArray))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0; i < tmpValueArray.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpResultArray.length <= i)\n\t\t\t\t{\n\t\t\t\t\ttmpResultArray.push({});\n\t\t\t\t}\n\n\t\t\t\tlet tmpObject = tmpResultArray[i];\n\t\t\t\tif (!tmpObject)\n\t\t\t\t{\n\t\t\t\t\t// This shouldn't be possible\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttmpObject[tmpPropertyName] = tmpValueArray[i];\n\t\t\t}\n\t\t}\n\n\t\treturn tmpResultArray;\n\t}\n\n\t/**\n\t * Take a set of arbitrary parameters and build an array from them\n\t * @returns {Array} - An array built from the absolute values of the parameters\n\t */\n\tcreateArrayFromAbsoluteValues()\n\t{\n\t\tlet tmpArray = [];\n\t\tfor (let i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\ttmpArray.push(arguments[i]);\n\t\t}\n\t\treturn tmpArray;\n\t}\n\n\t/**\n\t * Concatenate multiple arrays into a single array\n\t *\n\t * @return {Array<any>} - The concatenated array\n\t */\n\tconcatenateArrays()\n\t{\n\t\tlet tmpResultArray = [];\n\t\tfor (let i = 0; i < arguments.length; ++i)\n\t\t{\n\t\t\tlet tmpArray = arguments[i];\n\t\t\tif (Array.isArray(tmpArray))\n\t\t\t{\n\t\t\t\ttmpResultArray = tmpResultArray.concat(tmpArray);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.fable.log.error('Fable.Service.Utility.concatenateArrays called with non-array argument', { index: i, value: tmpArray });\n\t\t\t}\n\t\t}\n\t\treturn tmpResultArray;\n\t}\n}\n\nmodule.exports = FableServiceUtility;\n","\nclass SetConcatArray\n{\n\t/**\n\t * @param {Array<any>|SetConcatArray} pLeftValue - The left value to concatenate.\n\t * @param {Array<any>|SetConcatArray} pRightValue - The right value to concatenate.\n\t */\n\tconstructor(pLeftValue, pRightValue)\n\t{\n\t\tif (pLeftValue instanceof SetConcatArray)\n\t\t{\n\t\t\tthis.values = pLeftValue.values.concat([ pRightValue ]);\n\t\t}\n\t\telse if (pRightValue instanceof SetConcatArray)\n\t\t{\n\t\t\tthis.values = [ pLeftValue ].concat(pRightValue.values);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.values = [ pLeftValue, pRightValue ];\n\t\t}\n\t}\n}\n\nmodule.exports = SetConcatArray;\n"]}